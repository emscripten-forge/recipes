<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>LiquidFun Programmer&#39;s Guide: Joints</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">LiquidFun Programmer&#39;s Guide
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('md__chapter08__joints.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">Joints </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a href="#about">About</a><br/>
 <a href="#jd">Joint Definition</a><br/>
 <a href="#jf">Joint Factory</a><br/>
 <a href="#uj">Using Joints</a><br/>
</p>
<p><a class="anchor" id="about"></a></p>
<h2>About</h2>
<p>Joints are used to constrain bodies to the world or to each other. Typical examples in games include ragdolls, teeters, and pulleys. Joints can be combined in many different ways to create interesting motions.</p>
<p>Some joints provide limits so you can control the range of motion. Some joint provide motors which can be used to drive the joint at a prescribed speed until a prescribed force/torque is exceeded.</p>
<p>Joint motors can be used in many ways. You can use motors to control position by specifying a joint velocity that is proportional to the difference between the actual and desired position. You can also use motors to simulate joint friction: set the joint velocity to zero and provide a small, but significant maximum motor force/torque. Then the motor will attempt to keep the joint from moving until the load becomes too strong.</p>
<p><a class="anchor" id="jd"></a> </p>
<h2>Joint Definition</h2>
<p>Each joint type has a definition that derives from b2JointDef. All joints are connected between two different bodies. One body may static. Joints between static and/or kinematic bodies are allowed, but have no effect and use some processing time.</p>
<p>You can specify user data for any joint type and you can provide a flag to prevent the attached bodies from colliding with each other. This is actually the default behavior and you must set the collideConnected Boolean to allow collision between to connected bodies.</p>
<p>Many joint definitions require that you provide some geometric data. Often a joint will be defined by anchor points. These are points fixed in the attached bodies. LiquidFun requires these points to be specified in local coordinates. This way the joint can be specified even when the current body transforms violate the joint constraint &mdash; a common occurrence when a game is saved and reloaded. Additionally, some joint definitions need to know the default relative angle between the bodies. This is necessary to constrain rotation correctly.</p>
<p>Initializing the geometric data can be tedious, so many joints have initialization functions that use the current body transforms to remove much of the work. However, these initialization functions should usually only be used for prototyping. Production code should define the geometry directly. This will make joint behavior more robust.</p>
<p>The rest of the joint definition data depends on the joint type. We cover these now.</p>
<p><a class="anchor" id="jf"></a> </p>
<h2>Joint Factory</h2>
<p>Joints are created and destroyed using the world factory methods. This brings up an old issue: </p>
<pre class="fragment">Caution

Don't try to create a joint on the stack or on the heap using new or malloc.  You must create and destroy bodies and joints using the create and destroy methods of the b2World class.
</pre><p>Here's an example of the lifetime of a revolute joint:</p>
<p>&#160;&#160;&#160;<code>b2RevoluteJointDef jointDef;</code><br/>
 &#160;&#160;&#160;<code>jointDef.bodyA = myBodyA;</code><br/>
 &#160;&#160;&#160;<code>jointDef.bodyB = myBodyB;</code><br/>
 &#160;&#160;&#160;<code>jointDef.anchorPoint = myBodyA-&gt;GetCenterPosition();</code><br/>
 &#160;&#160;&#160;<code>b2RevoluteJoint* joint = (b2RevoluteJoint*)myWorld-&gt;CreateJoint(&amp;jointDef);</code><br/>
 &#160;&#160;&#160;<code>… do stuff …</code><br/>
 &#160;&#160;&#160;<code>myWorld-&gt;DestroyJoint(joint);</code><br/>
 &#160;&#160;&#160;<code>joint = NULL;</code><br/>
</p>
<p>It is always good to nullify your pointer after they are destroyed. This will make the program crash in a controlled manner if you try to reuse the pointer.</p>
<p>The lifetime of a joint is not simple. Heed this warning well: </p>
<pre class="fragment">Caution

Joints are destroyed when an attached body is destroyed.
</pre><p>This precaution is not always necessary. You may organize your game engine so that joints are always destroyed before the attached bodies. In this case you don't need to implement the listener class. See the section on Implicit Destruction for details.</p>
<p><a class="anchor" id="uj"></a> </p>
<h2>Using Joints</h2>
<p>Many simulations create the joints and don't access them again until they are destroyed. However, there is a lot of useful data contained in joints that you can use to create a rich simulation.</p>
<p>First of all, you can get the bodies, anchor points, and user data from a joint.</p>
<p>&#160;&#160;&#160;<code>b2Body* GetBodyA();</code></p>
<p>&#160;&#160;&#160;<code>b2Body* GetBodyB();</code></p>
<p>&#160;&#160;&#160;<code>b2Vec2 GetAnchorA();</code></p>
<p>&#160;&#160;&#160;<code>b2Vec2 GetAnchorB();</code></p>
<p>&#160;&#160;&#160;<code>void* GetUserData();</code></p>
<p>All joints have a reaction force and torque. This the reaction force applied to body 2 at the anchor point. You can use reaction forces to break joints or trigger other game events. These functions may do some computations, so don't call them if you don't need the result.</p>
<p>&#160;&#160;&#160;<code>b2Vec2 GetReactionForce();</code><br/>
</p>
<p>&#160;&#160;&#160;<code>float32 GetReactionTorque();</code><br/>
</p>
<h3>Distance Joint</h3>
<p>One of the simplest joint is a distance joint which says that the distance between two points on two bodies must be constant. When you specify a distance joint the two bodies should already be in place. Then you specify the two anchor points in world coordinates. The first anchor point is connected to body 1, and the second anchor point is connected to body 2. These points imply the length of the distance constraint.</p>
<div class="image">
<img src="image_18.gif"  align="center" alt="Distance joint" height="118" width="155"/>
</div>
<p><br/>
</p>
<p>Here is an example of a distance joint definition. In this case we decide to allow the bodies to collide.</p>
<p>&#160;&#160;&#160;<code>b2DistanceJointDef jointDef;</code><br/>
 &#160;&#160;&#160;<code>jointDef.Initialize(myBodyA, myBodyB, worldAnchorOnBodyA, worldAnchorOnBodyB);</code><br/>
 &#160;&#160;&#160;<code>jointDef.collideConnected = true;</code><br/>
</p>
<p>The distance joint can also be made soft, like a spring-damper connection. See the Web example in the testbed to see how this behaves.</p>
<p>Softness is achieved by tuning two constants in the definition: frequency and damping ratio. Think of the frequency as the frequency of a harmonic oscillator (like a guitar string). The frequency is specified in Hertz. Typically the frequency should be less than a half the frequency of the time step. So if you are using a 60Hz time step, the frequency of the distance joint should be less than 30Hz. The reason is related to the Nyquist frequency.</p>
<p>The damping ratio is non-dimensional and is typically between 0 and 1, but can be larger. At 1, the damping is critical (all oscillations should vanish).</p>
<p>&#160;&#160;&#160;<code>jointDef.frequencyHz = 4.0f;</code><br/>
 &#160;&#160;&#160;<code>jointDef.dampingRatio = 0.5f;</code><br/>
</p>
<h3>Revolute Joint</h3>
<p>A revolute joint forces two bodies to share a common anchor point, often called a hinge point. The revolute joint has a single degree of freedom: the relative rotation of the two bodies. This is called the joint angle.</p>
<div class="image">
<img src="image_19.gif"  align="center" alt="Revolute joint" height="97" width="139"/>
</div>
<p><br/>
</p>
<p>To specify a revolute you need to provide two bodies and a single anchor point in world space. The initialization function assumes that the bodies are already in the correct position.</p>
<p>In this example, two bodies are connected by a revolute joint at the first body's center of mass.</p>
<p>&#160;&#160;&#160;<code>b2RevoluteJointDef jointDef;</code><br/>
 &#160;&#160;&#160;<code>jointDef.Initialize(myBodyA, myBodyB, myBodyA-&gt;GetWorldCenter());</code><br/>
</p>
<p>The revolute joint angle is positive when bodyB rotates CCW about the angle point. Like all angles in LiquidFun, the revolute angle is measured in radians. By convention the revolute joint angle is zero when the joint is created using Initialize(), regardless of the current rotation of the two bodies.</p>
<p>In some cases you might wish to control the joint angle. For this, the revolute joint can optionally simulate a joint limit and/or a motor.</p>
<p>A joint limit forces the joint angle to remain between a lower and upper bound. The limit will apply as much torque as needed to make this happen. The limit range should include zero, otherwise the joint will lurch when the simulation begins.</p>
<p>A joint motor allows you to specify the joint speed (the time derivative of the angle). The speed can be negative or positive. A motor can have infinite force, but this is usually not desirable. Recall the eternal question:</p>
<p>*"What happens when an irresistible force meets an immovable object?"*</p>
<p>I can tell you it's not pretty. So you can provide a maximum torque for the joint motor. The joint motor will maintain the specified speed unless the required torque exceeds the specified maximum. When the maximum torque is exceeded, the joint will slow down and can even reverse.</p>
<p>You can use a joint motor to simulate joint friction. Just set the joint speed to zero, and set the maximum torque to some small, but significant value. The motor will try to prevent the joint from rotating, but will yield to a significant load.</p>
<p>Here's a revision of the revolute joint definition above; this time the joint has a limit and a motor enabled. The motor is setup to simulate joint friction.</p>
<p>b2RevoluteJointDef jointDef; jointDef.Initialize(bodyA, bodyB, myBodyA-&gt;GetWorldCenter()); jointDef.lowerAngle = -0.5f * b2_pi; // -90 degrees jointDef.upperAngle = 0.25f * b2_pi; // 45 degrees jointDef.enableLimit = true; jointDef.maxMotorTorque = 10.0f; jointDef.motorSpeed = 0.0f; jointDef.enableMotor = true;</p>
<p>You can access a revolute joint's angle, speed, and motor torque.</p>
<p>&#160;&#160;&#160;<code>float32 GetJointAngle() const;</code><br/>
 &#160;&#160;&#160;<code>float32 GetJointSpeed() const;</code><br/>
 &#160;&#160;&#160;<code>float32 GetMotorTorque() const;</code><br/>
</p>
<p>You also update the motor parameters each step.</p>
<p>&#160;&#160;&#160;<code>void SetMotorSpeed(float32 speed);</code><br/>
 &#160;&#160;&#160;<code>void SetMaxMotorTorque(float32 torque);</code><br/>
</p>
<p>Joint motors have some interesting abilities. You can update the joint speed every time step so you can make the joint move back-and-forth like a sine-wave or according to whatever function you want.</p>
<p>&#160;&#160;&#160;<code>... Game Loop Begin ...</code><br/>
 &#160;&#160;&#160;<code>myJoint-&gt;SetMotorSpeed(cosf(0.5f * time));</code><br/>
 &#160;&#160;&#160;<code>... Game Loop End ...</code><br/>
</p>
<p>You can also use joint motors to track a desired joint angle. For example:</p>
<p>&#160;&#160;&#160;<code>... Game Loop Begin ...</code><br/>
 &#160;&#160;&#160;<code>float32 angleError = myJoint-&gt;GetJointAngle() - angleTarget;</code><br/>
 &#160;&#160;&#160;<code>float32 gain = 0.1f;</code><br/>
 &#160;&#160;&#160;<code>myJoint-&gt;SetMotorSpeed(-gain * angleError);</code><br/>
 &#160;&#160;&#160;<code>... Game Loop End ...</code><br/>
</p>
<p>Generally your gain parameter should not be too large. Otherwise your joint may become unstable.</p>
<h3>Prismatic Joint</h3>
<p>A prismatic joint allows for relative translation of two bodies along a specified axis. A prismatic joint prevents relative rotation. Therefore, a prismatic joint has a single degree of freedom.</p>
<div class="image">
<img src="image_20.gif"  align="center" alt="Prismatic joint" height="134" width="165"/>
</div>
<p><br/>
</p>
<p>The prismatic joint definition is similar to the revolute joint description; just substitute translation for angle and force for torque. Using this analogy provides an example prismatic joint definition with a joint limit and a friction motor:</p>
<p>&#160;&#160;&#160;<code>b2PrismaticJointDef jointDef;</code><br/>
 &#160;&#160;&#160;<code>b2Vec2 worldAxis(1.0f, 0.0f);</code><br/>
 &#160;&#160;&#160;<code>jointDef.Initialize(myBodyA, myBodyB, myBodyA-&gt;GetWorldCenter(), worldAxis);</code><br/>
 &#160;&#160;&#160;<code>jointDef.lowerTranslation = -5.0f;</code><br/>
 &#160;&#160;&#160;<code>jointDef.upperTranslation = 2.5f;</code><br/>
 &#160;&#160;&#160;<code>jointDef.enableLimit = true;</code><br/>
 &#160;&#160;&#160;<code>jointDef.maxMotorForce = 1.0f;</code><br/>
 &#160;&#160;&#160;<code>jointDef.motorSpeed = 0.0f;</code><br/>
 &#160;&#160;&#160;<code>jointDef.enableMotor = true;</code><br/>
</p>
<p>The revolute joint has an implicit axis coming out of the screen. The prismatic joint needs an explicit axis parallel to the screen. This axis is fixed in the two bodies and follows their motion.</p>
<p>Like the revolute joint, the prismatic joint translation is zero when the joint is created using Initialize(). So be sure zero is between your lower and upper translation limits.</p>
<p>Using a prismatic joint is similar to using a revolute joint. Here are the relevant member functions:</p>
<p>&#160;&#160;&#160;<code>float32 GetJointTranslation() const;</code></p>
<p>&#160;&#160;&#160;<code>float32 GetJointSpeed() const;</code></p>
<p>&#160;&#160;&#160;<code>float32 GetMotorForce() const;</code></p>
<p>&#160;&#160;&#160;<code>void SetMotorSpeed(float32 speed);</code></p>
<p>&#160;&#160;&#160;<code>void SetMotorForce(float32 force);</code></p>
<h3>Pulley Joint</h3>
<p>A pulley is used to create an idealized pulley. The pulley connects two bodies to ground and to each other. As one body goes up, the other goes down. The total length of the pulley rope is conserved according to the initial configuration.</p>
<p>length1 + length2 == constant</p>
<p>You can supply a ratio that simulates a block and tackle. This causes one side of the pulley to extend faster than the other. At the same time the constraint force is smaller on one side than the other. You can use this to create mechanical leverage.</p>
<p>length1 + ratio * length2 == constant</p>
<p>For example, if the ratio is 2, then length1 will vary at twice the rate of length2. Also the force in the rope attached to body1 will have half the constraint force as the rope attached to body2.</p>
<div class="image">
<img src="image_21.gif"  align="center" alt="Pulley joint" height="213" width="237"/>
</div>
<p><br/>
</p>
<p>Pulleys can be troublesome when one side is fully extended. The rope on the other side will have zero length. At this point the constraint equations become singular (bad). You should configure collision shapes to prevent this.</p>
<p>Here is an example pulley definition:</p>
<p>&#160;&#160;&#160;<code>b2Vec2 anchor1 = myBody1-&gt;GetWorldCenter();</code><br/>
 &#160;&#160;&#160;<code>b2Vec2 anchor2 = myBody2-&gt;GetWorldCenter();</code><br/>
 &#160;&#160;&#160;<code>b2Vec2 groundAnchor1(p1.x, p1.y + 10.0f);</code><br/>
 &#160;&#160;&#160;<code>b2Vec2 groundAnchor2(p2.x, p2.y + 12.0f);</code><br/>
 &#160;&#160;&#160;<code>float32 ratio = 1.0f;</code><br/>
 &#160;&#160;&#160;<code>b2PulleyJointDef jointDef;</code><br/>
 &#160;&#160;&#160;<code>jointDef.Initialize(myBody1, myBody2, groundAnchor1, groundAnchor2, anchor1, anchor2, ratio);</code><br/>
</p>
<p>Pulley joints provide the current lengths.</p>
<p>&#160;&#160;&#160;<code>float32 GetLengthA() const;</code><br/>
 &#160;&#160;&#160;<code>float32 GetLengthB() const;</code><br/>
</p>
<h3>Gear Joint</h3>
<p>If you want to create a sophisticated mechanical contraption you might want to use gears. In principle you can create gears in LiquidFun by using compound shapes to model gear teeth. This is not very efficient and might be tedious to author. You also have to be careful to line up the gears so the teeth mesh smoothly. LiquidFun has a simpler method of creating gears: the gear joint.</p>
<div class="image">
<img src="image_22.gif"  align="center" alt="Gear joint" height="188" width="179"/>
</div>
<p><br/>
</p>
<p>The gear joint can only connect revolute and/or prismatic joints.</p>
<p>Like the pulley ratio, you can specify a gear ratio. However, in this case the gear ratio can be negative. Also keep in mind that when one joint is a revolute joint (angular) and the other joint is prismatic (translation), and then the gear ratio will have units of length or one over length.</p>
<p>coordinate1 + ratio * coordinate2 == constant</p>
<p>Here is an example gear joint. The bodies myBodyA and myBodyB are any bodies from the two joints, as long as they are not the same bodies.</p>
<p>&#160;&#160;&#160;<code>b2GearJointDef jointDef;</code><br/>
 &#160;&#160;&#160;<code>jointDef.bodyA = myBodyA;</code><br/>
 &#160;&#160;&#160;<code>jointDef.bodyB = myBodyB;</code><br/>
 &#160;&#160;&#160;<code>jointDef.joint1 = myRevoluteJoint;</code><br/>
 &#160;&#160;&#160;<code>jointDef.joint2 = myPrismaticJoint;</code><br/>
 &#160;&#160;&#160;<code>jointDef.ratio = 2.0f * b2_pi / myLength;</code><br/>
</p>
<p>Note that the gear joint depends on two other joints. This creates a fragile situation. What happens if those joints are deleted? </p>
<pre class="fragment">Caution

Always delete gear joints before the revolute/prismatic joints on the gears. Otherwise your code will crash in a bad way due to the orphaned joint pointers in the gear joint. You should also delete the gear joint before you delete any of the bodies involved.
</pre><h3>Mouse Joint</h3>
<p>The mouse joint is used in the testbed to manipulate bodies with the mouse. It attempts to drive a point on a body towards the current position of the cursor. There is no restriction on rotation.</p>
<p>The mouse joint definition has a target point, maximum force, frequency, and damping ratio. The target point initially coincides with the body’s anchor point. The maximum force is used to prevent violent reactions when multiple dynamic bodies interact. You can make this as large as you like. The frequency and damping ratio are used to create a spring/damper effect similar to the distance joint.</p>
<p>Many users have tried to adapt the mouse joint for game play. Users often want to achieve precise positioning and instantaneous response. The mouse joint doesn’t work very well in that context. You may wish to consider using kinematic bodies instead.</p>
<h3>Wheel Joint</h3>
<p>The wheel joint restricts a point on bodyB to a line on bodyA. The wheel joint also provides a suspension spring. See b2WheelJoint.h and Car.h for details.</p>
<div class="image">
<img src="image_23.png"  align="center" alt="Wheel joint" height="286" width="157"/>
</div>
<p><br/>
</p>
<h3>Weld Joint</h3>
<p>The weld joint attempts to constrain all relative motion between two bodies. See the Cantilever.h in the testbed to see how the weld joint behaves.</p>
<p>It is tempting to use the weld joint to define breakable structures. However, the LiquidFun solver is iterative so the joints are a bit soft. So chains of bodies connected by weld joints will flex.</p>
<p>Instead it is better to create breakable bodies starting with a single body with multiple fixtures. When the body breaks, you can destroy a fixture and recreate it on a new body. See the Breakable example in the testbed.</p>
<h3>Rope Joint</h3>
<p>The rope joint restricts the maximum distance between two points. This can be useful to prevent chains of bodies from stretching, even under high load. See b2RopeJoint.h and RopeJoint.h for details.</p>
<h3>Friction Joint</h3>
<p>The friction joint is used for top-down friction. The joint provides 2D translational friction and angular friction. See b2FrictionJoint.h and ApplyForce.h for details.</p>
<p><em>This content is licensed under <a href="http://creativecommons.org/licenses/by/4.0/legalcode">Creative Commons Attribution 4.0</a>. For details and restrictions, please see the <a href="md__content_license.html">Content License</a>.</em> </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- Google Analytics -->
<script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-46159502-1', 'auto');
ga('create', 'UA-49880327-7', 'auto', {'name': 'liquidFunTracker'});
ga('send', 'pageview');
ga('liquidFunTracker.send', 'pageview');
</script>
</body>
</html>
