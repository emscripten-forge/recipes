<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>LiquidFun Programmer&#39;s Guide: Fixtures</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">LiquidFun Programmer&#39;s Guide
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('md__chapter07__fixtures.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">Fixtures </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a href="#about">About</a><br/>
 <a href="#fc">Fixture Creation</a><br/>
 <a href="#se">Sensors</a><br/>
</p>
<p><a class="anchor" id="about"></a> </p>
<h2>About</h2>
<p>Recall that shapes donâ€™t know about bodies and may be used independently of the physics simulation. Therefore LiquidFun provides the b2Fixture class to attach shapes to bodies. A body may have zero or more fixtures. A body with multiple fixtures is sometimes called a <em>compound body.</em></p>
<p>Fixtures hold the following:</p>
<ul>
<li>a single shape</li>
<li>broad-phase proxies</li>
<li>density, friction, and restitution</li>
<li>collision filtering flags</li>
<li>back pointer to the parent body</li>
<li>user data</li>
<li>sensor flag</li>
</ul>
<p>These are described in the following sections.</p>
<p><a class="anchor" id="fc"></a> </p>
<h2>Fixture Creation</h2>
<p>Fixtures are created by initializing a fixture definition and then passing the definition to the parent body.</p>
<p>&#160;&#160;&#160;<code>b2FixtureDef fixtureDef;</code><br/>
 &#160;&#160;&#160;<code>fixtureDef.shape = </code><br/>
 &#160;&#160;&#160;<code>fixtureDef.density = 1.0f;</code><br/>
 &#160;&#160;&#160;<code>b2Fixture* myFixture = myBody-&gt;CreateFixture(&amp;fixtureDef);</code><br/>
</p>
<p>This creates the fixture and attaches it to the body. You do not need to store the fixture pointer since the fixture will automatically be destroyed when the parent body is destroyed. You can create multiple fixtures on a single body.</p>
<p>You can destroy a fixture on the parent body. You may do this to model a breakable object. Otherwise you can just leave the fixture alone and let the body destruction take care of destroying the attached fixtures.</p>
<p>&#160;&#160;&#160;<code>myBody-&gt;DestroyFixture(myFixture);</code><br/>
</p>
<h3>Density</h3>
<p>The fixture density is used to compute the mass properties of the parent body. The density can be zero or positive. You should generally use similar densities for all your fixtures. This will improve stacking stability.</p>
<p>The mass of a body is not adjusted when you set the density. You must call ResetMassData for this to occur.</p>
<p>&#160;&#160;&#160;<code>fixture-&gt;SetDensity(5.0f);</code><br/>
 &#160;&#160;&#160;<code>body-&gt;ResetMassData();</code><br/>
</p>
<h3>Friction</h3>
<p>Friction is used to make objects slide along each other realistically. LiquidFun supports static and dynamic friction, but uses the same parameter for both. Friction is simulated accurately in LiquidFun and the friction strength is proportional to the normal force (this is called Coulomb friction). The friction parameter is usually set between 0 and 1, but can be any non-negative value. A friction value of 0 turns off friction and a value of 1 makes the friction strong. When the friction force is computed between two shapes, LiquidFun must combine the friction parameters of the two parent fixtures. This is done with the geometric mean:</p>
<p>&#160;&#160;&#160;<code>float32 friction;</code><br/>
 &#160;&#160;&#160;<code>friction = sqrtf(fixtureA-&gt;friction * fixtureB-&gt;friction);</code><br/>
</p>
<p>So if one fixture has zero friction then the contact will have zero friction.</p>
<p>You can override the default mixed friction using b2Contact::SetFriction. This is usually done in the b2ContactListener callback.</p>
<h3>Restitution</h3>
<p>Restitution is used to make objects bounce. The restitution value is usually set to be between 0 and 1. Consider dropping a ball on a table. A value of zero means the ball won't bounce. This is called an inelastic collision. A value of one means the ball's velocity will be exactly reflected. This is called a perfectly elastic collision. Restitution is combined using the following formula.</p>
<p>&#160;&#160;&#160;<code>float32 restitution;</code><br/>
 &#160;&#160;&#160;<code>restitution = b2Max(fixtureA-&gt;restitution, fixtureB-&gt;restitution);</code><br/>
</p>
<p>Restitution is combined this way so that you can have a bouncy super ball without having a bouncy floor.</p>
<p>You can override the default mixed restitution using b2Contact::SetRestitution. This is usually done in the b2ContactListener callback.</p>
<p>When a shape develops multiple contacts, restitution is simulated approximately. This is because LiquidFun uses an iterative solver. LiquidFun also uses inelastic collisions when the collision velocity is small. This is done to prevent jitter. See b2_velocityThreshold in b2Settings.h.</p>
<h3>Filtering</h3>
<p>Collision filtering allows you to prevent collision between fixtures. For example, say you make a character that rides a bicycle. You want the bicycle to collide with the terrain and the character to collide with the terrain, but you don't want the character to collide with the bicycle (because they must overlap). LiquidFun supports such collision filtering using categories and groups.</p>
<p>LiquidFun supports 16 collision categories. For each fixture you can specify which category it belongs to. You also specify what other categories this fixture can collide with. For example, you could specify in a multiplayer game that all players don't collide with each other and monsters don't collide with each other, but players and monsters should collide. This is done with masking bits. For example:</p>
<p>&#160;&#160;&#160;<code>playerFixtureDef.filter.categoryBits = 0x0002;</code><br/>
 &#160;&#160;&#160;<code>monsterFixtureDef.filter.categoryBits = 0x0004;</code><br/>
 &#160;&#160;&#160;<code>playerFixtureDef.filter.maskBits = 0x0004;</code><br/>
 &#160;&#160;&#160;<code>monsterFixtureDef.filter.maskBits = 0x0002;</code><br/>
</p>
<p>Here is the rule for a collision to occur:</p>
<p>&#160;&#160;&#160;<code>uint16 catA = fixtureA.filter.categoryBits;</code><br/>
 &#160;&#160;&#160;<code>uint16 maskA = fixtureA.filter.maskBits;</code><br/>
 &#160;&#160;&#160;<code>uint16 catB = fixtureB.filter.categoryBits;</code><br/>
 &#160;&#160;&#160;<code>uint16 maskB = fixtureB.filter.maskBits;</code><br/>
 &#160;&#160;&#160;<code>if ((catA &amp; maskB) != 0 &amp;&amp; (catB &amp; maskA) != 0)</code><br/>
 &#160;&#160;&#160;<code>{</code><br/>
 &#160;&#160;&#160;&#160;&#160;&#160; <code>// fixtures can collide</code><br/>
 &#160;&#160;&#160;<code>}</code><br/>
</p>
<p>Collision groups let you specify an integral group index. You can have all fixtures with the same group index always collide (positive index) or never collide (negative index). Group indices are usually used for things that are somehow related, like the parts of a bicycle. In the following example, fixture1 and fixture2 always collide, but fixture3 and fixture4 never collide.</p>
<p>&#160;&#160;&#160;<code>fixture1Def.filter.groupIndex = 2;</code><br/>
 &#160;&#160;&#160;<code>fixture2Def.filter.groupIndex = 2;</code><br/>
 &#160;&#160;&#160;<code>fixture3Def.filter.groupIndex = -8;</code><br/>
 &#160;&#160;&#160;<code>fixture4Def.filter.groupIndex = -8;</code><br/>
</p>
<p>Collisions between fixtures of different group indices are filtered according the category and mask bits. In other words, group filtering has higher precedence than category filtering.</p>
<p>Note that additional collision filtering occurs in LiquidFun. Here is a list:</p>
<ul>
<li>A fixture on a static body can only collide with a dynamic body.</li>
<li>A fixture on a kinematic body can only collide with a dynamic body.</li>
<li>Fixtures on the same body never collide with each other.</li>
<li>You can optionally enable/disable collision between fixtures on bodies connected by a joint.</li>
</ul>
<p>Sometimes you might need to change collision filtering after a fixture has already been created. You can get and set the b2Filter structure on an existing fixture using b2Fixture::GetFilterData and b2Fixture::SetFilterData. Note that changing the filter data will not add or remove contacts until the next time step (see the World class).</p>
<p><a class="anchor" id="se"></a> </p>
<h2>Sensors</h2>
<p>Sometimes game logic needs to know when two fixtures overlap yet there should be no collision response. This is done by using sensors. A sensor is a fixture that detects collision but does not produce a response.</p>
<p>You can flag any fixture as being a sensor. Sensors may be static, kinematic, or dynamic. Remember that you may have multiple fixtures per body and you can have any mix of sensors and solid fixtures. Also, sensors only form contacts when at least one body is dynamic, so you will not get a contact for kinematic versus kinematic, kinematic versus static, or static versus static.</p>
<p>Sensors do not generate contact points. There are two ways to get the state of a sensor:</p>
<ol type="1">
<li><code>b2Contact::IsTouching</code></li>
<li><code>b2ContactListener::BeginContact and EndContact</code></li>
</ol>
<p><em>This content is licensed under <a href="http://creativecommons.org/licenses/by/4.0/legalcode">Creative Commons Attribution 4.0</a>. For details and restrictions, please see the <a href="md__content_license.html">Content License</a>.</em> </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- Google Analytics -->
<script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-46159502-1', 'auto');
ga('create', 'UA-49880327-7', 'auto', {'name': 'liquidFunTracker'});
ga('send', 'pageview');
ga('liquidFunTracker.send', 'pageview');
</script>
</body>
</html>
