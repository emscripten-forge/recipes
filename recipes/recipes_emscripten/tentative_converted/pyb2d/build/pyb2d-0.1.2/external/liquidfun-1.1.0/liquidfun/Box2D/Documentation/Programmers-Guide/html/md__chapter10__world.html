<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>LiquidFun Programmer&#39;s Guide: World Class</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">LiquidFun Programmer&#39;s Guide
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('md__chapter10__world.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">World Class </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a href="#about">About</a><br/>
 <a href="#cdw">Creating and Destroying a World</a><br/>
 <a href="#uw">Using a World</a><br/>
 <a href="#sim">Simulation</a><br/>
 <a href="#ew">Exploring the World</a><br/>
 <a href="#ab">AABB Queries</a><br/>
 <a href="#rc">Ray Casts</a><br/>
 <a href="#fi">Forces and Impulses</a><br/>
 <a href="#ct">Coordinate Transformations</a><br/>
 <a href="#lists">Lists</a><br/>
 <a class="anchor" id="about"></a><br/>
 </p>
<h2>About</h2>
<p>The b2World class contains the bodies and joints. It manages all aspects of the simulation and allows for asynchronous queries (like AABB queries and ray-casts). Much of your interactions with LiquidFun will be with a b2World object.</p>
<p><a class="anchor" id="cdw"></a><br/>
 </p>
<h2>Creating and Destroying a World</h2>
<p>Creating a world is fairly simple. You just need to provide a gravity vector and a Boolean indicating if bodies can sleep. Usually you will create and destroy a world using new and delete.</p>
<p>&#160;&#160;&#160;<code>b2World* myWorld = new b2World(gravity, doSleep);</code><br/>
 &#160;&#160;&#160;<code>... do stuff ...</code><br/>
 &#160;&#160;&#160;<code>delete myWorld;</code><br/>
</p>
<p><a class="anchor" id="uw"></a><br/>
 </p>
<h2>Using a World</h2>
<p>The world class contains factories for creating and destroying bodies and joints. These factories are discussed later in the sections on bodies and joints. There are some other interactions with b2World that I will cover now.</p>
<p><a class="anchor" id="sim"></a><br/>
 </p>
<h2>Simulation</h2>
<p>The world class is used to drive the simulation. You specify a time step and a velocity and position iteration count. For example:</p>
<p>&#160;&#160;&#160;<code>float32 timeStep = 1.0f / 60.f;</code><br/>
 &#160;&#160;&#160;<code>int32 velocityIterations = 10;</code><br/>
 &#160;&#160;&#160;<code>int32 positionIterations = 8;</code><br/>
 &#160;&#160;&#160;<code>myWorld-&gt;Step(timeStep, velocityIterations, positionIterations);</code><br/>
</p>
<p>After the time step you can examine your bodies and joints for information. Most likely you will grab the position off the bodies so that you can update your actors and render them. You can perform the time step anywhere in your game loop, but you should be aware of the order of things. For example, you must create bodies before the time step if you want to get collision results for the new bodies in that frame.</p>
<p>As I discussed above in the HelloWorld tutorial, you should use a fixed time step. By using a larger time step you can improve performance in low frame rate scenarios. But generally you should use a time step no larger than 1/30 seconds. A time step of 1/60 seconds will usually deliver a high quality simulation.</p>
<p>The iteration count controls how many times the constraint solver sweeps over all the contacts and joints in the world. More iteration always yields a better simulation. But don't trade a small time step for a large iteration count. 60Hz and 10 iterations is far better than 30Hz and 20 iterations.</p>
<p>After stepping, you should clear any forces you have applied to your bodies. This is done with the command b2World::ClearForces. This lets you take multiple sub-steps with the same force field.</p>
<p>&#160;&#160;&#160;<code>myWorld-&gt;ClearForces();</code><br/>
</p>
<p><a class="anchor" id="ew"></a><br/>
 </p>
<h2>Exploring the World</h2>
<p>The world is a container for bodies, contacts, and joints. You can grab the body, contact, and joint lists off the world and iterate over them. For example, this code wakes up all the bodies in the world:</p>
<p>&#160;&#160;&#160;<code>for (b2Body* b = myWorld-&gt;GetBodyList(); b; b = b-&gt;GetNext())</code><br/>
 &#160;&#160;&#160;<code>{</code><br/>
 &#160;&#160;&#160;&#160;&#160;&#160;<code>b-&gt;SetAwake(true);</code><br/>
 &#160;&#160;&#160;<code>}</code><br/>
</p>
<p>Unfortunately real programs can be more complicated. For example, the following code is broken:</p>
<p>&#160;&#160;&#160;<code>for (b2Body* b = myWorld-&gt;GetBodyList(); b; b = b-&gt;GetNext())</code><br/>
 &#160;&#160;&#160;<code>{</code><br/>
 &#160;&#160;&#160;&#160;&#160;&#160;<code>GameActor* myActor = (GameActor*)b-&gt;GetUserData();</code><br/>
 &#160;&#160;&#160;&#160;&#160;&#160;<code>if (myActor-&gt;IsDead())</code><br/>
 &#160;&#160;&#160;&#160;&#160;&#160;<code>{</code><br/>
 &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<code>myWorld-&gt;DestroyBody(b); // ERROR: now GetNext returns garbage.</code><br/>
 &#160;&#160;&#160;&#160;&#160;&#160;<code>}</code><br/>
 &#160;&#160;&#160;<code>}</code><br/>
</p>
<p>Everything goes ok until a body is destroyed. Once a body is destroyed, its next pointer becomes invalid. So the call to b2Body::GetNext() will return garbage. The solution to this is to copy the next pointer before destroying the body.</p>
<p>&#160;&#160;&#160;<code>b2Body* node = myWorld-&gt;GetBodyList();</code><br/>
 &#160;&#160;&#160;<code>while (node)</code><br/>
 &#160;&#160;&#160;<code>{</code><br/>
 &#160;&#160;&#160;&#160;&#160;&#160;<code>b2Body* b = node;</code><br/>
 &#160;&#160;&#160;&#160;&#160;&#160;<code>node = node-&gt;GetNext();</code><br/>
 &#160;&#160;&#160;&#160;&#160;&#160;<code>GameActor* myActor = (GameActor*)b-&gt;GetUserData();</code><br/>
 &#160;&#160;&#160;&#160;&#160;&#160;<code>if (myActor-&gt;IsDead())</code><br/>
 &#160;&#160;&#160;&#160;&#160;&#160;<code>{</code><br/>
 &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<code>myWorld-&gt;DestroyBody(b);</code> <br/>
 &#160;&#160;&#160;&#160;&#160;&#160;<code>}</code><br/>
 &#160;&#160;&#160;<code>}</code><br/>
</p>
<p>This safely destroys the current body. However, you may want to call a game function that may destroy multiple bodies. In this case you need to be very careful. The solution is application specific, but for convenience I'll show one method of solving the problem.</p>
<p>&#160;&#160;&#160;<code>b2Body* node = myWorld-&gt;GetBodyList();</code><br/>
 &#160;&#160;&#160;<code>while (node)</code><br/>
 &#160;&#160;&#160;<code>{</code><br/>
 &#160;&#160;&#160;&#160;&#160;&#160;<code>b2Body* b = node;</code><br/>
 &#160;&#160;&#160;&#160;&#160;&#160;<code>node = node-&gt;GetNext();</code><br/>
 &#160;&#160;&#160;&#160;&#160;&#160;<code>GameActor* myActor = (GameActor*)b-&gt;GetUserData();</code><br/>
 &#160;&#160;&#160;&#160;&#160;&#160;<code>if (myActor-&gt;IsDead())</code><br/>
 &#160;&#160;&#160;&#160;&#160;&#160;<code>{</code><br/>
 &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<code>bool otherBodiesDestroyed = GameCrazyBodyDestroyer(b);</code><br/>
 &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<code>if (otherBodiesDestroyed)</code><br/>
 &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<code>{</code><br/>
 &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<code>node = myWorld-&gt;GetBodyList();</code><br/>
 &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<code>}</code><br/>
 &#160;&#160;&#160;&#160;&#160;&#160;<code>}</code><br/>
 &#160;&#160;&#160;<code>}</code><br/>
</p>
<p>Obviously to make this work, GameCrazyBodyDestroyer must be honest about what it has destroyed.</p>
<p><a class="anchor" id="ab"></a><br/>
 </p>
<h2>AABB Queries</h2>
<p>Sometimes you want to determine all the shapes in a region. The b2World class has a fast log(N) method for this using the broad-phase data structure. You provide an AABB in world coordinates and an implementation of b2QueryCallback. The world calls your class with each fixture whose AABB overlaps the query AABB. Return true to continue the query, otherwise return false. For example, the following code finds all the fixtures that potentially intersect a specified AABB and wakes up all of the associated bodies.</p>
<p>&#160;&#160;&#160;<code>class MyQueryCallback : public b2QueryCallback</code><br/>
 &#160;&#160;&#160;<code>{</code><br/>
 &#160;&#160;&#160;&#160;&#160;&#160;<code>public:</code><br/>
 &#160;&#160;&#160;&#160;&#160;&#160;<code>bool ReportFixture(b2Fixture* fixture)</code><br/>
 &#160;&#160;&#160;&#160;&#160;&#160;<code>{</code><br/>
 &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<code>b2Body* body = fixture-&gt;GetBody();</code><br/>
 &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<code>body-&gt;SetAwake(true);</code><br/>
 &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<code>// Return true to continue the query.</code><br/>
 &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<code>return true;</code><br/>
 &#160;&#160;&#160;&#160;&#160;&#160;<code>}</code><br/>
 &#160;&#160;&#160;<code>};</code><br/>
 &#160;&#160;&#160;<code>...</code><br/>
 &#160;&#160;&#160;<code>MyQueryCallback callback;</code><br/>
 &#160;&#160;&#160;<code>b2AABB aabb;</code><br/>
 &#160;&#160;&#160;<code>aabb.lowerBound.Set(-1.0f, -1.0f);</code><br/>
 &#160;&#160;&#160;<code>aabb.upperBound.Set(1.0f, 1.0f);</code><br/>
 &#160;&#160;&#160;<code>myWorld-&gt;Query(&amp;callback, aabb);</code><br/>
</p>
<p>You cannot make any assumptions about the order of the callbacks.</p>
<p><a class="anchor" id="rc"></a><br/>
 </p>
<h2>Ray Casts</h2>
<p>You can use ray casts to do line-of-sight checks, fire guns, etc. You perform a ray cast by implementing a callback class and providing the start and end points. The world class calls your class with each fixture hit by the ray. Your callback is provided with the fixture, the point of intersection, the unit normal vector, and the fractional distance along the ray. You cannot make any assumptions about the order of the callbacks.</p>
<p>You control the continuation of the ray cast by returning a fraction. Returning a fraction of zero indicates the ray cast should be terminated. A fraction of one indicates the ray cast should continue as if no hit occurred. If you return the fraction from the argument list, the ray will be clipped to the current intersection point. So you can ray cast any shape, ray cast all shapes, or ray cast the closest shape by returning the appropriate fraction.</p>
<p>You may also return of fraction of -1 to filter the fixture. Then the ray cast will proceed as if the fixture does not exist.</p>
<p>Here is an example:</p>
<p>&#160;&#160;&#160;<code>// This class captures the closest hit shape.</code><br/>
 &#160;&#160;&#160;<code>class MyRayCastCallback : public b2RayCastCallback</code><br/>
 &#160;&#160;&#160;<code>{</code><br/>
 &#160;&#160;&#160;&#160;&#160;&#160;<code>public:</code><br/>
 &#160;&#160;&#160;&#160;&#160;&#160;<code>MyRayCastCallback()</code><br/>
 &#160;&#160;&#160;&#160;&#160;&#160;<code>{</code><br/>
 &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<code>m_fixture = NULL;</code><br/>
 &#160;&#160;&#160;&#160;&#160;&#160;<code>}</code><br/>
 &#160;&#160;&#160;&#160;&#160;&#160;<code>float32 ReportFixture(b2Fixture* fixture, const b2Vec2&amp; point, const b2Vec2&amp; normal, float32 fraction)</code><br/>
 &#160;&#160;&#160;&#160;&#160;&#160;<code>{</code><br/>
 &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<code>m_fixture = fixture;</code><br/>
 &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<code>m_point = point;</code><br/>
 &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<code>m_normal = normal;</code><br/>
 &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<code>m_fraction = fraction;</code><br/>
 &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<code>return fraction;</code><br/>
 &#160;&#160;&#160;&#160;&#160;&#160;<code>}</code><br/>
 &#160;&#160;&#160;&#160;&#160;&#160;<code>b2Fixture* m_fixture;</code><br/>
 &#160;&#160;&#160;&#160;&#160;&#160;<code>b2Vec2 m_point;</code><br/>
 &#160;&#160;&#160;&#160;&#160;&#160;<code>b2Vec2 m_normal;</code><br/>
 &#160;&#160;&#160;&#160;&#160;&#160;<code>float32 m_fraction;</code><br/>
 &#160;&#160;&#160;<code>};</code><br/>
 &#160;&#160;&#160;<code>MyRayCastCallback callback;</code><br/>
 &#160;&#160;&#160;<code>b2Vec2 point1(-1.0f, 0.0f);</code><br/>
 &#160;&#160;&#160;<code>b2Vec2 point2(3.0f, 1.0f);</code><br/>
 &#160;&#160;&#160;<code>myWorld-&gt;RayCast(&amp;callback, point1, point2);</code><br/>
</p>
<p>Caution</p>
<p>Due to round-off errors, ray casts can sneak through small cracks between polygons in your static environment. If this is not acceptable in your application, please enlarge your polygons slightly.</p>
<p>&#160;&#160;&#160;<code>void SetLinearVelocity(const b2Vec2&amp; v);</code><br/>
 &#160;&#160;&#160;<code>b2Vec2 GetLinearVelocity() const;</code><br/>
 &#160;&#160;&#160;<code>void SetAngularVelocity(float32 omega);</code><br/>
 &#160;&#160;&#160;<code>float32 GetAngularVelocity() const;</code><br/>
</p>
<p><a class="anchor" id="fi"></a><br/>
 </p>
<h2>Forces and Impulses</h2>
<p>You can apply forces, torques, and impulses to a body. When you apply a force or an impulse, you provide a world point where the load is applied. This often results in a torque about the center of mass.</p>
<p>void ApplyForce(const b2Vec2&amp; force, const b2Vec2&amp; point); void ApplyTorque(float32 torque); void ApplyLinearImpulse(const b2Vec2&amp; impulse, const b2Vec2&amp; point); void ApplyAngularImpulse(float32 impulse);</p>
<p>Applying a force, torque, or impulse wakes the body. Sometimes this is undesirable. For example, you may be applying a steady force and want to allow the body to sleep to improve performance. In this case you can use the following code.</p>
<p>&#160;&#160;&#160;<code>if (myBody-&gt;IsAwake() == true)</code><br/>
 &#160;&#160;&#160;<code>{</code><br/>
 &#160;&#160;&#160;&#160;&#160;&#160;<code>myBody-&gt;ApplyForce(myForce, myPoint);</code><br/>
 &#160;&#160;&#160;<code>}</code><br/>
</p>
<p>You can apply forces and impulses to particles and particle groups, as well. Unlike with bodies, however, the load is not applied to an arbitrary world point. Instead, it acts upon the center of each particle.</p>
<p>You can apply forces and impulses to individual particles or to particle groups. The following example spreads an impulse of (0.7, 0.3) kg m/s across the particles in myParticleGroup:</p>
<p>&#160;&#160;&#160;<code>const b2Vec2 impulse(0.7f, 0.3f);</code> &#160;&#160;&#160;<code>myParticleGroup-&gt;ApplyLinearImpulse(impulse);</code></p>
<p><a class="anchor" id="ct"></a><br/>
 </p>
<h2>Coordinate Transformations</h2>
<p>The body class has some utility functions to help you transform points and vectors between local and world space. If you don't understand these concepts, please read "Essential Mathematics for Games and Interactive Applications" by Jim Van Verth and Lars Bishop. These functions are efficient (when inlined).</p>
<p>&#160;&#160;&#160;<code>b2Vec2 GetWorldPoint(const b2Vec2&amp; localPoint);</code><br/>
</p>
<p>&#160;&#160;&#160;<code>b2Vec2 GetWorldVector(const b2Vec2&amp; localVector);</code><br/>
</p>
<p>&#160;&#160;&#160;<code>b2Vec2 GetLocalPoint(const b2Vec2&amp; worldPoint);</code><br/>
</p>
<p>&#160;&#160;&#160;<code>b2Vec2 GetLocalVector(const b2Vec2&amp; worldVector);</code><br/>
</p>
<p><a class="anchor" id="lists"></a><br/>
 </p>
<h2>Lists</h2>
<p>You can iterate over a body's fixtures. This is mainly useful if you need to access the fixture's user data.</p>
<p>&#160;&#160;&#160;<code>for (b2Fixture* f = body-&gt;GetFixtureList(); f; f = f-&gt;GetNext())</code><br/>
 &#160;&#160;&#160;<code>{</code><br/>
 &#160;&#160;&#160;&#160;&#160;&#160;<code>MyFixtureData* data = (MyFixtureData*)f-&gt;GetUserData();</code><br/>
 &#160;&#160;&#160;&#160;&#160;&#160;<code>… do something with data …</code><br/>
 &#160;&#160;&#160;<code>}</code><br/>
</p>
<p>You can similarly iterate over the body's joint list.</p>
<p>The body also provides a list of associated contacts. You can use this to get information about the current contacts. Be careful, because the contact list may not contain all the contacts that existed during the previous time step.</p>
<p><em>This content is licensed under <a href="http://creativecommons.org/licenses/by/4.0/legalcode">Creative Commons Attribution 4.0</a>. For details and restrictions, please see the <a href="md__content_license.html">Content License</a>.</em> </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- Google Analytics -->
<script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-46159502-1', 'auto');
ga('create', 'UA-49880327-7', 'auto', {'name': 'liquidFunTracker'});
ga('send', 'pageview');
ga('liquidFunTracker.send', 'pageview');
</script>
</body>
</html>
