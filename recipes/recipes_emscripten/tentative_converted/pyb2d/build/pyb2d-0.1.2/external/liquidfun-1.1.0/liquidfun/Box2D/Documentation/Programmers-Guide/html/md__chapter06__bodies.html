<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>LiquidFun Programmer&#39;s Guide: Bodies</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">LiquidFun Programmer&#39;s Guide
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('md__chapter06__bodies.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">Bodies </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a href="#about">About</a><br/>
 <a href="#bd">Body Definition</a><br/>
 <a href="#bf">Body Factory</a><br/>
 <a href="#ub">Using a Body</a><br/>
</p>
<p><a class="anchor" id="about"></a> </p>
<h2>About</h2>
<p>Bodies have position and velocity. You can apply forces, torques, and impulses to bodies. Bodies can be static, kinematic, or dynamic. Here are the body type definitions:</p>
<h3>b2_staticBody</h3>
<p>A static body does not move under simulation and behaves as if it has infinite mass. Internally, LiquidFun stores zero for the mass and the inverse mass. Static bodies can be moved manually by the user. A static body has zero velocity. Static bodies do not collide with other static or kinematic bodies.</p>
<h3>b2_kinematicBody</h3>
<p>A kinematic body moves under simulation according to its velocity. Kinematic bodies do not respond to forces. They can be moved manually by the user, but normally a kinematic body is moved by setting its velocity. A kinematic body behaves as if it has infinite mass, however, LiquidFun stores zero for the mass and the inverse mass. Kinematic bodies do not collide with other kinematic or static bodies.</p>
<h3>b2_dynamicBody</h3>
<p>A dynamic body is fully simulated. They can be moved manually by the user, but normally they move according to forces. A dynamic body can collide with all body types. A dynamic body always has finite, non-zero mass. If you try to set the mass of a dynamic body to zero, it will automatically acquire a mass of one kilogram and it won’t rotate.</p>
<p>Bodies are the backbone for fixtures (shapes). Bodies carry fixtures and move them around in the world. Bodies are always rigid bodies in LiquidFun. That means that two fixtures attached to the same rigid body never move relative to each other and fixtures attached to the same body don’t collide.</p>
<p>Fixtures have collision geometry and density. Normally, bodies acquire their mass properties from the fixtures. However, you can override the mass properties after a body is constructed.</p>
<p>You usually keep pointers to all the bodies you create. This way you can query the body positions to update the positions of your graphical entities. You should also keep body pointers so you can destroy them when you are done with them.</p>
<p><a class="anchor" id="bd"></a> </p>
<h2>Body Definition</h2>
<p>Before a body is created you must create a body definition (b2BodyDef). The body definition holds the data needed to create and initialize a body.</p>
<p>LiquidFun copies the data out of the body definition; it does not keep a pointer to the body definition. This means you can recycle a body definition to create multiple bodies.</p>
<p>Let’s go over some of the key members of the body definition.</p>
<h3>Body Type</h3>
<p>As discussed at the beginning of this chapter, there are three different body types: static, kinematic, and dynamic. You should establish the body type at creation because changing the body type later is expensive.</p>
<p>&#160;&#160;&#160;<code>bodyDef.type = b2_dynamicBody;</code><br/>
</p>
<p>Setting the body type is mandatory.</p>
<h3>Position and Angle</h3>
<p>The body definition gives you the chance to initialize the position of the body on creation. This has far better performance than creating the body at the world origin and then moving the body.</p>
<p>Caution</p>
<p>Do not create a body at the origin and then move it. If you create several bodies at the origin, then performance will suffer.</p>
<p>A body has two main points of interest. The first point is the body's origin. Fixtures and joints are attached relative to the body's origin. The second point of interest is the center of mass. The center of mass is determined from mass distribution of the attached shapes or is explicitly set with b2MassData. Much of LiquidFun's internal computations use the center of mass position. For example b2Body stores the linear velocity for the center of mass.</p>
<p>When you are building the body definition, you may not know where the center of mass is located. Therefore you specify the position of the body's origin. You may also specify the body's angle in radians, which is not affected by the position of the center of mass. If you later change the mass properties of the body, then the center of mass may move on the body, but the origin position does not change and the attached shapes and joints do not move.</p>
<p>&#160;&#160;&#160;<code>bodyDef.position.Set(0.0f, 2.0f); // the body's origin position.</code><br/>
 &#160;&#160;&#160;<code>bodyDef.angle = 0.25f * b2_pi; // the body's angle in radians.</code><br/>
</p>
<p>A rigid body is also a frame of reference. You can define fixtures and joints in that frame. Those fixtures and joint anchors never move in the local frame of the body.</p>
<h3>Damping</h3>
<p>Damping is used to reduce the world velocity of bodies. Damping is different than friction because friction only occurs with contact. Damping is not a replacement for friction and the two effects should be used together.</p>
<p>Damping parameters should be between 0 and infinity, with 0 meaning no damping, and infinity meaning full damping. Normally you will use a damping value between 0 and 0.1. I generally do not use linear damping because it makes bodies look floaty.</p>
<p>&#160;&#160;&#160;<code>bodyDef.linearDamping = 0.0f;</code><br/>
 &#160;&#160;&#160;<code>bodyDef.angularDamping = 0.01f;</code><br/>
</p>
<p>Damping is approximated for stability and performance. At small damping values the damping effect is mostly independent of the time step. At larger damping values, the damping effect will vary with the time step. This is not an issue if you use a fixed time step (recommended).</p>
<h3>Gravity Scale</h3>
<p>You can use the gravity scale to adjust the gravity on a single body. Be careful though, increased gravity can decrease stability.</p>
<p>&#160;&#160;&#160;<code>// Set the gravity scale to zero so this body will float</code><br/>
 &#160;&#160;&#160;<code>bodyDef.gravityScale = 0.0f;</code><br/>
</p>
<h3>Sleep Parameters</h3>
<p>What does sleep mean? Well it is expensive to simulate bodies, so the less we have to simulate the better. When a body comes to rest we would like to stop simulating it.</p>
<p>When LiquidFun determines that a body (or group of bodies) has come to rest, the body enters a sleep state which has very little CPU overhead. If a body is awake and collides with a sleeping body, then the sleeping body wakes up. Bodies will also wake up if a joint or contact attached to them is destroyed. You can also wake a body manually.</p>
<p>The body definition lets you specify whether a body can sleep and whether a body is created sleeping.</p>
<p>&#160;&#160;&#160;<code>bodyDef.allowSleep = true;</code><br/>
 &#160;&#160;&#160;<code>bodyDef.awake = true;</code><br/>
</p>
<h3>Fixed Rotation</h3>
<p>You may want a rigid body, such as a character, to have a fixed rotation. Such a body should not rotate, even under load. You can use the fixed rotation setting to achieve this:</p>
<p>&#160;&#160;&#160;<code>bodyDef.fixedRotation = true;</code><br/>
</p>
<p>The fixed rotation flag causes the rotational inertia and its inverse to be set to zero.</p>
<h3>Bullets</h3>
<p>Game simulation usually generates a sequence of images that are played at some frame rate. This is called discrete simulation. In discrete simulation, rigid bodies can move by a large amount in one time step. If a physics engine doesn't account for the large motion, you may see some objects incorrectly pass through each other. This effect is called tunneling.</p>
<p>By default, LiquidFun uses continuous collision detection (CCD) to prevent dynamic bodies from tunneling through static bodies. This is done by sweeping shapes from their old position to their new positions. The engine looks for new collisions during the sweep and computes the time of impact (TOI) for these collisions. Bodies are moved to their first TOI and then halted for the remainder of the time step.</p>
<p>Normally CCD is not used between dynamic bodies. This is done to keep performance reasonable. In some game scenarios you need dynamic bodies to use CCD. For example, you may want to shoot a high speed bullet at a stack of dynamic bricks. Without CCD, the bullet might tunnel through the bricks.</p>
<p>Fast moving objects in LiquidFun can be labeled as bullets. Bullets will perform CCD with both static and dynamic bodies. You should decide what bodies should be bullets based on your game design. If you decide a body should be treated as a bullet, use the following setting.</p>
<p>&#160;&#160;&#160;<code>bodyDef.bullet = true;</code><br/>
</p>
<p>The bullet flag only affects dynamic bodies.</p>
<p>LiquidFun performs continuous collision sequentially, so bullets may miss fast moving bodies.</p>
<h3>Activation</h3>
<p>You may wish a body to be created but not participate in collision or dynamics. This state is similar to sleeping except the body will not be woken by other bodies and the body's fixtures will not be placed in the broad-phase. This means the body will not participate in collisions, ray casts, etc.</p>
<p>You can create a body in an inactive state and later re-activate it.</p>
<p>&#160;&#160;&#160;<code>bodyDef.active = true;</code><br/>
</p>
<p>Joints may be connected to inactive bodies. These joints will not be simulated. You should be careful when you activate a body that its joints are not distorted.</p>
<h3>User Data</h3>
<p>User data is a void pointer. This gives you a hook to link your application objects to bodies. You should be consistent to use the same object type for all body user data.</p>
<p>&#160;&#160;&#160;<code>b2BodyDef bodyDef;</code><br/>
 &#160;&#160;&#160;<code>bodyDef.userData = </code><br/>
</p>
<p><a class="anchor" id="bf"></a> </p>
<h2>Body Factory</h2>
<p>Bodies are created and destroyed using a body factory provided by the world class. This lets the world create the body with an efficient allocator and add the body to the world data structure.</p>
<p>Bodies can be dynamic or static depending on the mass properties. Both body types use the same creation and destruction methods.</p>
<p>&#160;&#160;&#160;<code>b2Body* dynamicBody = myWorld-&gt;CreateBody(&amp;bodyDef);</code><br/>
 &#160;&#160;&#160;<code>... do stuff …</code><br/>
 &#160;&#160;&#160;<code>myWorld-&gt;DestroyBody(dynamicBody);</code><br/>
 &#160;&#160;&#160;<code>dynamicBody = NULL;</code><br/>
</p>
<p>Caution</p>
<p>You should never use new or malloc to create a body. The world won't know about the body and the body won't be properly initialized.</p>
<p>Static bodies do not move under the influence of other bodies. You may manually move static bodies, but you should be careful so that you don't squash dynamic bodies between two or more static bodies. Friction will not work correctly if you move a static body. Static bodies never collide with static or kinematic bodies. It is faster to attach several shapes to a static body than to create several static bodies with a single shape on each one. Internally, LiquidFun sets the mass and inverse mass of static bodies to zero. This makes the math work out so that most algorithms don't need to treat static bodies as a special case.</p>
<p>LiquidFun does not keep a reference to the body definition or any of the data it holds (except user data pointers). So you can create temporary body definitions and reuse the same body definitions.</p>
<p>LiquidFun allows you to avoid destroying bodies by deleting your b2World object, which does all the cleanup work for you. However, you should be mindful to nullify body pointers that you keep in your game engine.</p>
<p>When you destroy a body, the attached fixtures and joints are automatically destroyed. This has important implications for how you manage shape and joint pointers.</p>
<p><a class="anchor" id="ub"></a> </p>
<h2>Using a Body</h2>
<p>After creating a body, there are many operations you can perform on the body. These include setting mass properties, accessing position and velocity, applying forces, and transforming points and vectors.</p>
<h3>Mass Data</h3>
<p>Every body has a mass (scalar), center of mass (2-vector), and rotational inertia (scalar). For static bodies, the mass and rotational inertia are set to zero. When a body has fixed rotation, its rotational inertia is zero.</p>
<p>Normally the mass properties of a body are established automatically when fixtures are added to the body. You can also adjust the mass of a body at run-time. This is usually done when you have special game scenarios that require altering the mass.</p>
<p>&#160;&#160;&#160;<code>void SetMassData(const b2MassData* data);</code><br/>
</p>
<p>After setting a body's mass directly, you may wish to revert to the natural mass dictated by the fixtures. You can do this with:</p>
<p>&#160;&#160;&#160;<code>void ResetMassData();</code><br/>
</p>
<p>The body's mass data is available through the following functions:</p>
<p>&#160;&#160;&#160;<code>float32 GetMass() const;</code></p>
<p>&#160;&#160;&#160;<code>float32 GetInertia() const;</code></p>
<p>&#160;&#160;&#160;<code>const b2Vec2&amp; GetLocalCenter() const;</code></p>
<p>&#160;&#160;&#160;<code>void GetMassData(b2MassData* data) const;</code></p>
<h3>State Information</h3>
<p>There are many aspects to the body's state. You can access this state data efficiently through the following functions:</p>
<p>&#160;&#160;&#160;<code>void SetType(b2BodyType type);</code></p>
<p>&#160;&#160;&#160;<code>b2BodyType GetType();</code></p>
<p>&#160;&#160;&#160;<code>void SetBullet(bool flag);</code></p>
<p>&#160;&#160;&#160;<code>bool IsBullet() const;</code></p>
<p>&#160;&#160;&#160;<code>void SetSleepingAllowed(bool flag);</code></p>
<p>&#160;&#160;&#160;<code>bool IsSleepingAllowed() const;</code></p>
<p>&#160;&#160;&#160;<code>void SetAwake(bool flag);</code></p>
<p>&#160;&#160;&#160;<code>bool IsAwake() const;</code></p>
<p>&#160;&#160;&#160;<code>void SetActive(bool flag);</code></p>
<p>&#160;&#160;&#160;<code>bool IsActive() const;</code></p>
<p>&#160;&#160;&#160;<code>void SetFixedRotation(bool flag);</code></p>
<p>&#160;&#160;&#160;<code>bool IsFixedRotation() const;</code></p>
<h3>Position and Velocity</h3>
<p>You can access the position and rotation of a body. This is common when rendering your associated game actor. You can also set the position, although this is less common since you will normally use LiquidFun to simulate movement.</p>
<p>&#160;&#160;&#160;<code>bool SetTransform(const b2Vec2&amp; position, float32 angle);</code><br/>
 &#160;&#160;&#160;<code>const b2Transform&amp; GetTransform() const;</code><br/>
 &#160;&#160;&#160;<code>const b2Vec2&amp; GetPosition() const;</code><br/>
 &#160;&#160;&#160;<code>float32 GetAngle() const;</code><br/>
</p>
<p>You can access the center of mass position in local and world coordinates. Much of the internal simulation in LiquidFun uses the center of mass. However, you should normally not need to access it. Instead you will usually work with the body transform. For example, you may have a body that is square. The body origin might be a corner of the square, while the center of mass is located at the center of the square.</p>
<p>&#160;&#160;&#160;<code>const b2Vec2&amp; GetWorldCenter() const;</code><br/>
 &#160;&#160;&#160;<code>const b2Vec2&amp; GetLocalCenter() const;</code><br/>
</p>
<p>You can access the linear and angular velocity. The linear velocity is for the center of mass. Therefore, the linear velocity may change if the mass properties change.</p>
<p><em>This content is licensed under <a href="http://creativecommons.org/licenses/by/4.0/legalcode">Creative Commons Attribution 4.0</a>. For details and restrictions, please see the <a href="md__content_license.html">Content License</a>.</em> </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- Google Analytics -->
<script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-46159502-1', 'auto');
ga('create', 'UA-49880327-7', 'auto', {'name': 'liquidFunTracker'});
ga('send', 'pageview');
ga('liquidFunTracker.send', 'pageview');
</script>
</body>
</html>
