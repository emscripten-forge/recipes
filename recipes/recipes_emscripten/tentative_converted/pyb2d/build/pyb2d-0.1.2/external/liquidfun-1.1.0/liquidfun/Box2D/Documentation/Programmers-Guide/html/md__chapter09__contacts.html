<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>LiquidFun Programmer&#39;s Guide: Contacts</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">LiquidFun Programmer&#39;s Guide
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('md__chapter09__contacts.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">Contacts </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a href="#about">About</a><br/>
 <a href="#cc">Contact Class</a><br/>
 <a href="#ac">Accessing Contacts</a><br/>
 <a href="#cl">Contact Listener</a><br/>
 <a href="#cf">Contact Filtering</a><br/>
</p>
<p><a class="anchor" id="about"></a> </p>
<h2>About</h2>
<p>Contacts are objects created by LiquidFun to manage collision between two fixtures. If the fixture has children, such as a chain shape, then a contact exists for each relevant child. There are different kinds of contacts, derived from b2Contact, for managing contact between different kinds of fixtures. For example there is a contact class for managing polygon-polygon collision and another contact class for managing circle-circle collision.</p>
<p>Here is some terminology associated with contacts.</p>
<h3>contact point</h3>
<p>A contact point is a point where two shapes touch. LiquidFun approximates contact with a small number of points.</p>
<h3>contact normal</h3>
<p>A contact normal is a unit vector that points from one shape to another. By convention, the normal points from fixtureA to fixtureB.</p>
<h3>contact separation</h3>
<p>Separation is the opposite of penetration. Separation is negative when shapes overlap. It is possible that future versions of LiquidFun will create contact points with positive separation, so you may want to check the sign when contact points are reported.</p>
<h3>contact manifold</h3>
<p>Contact between two convex polygons may generate up to 2 contact points. Both of these points use the same normal, so they are grouped into a contact manifold, which is an approximation of a continuous region of contact.</p>
<h3>normal impulse</h3>
<p>The normal force is the force applied at a contact point to prevent the shapes from penetrating. For convenience, LiquidFun works with impulses. The normal impulse is just the normal force multiplied by the time step.</p>
<h3>tangent impulse</h3>
<p>The tangent force is generated at a contact point to simulate friction. For convenience, this is stored as an impulse.</p>
<h3>contact ids</h3>
<p>LiquidFun tries to re-use the contact force results from a time step as the initial guess for the next time step. LiquidFun uses contact ids to match contact points across time steps. The ids contain geometric features indices that help to distinguish one contact point from another.</p>
<p>Contacts are created when two fixtureâ€™s AABBs overlap. Sometimes collision filtering will prevent the creation of contacts. Contacts are destroyed with the AABBs cease to overlap.</p>
<p>So you might gather that there may be contacts created for fixtures that are not touching (just their AABBs). Well, this is correct. It's a "chicken or egg" problem. We don't know if we need a contact object until one is created to analyze the collision. We could delete the contact right away if the shapes are not touching, or we can just wait until the AABBs stop overlapping. LiquidFun takes the latter approach because it lets the system cache information to improve performance.</p>
<p><a class="anchor" id="cc"></a> </p>
<h2>Contact Class</h2>
<p>As mentioned before, the contact class is created and destroyed by LiquidFun. Contact objects are not created by the user. However, you are able to access the contact class and interact with it.</p>
<p>You can access the raw contact manifold:</p>
<p>&#160;&#160;&#160;<code>b2Manifold* GetManifold();</code><br/>
 &#160;&#160;&#160;<code>const b2Manifold* GetManifold() const;</code><br/>
</p>
<p>You can potentially modify the manifold, but this is generally not supported and is for advanced usage.</p>
<p>There is a helper function to get the b2WorldManifold:</p>
<p>&#160;&#160;&#160;<code>void GetWorldManifold(b2WorldManifold* worldManifold) const;</code><br/>
</p>
<p>This uses the current positions of the bodies to compute world positions of the contact points.</p>
<p>Sensors do not create manifolds, so for them use:</p>
<p>&#160;&#160;&#160;<code>bool touching = sensorContact-&gt;IsTouching();</code><br/>
</p>
<p>This function also works for non-sensors.</p>
<p>You can get the fixtures from a contact. From those you can get the bodies.</p>
<p>&#160;&#160;&#160;<code>b2Fixture* fixtureA = myContact-&gt;GetFixtureA();</code><br/>
 &#160;&#160;&#160;<code>b2Body* bodyA = fixtureA-&gt;GetBody();</code><br/>
 &#160;&#160;&#160;<code>MyActor* actorA = (MyActor*)bodyA-&gt;GetUserData();</code><br/>
</p>
<p>You can disable a contact. This only works inside the b2ContactListener::PreSolve event, discussed below.</p>
<p><a class="anchor" id="ac"></a> </p>
<h2>Accessing Contacts</h2>
<p>You can get access to contacts in several ways. You can access the contacts directly on the world and body structures. You can also implement a contact listener.</p>
<p>You can iterate over all contacts in the world:</p>
<p>&#160;&#160;&#160;<code>for (b2Contact* c = myWorld-&gt;GetContactList(); c; c = c-&gt;GetNext())</code><br/>
 &#160;&#160;&#160;<code>{</code><br/>
 &#160;&#160;&#160;&#160;&#160;&#160;<code>// process c</code><br/>
 &#160;&#160;&#160;<code>}</code><br/>
</p>
<p>You can also iterate over all the contacts on a body. These are stored in a graph using a contact edge structure.</p>
<p>&#160;&#160;&#160;<code>for (b2ContactEdge* ce = myBody-&gt;GetContactList(); ce; ce = ce-&gt;next)</code><br/>
 &#160;&#160;&#160;<code>{</code><br/>
 &#160;&#160;&#160;&#160;&#160;&#160;<code>b2Contact* c = ce-&gt;contact;</code><br/>
 &#160;&#160;&#160;&#160;&#160;&#160;<code>// process c</code><br/>
 &#160;&#160;&#160;<code>}</code><br/>
</p>
<p>You can also access contacts using the contact listener that is described below.</p>
<p>Caution</p>
<p>Accessing contacts off b2World and b2Body may miss some transient contacts that occur in the middle of the time step. Use b2ContactListener to get the most accurate results.</p>
<p><a class="anchor" id="cl"></a> </p>
<h2>Contact Listener</h2>
<p>You can receive contact data by implementing b2ContactListener. The contact listener supports several events: begin, end, pre-solve, and post-solve.</p>
<p>&#160;&#160;&#160;<code>class MyContactListener : public b2ContactListener</code><br/>
 &#160;&#160;&#160;<code>{</code><br/>
 &#160;&#160;&#160;&#160;&#160;&#160;<code>public:</code><br/>
 &#160;&#160;&#160;&#160;&#160;&#160;<code>void BeginContact(b2Contact* contact)</code><br/>
 &#160;&#160;&#160;&#160;&#160;&#160;<code>{ /* handle begin event }</code><br/>
 &#160;&#160;&#160;&#160;&#160;&#160;<code>void EndContact(b2Contact* contact)</code><br/>
 &#160;&#160;&#160;&#160;&#160;&#160;<code>{ /* handle end event }</code><br/>
 &#160;&#160;&#160;&#160;&#160;&#160;<code>void PreSolve(b2Contact* contact, const b2Manifold* oldManifold)</code><br/>
 &#160;&#160;&#160;&#160;&#160;&#160;<code>{ /* handle pre-solve event }</code><br/>
 &#160;&#160;&#160;&#160;&#160;&#160;<code>void PostSolve(b2Contact* contact, const b2ContactImpulse* impulse)</code><br/>
 &#160;&#160;&#160;&#160;&#160;&#160;<code>{ /* handle post-solve event }</code><br/>
 &#160;&#160;&#160;<code>};</code><br/>
</p>
<p>Caution</p>
<p>Do not keep a reference to the pointers sent to b2ContactListener. Instead make a deep copy of the contact point data into your own buffer. The example below shows one way of doing this.</p>
<p>At run-time you can create an instance of the listener and register it with b2World::SetContactListener. Be sure your listener remains in scope while the world object exists.</p>
<h3>Begin Contact Event</h3>
<p>This is called when two fixtures begin to overlap. This is called for sensors and non-sensors. This event can only occur inside the time step.</p>
<h3>End Contact Event</h3>
<p>This is called when two fixtures cease to overlap. This is called for sensors and non-sensors. This may be called when a body is destroyed, so this event can occur outside the time step.</p>
<h3>Pre-Solve Event</h3>
<p>This is called after collision detection, but before collision resolution. This gives you a chance to disable the contact based on the current configuration. For example, you can implement a one-sided platform using this callback and calling b2Contact::SetEnabled(false). The contact will be re-enabled each time through collision processing, so you will need to disable the contact every time-step. The pre-solve event may be fired multiple times per time step per contact due to continuous collision detection.</p>
<p>&#160;&#160;&#160;<code>void PreSolve(b2Contact* contact, const b2Manifold* oldManifold)</code><br/>
 &#160;&#160;&#160;<code>{</code><br/>
 &#160;&#160;&#160;<code>b2WorldManifold worldManifold;</code><br/>
 &#160;&#160;&#160;<code>contact-&gt;GetWorldManifold(&amp;worldManifold);</code><br/>
 &#160;&#160;&#160;<code>if (worldManifold.normal.y &lt; -0.5f)</code><br/>
 &#160;&#160;&#160;&#160;&#160;&#160;<code>{</code><br/>
 &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<code>contact-&gt;SetEnabled(false);</code><br/>
 &#160;&#160;&#160;&#160;&#160;&#160;<code>}</code><br/>
 &#160;&#160;&#160;<code>}</code><br/>
</p>
<p>The pre-solve event is also a good place to determine the point state and the approach velocity of collisions.</p>
<p>&#160;&#160;&#160;<code>void PreSolve(b2Contact* contact, const b2Manifold* oldManifold)</code><br/>
 &#160;&#160;&#160;<code>{</code><br/>
 &#160;&#160;&#160;&#160;&#160;&#160;<code>b2WorldManifold worldManifold;</code><br/>
 &#160;&#160;&#160;&#160;&#160;&#160;<code>contact-&gt;GetWorldManifold(&amp;worldManifold);</code><br/>
 &#160;&#160;&#160;&#160;&#160;&#160;<code>b2PointState state1[2], state2[2];</code><br/>
 &#160;&#160;&#160;&#160;&#160;&#160;<code>b2GetPointStates(state1, state2, oldManifold, contact-&gt;GetManifold());</code><br/>
 &#160;&#160;&#160;&#160;&#160;&#160;<code>if (state2[0] == b2_addState)</code><br/>
 &#160;&#160;&#160;&#160;&#160;&#160;<code>{</code><br/>
 &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<code>const b2Body* bodyA = contact-&gt;GetFixtureA()-&gt;GetBody();</code><br/>
 &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<code>const b2Body* bodyB = contact-&gt;GetFixtureB()-&gt;GetBody();</code><br/>
 &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<code>b2Vec2 point = worldManifold.points[0];</code><br/>
 &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<code>b2Vec2 vA = bodyA-&gt;GetLinearVelocityFromWorldPoint(point);</code><br/>
 &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<code>b2Vec2 vB = bodyB-&gt;GetLinearVelocityFromWorldPoint(point);</code><br/>
 &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<code>float32 approachVelocity = b2Dot(vB â€“ vA, worldManifold.normal);</code><br/>
 &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<code>if (approachVelocity &gt; 1.0f)</code><br/>
 &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<code>{</code><br/>
 &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<code>MyPlayCollisionSound();</code><br/>
 &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<code>}</code><br/>
 &#160;&#160;&#160;&#160;&#160;&#160;<code>}</code><br/>
 &#160;&#160;&#160;<code>}</code><br/>
</p>
<h3>Post-Solve Event</h3>
<p>The post solve event is where you can gather collision impulse results. If you donâ€™t care about the impulses, you should probably just implement the pre-solve event.</p>
<p>It is tempting to implement game logic that alters the physics world inside a contact callback. For example, you may have a collision that applies damage and try to destroy the associated actor and its rigid body. However, LiquidFun does not allow you to alter the physics world inside a callback because you might destroy objects that LiquidFun is currently processing, leading to orphaned pointers.</p>
<p>The recommended practice for processing contact points is to buffer all contact data that you care about and process it after the time step. You should always process the contact points immediately after the time step; otherwise some other client code might alter the physics world, invalidating the contact buffer. When you process the contact buffer you can alter the physics world, but you still need to be careful that you don't orphan pointers stored in the contact point buffer. The testbed has example contact point processing that is safe from orphaned pointers.</p>
<p>This code from the CollisionProcessing test shows how to handle orphaned bodies when processing the contact buffer. Here is an excerpt. Be sure to read the comments in the listing. This code assumes that all contact points have been buffered in the b2ContactPoint array m_points.</p>
<p>&#160;&#160;&#160;<code>// We are going to destroy some bodies according to contact</code><br/>
 &#160;&#160;&#160;<code>// points. We must buffer the bodies that should be destroyed</code><br/>
 &#160;&#160;&#160;<code>// because they may belong to multiple contact points.</code><br/>
 &#160;&#160;&#160;<code>const int32 k_maxNuke = 6;</code><br/>
 &#160;&#160;&#160;<code>b2Body* nuke[k_maxNuke];</code><br/>
 &#160;&#160;&#160;<code>int32 nukeCount = 0;</code><br/>
 &#160;&#160;&#160;<code>// Traverse the contact buffer. Destroy bodies that</code><br/>
 &#160;&#160;&#160;<code>// are touching heavier bodies.</code><br/>
 &#160;&#160;&#160;<code>for (int32 i = 0; i &lt; m_pointCount; ++i)</code><br/>
 &#160;&#160;&#160;<code>{</code><br/>
 &#160;&#160;&#160;&#160;&#160;&#160;<code>ContactPoint* point = m_points + i;</code><br/>
 &#160;&#160;&#160;&#160;&#160;&#160;<code>b2Body* bodyA = point-&gt;fixtureA-&gt;GetBody();</code><br/>
 &#160;&#160;&#160;&#160;&#160;&#160;<code>b2Body* bodyB = point-&gt;FixtureB-&gt;GetBody();</code><br/>
 &#160;&#160;&#160;&#160;&#160;&#160;<code>float32 massA = bodyA-&gt;GetMass();</code><br/>
 &#160;&#160;&#160;&#160;&#160;&#160;<code>float32 massB = bodyB-&gt;GetMass();</code><br/>
 &#160;&#160;&#160;&#160;&#160;&#160;<code>if (massA &gt; 0.0f &amp;&amp; massB &gt; 0.0f)</code><br/>
 &#160;&#160;&#160;&#160;&#160;&#160;<code>{</code><br/>
 &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<code>if (massB &gt; massA)</code><br/>
 &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<code>{</code><br/>
 &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<code>nuke[nukeCount++] = bodyA;</code><br/>
 &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<code>}</code><br/>
 &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<code>else</code><br/>
 &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<code>{</code><br/>
 &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<code>nuke[nukeCount++] = bodyB;</code><br/>
 &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<code>}</code><br/>
 &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<code>if (nukeCount == k_maxNuke)</code><br/>
 &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<code>{</code><br/>
 &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<code>break;</code><br/>
 &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<code>}</code><br/>
 &#160;&#160;&#160;&#160;&#160;&#160;<code>}</code><br/>
 &#160;&#160;&#160;<code>}</code><br/>
 &#160;&#160;&#160;<code>// Sort the nuke array to group duplicates.</code><br/>
 &#160;&#160;&#160;<code>std::sort(nuke, nuke + nukeCount);</code><br/>
 &#160;&#160;&#160;<code>// Destroy the bodies, skipping duplicates.</code><br/>
 &#160;&#160;&#160;<code>int32 i = 0;</code><br/>
 &#160;&#160;&#160;<code>while (i &lt; nukeCount)</code><br/>
 &#160;&#160;&#160;<code>{</code><br/>
 &#160;&#160;&#160;&#160;&#160;&#160;<code>b2Body* b = nuke[i++];</code><br/>
 &#160;&#160;&#160;&#160;&#160;&#160;<code>while (i &lt; nukeCount &amp;&amp; nuke[i] == b)</code><br/>
 &#160;&#160;&#160;&#160;&#160;&#160;<code>{</code><br/>
 &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<code>++i;</code><br/>
 &#160;&#160;&#160;&#160;&#160;&#160;<code>}</code><br/>
 &#160;&#160;&#160;&#160;&#160;&#160;<code>m_world-&gt;DestroyBody(b);</code><br/>
 &#160;&#160;&#160;<code>}</code><br/>
</p>
<h2>Contact Filtering</h2>
<p>Often in a game you don't want all objects to collide. For example, you may want to create a door that only certain characters can pass through. This is called contact filtering, because some interactions are filtered out.</p>
<p>LiquidFun allows you to achieve custom contact filtering by implementing a b2ContactFilter class. This class requires you to implement a ShouldCollide function that receives two b2Shape pointers. Your function returns true if the shapes should collide.</p>
<p>The default implementation of ShouldCollide uses the b2FilterData defined in Chapter 6, Fixtures.</p>
<p>&#160;&#160;&#160;<code>bool b2ContactFilter::ShouldCollide(b2Fixture* fixtureA, b2Fixture* fixtureB)</code><br/>
 &#160;&#160;&#160;<code>{</code><br/>
 &#160;&#160;&#160;&#160;&#160;&#160;<code>const b2Filter&amp; filterA = fixtureA-&gt;GetFilterData();</code><br/>
 &#160;&#160;&#160;&#160;&#160;&#160;<code>const b2Filter&amp; filterB = fixtureB-&gt;GetFilterData();</code><br/>
 &#160;&#160;&#160;&#160;&#160;&#160;<code>if (filterA.groupIndex == filterB.groupIndex &amp;&amp; filterA.groupIndex != 0)</code><br/>
 &#160;&#160;&#160;&#160;&#160;&#160;<code>{</code><br/>
 &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<code>return filterA.groupIndex &gt; 0;</code><br/>
 &#160;&#160;&#160;&#160;&#160;&#160;<code>}</code><br/>
 &#160;&#160;&#160;&#160;&#160;&#160;<code>bool collide = (filterA.maskBits &amp; filterB.categoryBits) != 0 &amp;&amp; (filterA.categoryBits &amp; filterB.maskBits) != 0;</code><br/>
 &#160;&#160;&#160;&#160;&#160;&#160;<code>return collide;</code><br/>
 &#160;&#160;&#160;<code>}</code><br/>
</p>
<p>At run-time you can create an instance of your contact filter and register it with b2World::SetContactFilter. Make sure your filter stays in scope while the world exists.</p>
<p>&#160;&#160;&#160;<code>MyContactFilter filter;</code><br/>
 &#160;&#160;&#160;<code>world-&gt;SetContactFilter(&amp;filter);</code><br/>
 &#160;&#160;&#160;<code>// filter remains in scope â€¦</code><br/>
</p>
<p><em>This content is licensed under <a href="http://creativecommons.org/licenses/by/4.0/legalcode">Creative Commons Attribution 4.0</a>. For details and restrictions, please see the <a href="md__content_license.html">Content License</a>.</em> </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- Google Analytics -->
<script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-46159502-1', 'auto');
ga('create', 'UA-49880327-7', 'auto', {'name': 'liquidFunTracker'});
ga('send', 'pageview');
ga('liquidFunTracker.send', 'pageview');
</script>
</body>
</html>
