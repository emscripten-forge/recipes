From 8e899828d96b4b90f61a87a71f6eb9eba5919e61 Mon Sep 17 00:00:00 2001
From: Ian Thomas <ianthomas23@gmail.com>
Date: Tue, 9 Dec 2025 10:12:57 +0000
Subject: [PATCH 12/15] Extra char length args to f2py source files

---
 scipy/linalg/fblas_l2.pyf.src            | 117 +++---
 scipy/linalg/fblas_l3.pyf.src            |  52 ++-
 scipy/linalg/flapack_gen.pyf.src         | 195 +++++----
 scipy/linalg/flapack_gen_banded.pyf.src  |   7 +-
 scipy/linalg/flapack_gen_tri.pyf.src     |  37 +-
 scipy/linalg/flapack_other.pyf.src       | 488 ++++++++++++++---------
 scipy/linalg/flapack_pos_def.pyf.src     |  65 +--
 scipy/linalg/flapack_pos_def_tri.pyf.src |  28 +-
 scipy/linalg/flapack_sym_herm.pyf.src    | 407 +++++++++++--------
 9 files changed, 865 insertions(+), 531 deletions(-)

diff --git a/scipy/linalg/fblas_l2.pyf.src b/scipy/linalg/fblas_l2.pyf.src
index 27b9972c0d..177dbc4892 100644
--- a/scipy/linalg/fblas_l2.pyf.src
+++ b/scipy/linalg/fblas_l2.pyf.src
@@ -14,16 +14,16 @@
 !
 
 
-subroutine <prefix>gemv(m,n,alpha,a,x,beta,y,offx,incx,offy,incy,trans,rows,cols,ly)
+subroutine <prefix>gemv(m,n,alpha,a,x,beta,y,offx,incx,offy,incy,trans,rows,cols,ly,len0)
   ! Computes a matrix-vector product using a general matrix
   !
   ! y = gemv(alpha,a,x,beta=0,y=0,offx=0,incx=1,offy=0,incy=0,trans=0)
   ! Calculate y <- alpha * op(A) * x + beta * y
 
   callstatement (*f2py_func)((trans?(trans==2?"C":"T"):"N"),&m,&n,&alpha,a,&m, &
-       x+offx,&incx,&beta,y+offy,&incy)
+       x+offx,&incx,&beta,y+offy,&incy,len0)
   callprotoargument char*,F_INT*,F_INT*,<ctype>*,<ctype>*,F_INT*,<ctype>*,F_INT*,<ctype>*, &
-       <ctype>*,F_INT*
+       <ctype>*,F_INT*,F_INT
 
   integer optional, intent(in), check(trans>=0 && trans <=2) :: trans = 0
   integer optional, intent(in), check(incx>0||incx<0) :: incx = 1
@@ -52,10 +52,11 @@ subroutine <prefix>gemv(m,n,alpha,a,x,beta,y,offx,incx,offy,incy,trans,rows,cols
   integer depend(m,n,trans), intent(hide) :: rows = (trans?n:m)
   integer depend(m,n,trans), intent(hide) :: cols = (trans?m:n)
 
+    integer intent(hide) :: len0 = 1
 end subroutine <prefix>gemv
 
 
-subroutine <prefix>gbmv(m,n,kl,ku,alpha,a,lda,x,incx,offx,beta,y,incy,offy,trans,ly)
+subroutine <prefix>gbmv(m,n,kl,ku,alpha,a,lda,x,incx,offx,beta,y,incy,offy,trans,ly,len0)
   ! Performs one of the matrix-vector operations
   !
   !    y := alpha*A*x + beta*y,   or   y := alpha*A**T*x + beta*y,
@@ -64,8 +65,8 @@ subroutine <prefix>gbmv(m,n,kl,ku,alpha,a,lda,x,incx,offx,beta,y,incy,offy,trans
   ! where alpha and beta are scalars, x and y are vectors and A is an
   ! m by n band matrix, with kl sub-diagonals and ku super-diagonals.
 
-  callstatement (*f2py_func)((trans?(trans==2?"C":"T"):"N"),&m,&n,&kl,&ku,&alpha,a,&lda,x+offx,&incx,&beta,y+offy,&incy)
-  callprotoargument char*,F_INT*,F_INT*,F_INT*,F_INT*,<ctype>*,<ctype>*,F_INT*,<ctype>*,F_INT*,<ctype>*,<ctype>*,F_INT*
+  callstatement (*f2py_func)((trans?(trans==2?"C":"T"):"N"),&m,&n,&kl,&ku,&alpha,a,&lda,x+offx,&incx,&beta,y+offy,&incy,len0)
+  callprotoargument char*,F_INT*,F_INT*,F_INT*,F_INT*,<ctype>*,<ctype>*,F_INT*,<ctype>*,F_INT*,<ctype>*,<ctype>*,F_INT*,F_INT
 
   integer optional,intent(in),check(trans>=0 && trans <=2) :: trans = 0
   integer intent(in), depend(ku,kl),check(m>=ku+kl+1) :: m
@@ -95,10 +96,11 @@ subroutine <prefix>gbmv(m,n,kl,ku,alpha,a,lda,x,incx,offx,beta,y,incy,offy,trans
   check(len(x)>offx+(trans==0?n-1:m-1)*abs(incx)) :: x
   depend(offx,n,incx) :: x
 
+    integer intent(hide) :: len0 = 1
 end subroutine <prefix>gbmv
 
 
-subroutine <prefix><s,s,h,h>bmv(n,k,alpha,a,lda,x,incx,offx,beta,y,incy,offy,lower,ly)
+subroutine <prefix><s,s,h,h>bmv(n,k,alpha,a,lda,x,incx,offx,beta,y,incy,offy,lower,ly,len0)
   ! Performs the matrix-vector operation
   !
   !  y := alpha*A*x + beta*y,
@@ -106,8 +108,8 @@ subroutine <prefix><s,s,h,h>bmv(n,k,alpha,a,lda,x,incx,offx,beta,y,incy,offy,low
   ! where alpha and beta are scalars, x and y are n element vectors and
   ! A is an n by n symmetric band matrix, with k super-diagonals.
 
-  callstatement (*f2py_func)((lower?"L":"U"),&n,&k,&alpha,a,&lda,x+offx,&incx,&beta,y+offy,&incy)
-  callprotoargument char*,F_INT*,F_INT*,<ctype>*,<ctype>*,F_INT*,<ctype>*,F_INT*,<ctype>*,<ctype>*,F_INT*
+  callstatement (*f2py_func)((lower?"L":"U"),&n,&k,&alpha,a,&lda,x+offx,&incx,&beta,y+offy,&incy,len0)
+  callprotoargument char*,F_INT*,F_INT*,<ctype>*,<ctype>*,F_INT*,<ctype>*,F_INT*,<ctype>*,<ctype>*,F_INT*,F_INT
 
   integer optional, intent(in),check(lower==0||lower==1) :: lower = 0
   integer intent(hide),depend(a),check(n>=0) :: n = shape(a,1)
@@ -134,16 +136,17 @@ subroutine <prefix><s,s,h,h>bmv(n,k,alpha,a,lda,x,incx,offx,beta,y,incy,offy,low
   check(len(x)>offx+(n-1)*abs(incx)) :: x
   depend(offx,n,incx) :: x
 
+    integer intent(hide) :: len0 = 1
 end subroutine <prefix><s,s,h,h>bmv
 
 
-subroutine <prefix6><s,s,s,s,h,h>pmv(n,alpha,ap,x,incx,offx,beta,y,incy,offy,lower,ly)
+subroutine <prefix6><s,s,s,s,h,h>pmv(n,alpha,ap,x,incx,offx,beta,y,incy,offy,lower,ly,len0)
   ! Computes a matrix-vector product for a symmetric matrix
   !
   ! Calculate y <- alpha * A * x + beta * y, A is symmetric in packed form.
 
-  callstatement (*f2py_func)((lower?"L":"U"),&n,&alpha,ap,x+offx,&incx,&beta,y+offy,&incy)
-  callprotoargument char*,F_INT*,<ctype6>*,<ctype6>*,<ctype6>*,F_INT*,<ctype6>*,<ctype6>*,F_INT*
+  callstatement (*f2py_func)((lower?"L":"U"),&n,&alpha,ap,x+offx,&incx,&beta,y+offy,&incy,len0)
+  callprotoargument char*,F_INT*,<ctype6>*,<ctype6>*,<ctype6>*,F_INT*,<ctype6>*,<ctype6>*,F_INT*,F_INT
 
   integer optional, intent(in),check(lower==0||lower==1) :: lower = 0
   integer intent(in),check(n>=0) :: n
@@ -168,18 +171,19 @@ subroutine <prefix6><s,s,s,s,h,h>pmv(n,alpha,ap,x,incx,offx,beta,y,incy,offy,low
   check(len(x)>offx+(n-1)*abs(incx)) :: x
   depend(offx,n,incx) :: x
 
+    integer intent(hide) :: len0 = 1
 end subroutine <prefix6><s,s,s,s,h,h>pmv
 
 
-subroutine <prefix><symv,\0,hemv,\2>(n,alpha,a,x,beta,y,offx,incx,offy,incy,lower,ly)
+subroutine <prefix><symv,\0,hemv,\2>(n,alpha,a,x,beta,y,offx,incx,offy,incy,lower,ly,len0)
   ! Computes a matrix-vector product for a symmetric/hermitian matrix
   !
   ! Calculate y <- alpha * A * x + beta * y, A is symmetric/hermitian
 
   callstatement (*f2py_func)((lower?"L":"U"),&n,&alpha,a,&n,x+offx,&incx,&beta, &
-       y+offy,&incy)
+       y+offy,&incy,len0)
   callprotoargument char*,F_INT*,<ctype>*,<ctype>*,F_INT*,<ctype>*,F_INT*,<ctype>*, &
-       <ctype>*,F_INT*
+       <ctype>*,F_INT*,F_INT
 
   integer optional, intent(in),check(lower==0||lower==1) :: lower = 0
   integer optional, intent(in),check(incx>0||incx<0) :: incx = 1
@@ -204,6 +208,7 @@ subroutine <prefix><symv,\0,hemv,\2>(n,alpha,a,x,beta,y,offx,incx,offy,incy,lowe
   check(len(y)>offy+(n-1)*abs(incy)) :: y
   depend(offy,n,incy) :: y
 
+    integer intent(hide) :: len0 = 1
 end subroutine  <prefix><symv,\0,hemv,\2>
 
 
@@ -229,14 +234,14 @@ subroutine <prefix6>ger<,,u,u,c,c>(m,n,alpha,x,incx,y,incy,a,lda)
 end subroutine <prefix6>ger<,,u,u,c,c>
 
 
-subroutine <prefix6><sy,\0,\0,\0, he,\4>r(alpha,x,lower,incx,offx,n,a)
+subroutine <prefix6><sy,\0,\0,\0, he,\4>r(alpha,x,lower,incx,offx,n,a,len0)
   ! Performs a rank-1 update of a symmetric/hermitian matrix.
   !
   ! Calculate a <- alpha*x*x^T + a
   ! Calculate a <- alpha*x*x^H + a
   !
-    callstatement (*f2py_func)((lower?"L":"U"),&n,&alpha,x+offx,&incx,a,&n)
-    callprotoargument char*, F_INT*, <ctype6>*, <ctype6>*, F_INT*, <ctype6>*, F_INT*
+    callstatement (*f2py_func)((lower?"L":"U"),&n,&alpha,x+offx,&incx,a,&n,len0)
+    callprotoargument char*, F_INT*, <ctype6>*, <ctype6>*, F_INT*, <ctype6>*, F_INT*,F_INT
 
     integer, optional, intent(in), check(lower == 0 || lower == 1) :: lower = 0
     <ftype6> intent(in) :: alpha
@@ -254,17 +259,18 @@ subroutine <prefix6><sy,\0,\0,\0, he,\4>r(alpha,x,lower,incx,offx,n,a)
     <ftype6> dimension(n,n), intent(in,copy,out), optional :: a
     depend(x, offx, incx, n) :: a
 
+    integer intent(hide) :: len0 = 1
 end subroutine <prefix6><sy,\0,\0,\0, he,\4>r
 
 
-subroutine <prefix><sy, \0, he, \2>r2(alpha,x,y,lower,incx,offx,incy,offy,n,a)
+subroutine <prefix><sy, \0, he, \2>r2(alpha,x,y,lower,incx,offx,incy,offy,n,a,len0)
   ! Performs a rank-2 update of a symmetric/hermitian matrix.
   !
   ! Calculate a <- alpha*x*y^T + alpha*y*x^T + a
   ! Calculate a <- alpha*x*y^H + alpha*y*x^H + a
   !
-    callstatement (*f2py_func)((lower?"L":"U"),&n,&alpha,x+offx,&incx,y+offy,&incy,a,&n)
-    callprotoargument char*, F_INT*, <ctype>*, <ctype>*, F_INT*, <ctype>*, F_INT*, <ctype>*, F_INT*
+    callstatement (*f2py_func)((lower?"L":"U"),&n,&alpha,x+offx,&incx,y+offy,&incy,a,&n,len0)
+    callprotoargument char*, F_INT*, <ctype>*, <ctype>*, F_INT*, <ctype>*, F_INT*, <ctype>*, F_INT*,F_INT
 
     integer intent(in), optional, check(lower == 0 || lower == 1) :: lower = 0
     <ftype> intent(in) :: alpha
@@ -283,10 +289,11 @@ subroutine <prefix><sy, \0, he, \2>r2(alpha,x,y,lower,incx,offx,incy,offy,n,a)
 
     <ftype> dimension(n,n), intent(in,copy,out), optional :: a
     depend(incx, offx, x, incy, offy, y, n) :: a
+    integer intent(hide) :: len0 = 1
 end subroutine <prefix><sy, \0, he, \2>r2
 
 
-subroutine <prefix6><s,s,s,s,h,h>pr(n,alpha,x,incx,offx,ap,lower)
+subroutine <prefix6><s,s,s,s,h,h>pr(n,alpha,x,incx,offx,ap,lower,len0)
   ! Performs the symmetric rank 1 operation
   !
   !       A := alpha*x*x**T(H) + A,
@@ -294,8 +301,8 @@ subroutine <prefix6><s,s,s,s,h,h>pr(n,alpha,x,incx,offx,ap,lower)
   ! where alpha is a scalar, x is an n element vector and A is an n x n
   ! symmetric/hermitian matrix, supplied in packed form.
 
-    callstatement (*f2py_func)((lower?"L":"U"),&n,&alpha,x+offx,&incx,ap)
-    callprotoargument char*,F_INT*,<ctype6creal>*,<ctype6>*,F_INT*,<ctype6>*
+    callstatement (*f2py_func)((lower?"L":"U"),&n,&alpha,x+offx,&incx,ap,len0)
+    callprotoargument char*,F_INT*,<ctype6creal>*,<ctype6>*,F_INT*,<ctype6>*,F_INT
 
     integer intent(in),check(n>=0) :: n
     integer intent(in), optional, check(lower == 0 || lower == 1) :: lower = 0
@@ -311,18 +318,19 @@ subroutine <prefix6><s,s,s,s,h,h>pr(n,alpha,x,incx,offx,ap,lower)
     <ftype6> dimension(*),depend(n),intent(in,out,copy,out=apu) :: ap
     check(len(ap)>=(n*(n+1)/2)) :: ap
 
+    integer intent(hide) :: len0 = 1
 end subroutine <prefix6><s,s,s,s,h,h>pr
 
 
-subroutine <prefix><s,s,h,h>pr2(n,alpha,x,incx,offx,y,incy,offy,ap,lower)
+subroutine <prefix><s,s,h,h>pr2(n,alpha,x,incx,offx,y,incy,offy,ap,lower,len0)
   ! Performs the symmetric rank 2 operation
   !
   !    A := alpha*x*y**T + alpha*y*x**T + A,
   !
   ! where alpha is a scalar, x and y are n element vectors and A is an
   ! n by n symmetric/hermitian matrix, supplied in packed form.
-    callstatement (*f2py_func)((lower?"L":"U"),&n,&alpha,x+offx,&incx,y+offy,&incy,ap)
-    callprotoargument char*,F_INT*,<ctype>*,<ctype>*,F_INT*,<ctype>*,F_INT*,<ctype>*
+    callstatement (*f2py_func)((lower?"L":"U"),&n,&alpha,x+offx,&incx,y+offy,&incy,ap,len0)
+    callprotoargument char*,F_INT*,<ctype>*,<ctype>*,F_INT*,<ctype>*,F_INT*,<ctype>*,F_INT
 
     integer intent(in),check(n>=0) :: n
     integer intent(in), optional, check(lower == 0 || lower == 1) :: lower = 0
@@ -345,9 +353,10 @@ subroutine <prefix><s,s,h,h>pr2(n,alpha,x,incx,offx,y,incy,offy,ap,lower)
     <ftype> dimension(*),depend(n),intent(in,out,copy,out=apu) :: ap
     check(len(ap)>=(n*(n+1)/2)) :: ap
 
+    integer intent(hide) :: len0 = 1
 end subroutine<prefix><s,s,h,h>pr2
 
-subroutine <prefix>tbsv(n,k,a,lda,x,incx,offx,lower,trans,diag)
+subroutine <prefix>tbsv(n,k,a,lda,x,incx,offx,lower,trans,diag,len0,len1,len2)
   ! Solves one of the systems of equations
   !
   !    A*xout = x,   or   A**T*xout = x,   or   A**H*xout = x,
@@ -358,8 +367,8 @@ subroutine <prefix>tbsv(n,k,a,lda,x,incx,offx,lower,trans,diag)
   ! No test for singularity or near-singularity is included in this
   ! routine. Such tests must be performed before calling this routine.
 
-  callstatement (*f2py_func)((lower?"L":"U"),(trans?(trans==2?"C":"T"):"N"),(diag?"U":"N"),&n,&k,a,&lda,x+offx,&incx)
-  callprotoargument char*,char*,char*,F_INT*,F_INT*,<ctype>*,F_INT*,<ctype>*,F_INT*
+  callstatement (*f2py_func)((lower?"L":"U"),(trans?(trans==2?"C":"T"):"N"),(diag?"U":"N"),&n,&k,a,&lda,x+offx,&incx,len0,len1,len2)
+  callprotoargument char*,char*,char*,F_INT*,F_INT*,<ctype>*,F_INT*,<ctype>*,F_INT*,F_INT,F_INT,F_INT
 
   integer intent(hide),check(n>=0),depend(a) :: n = shape(a,1)
   integer intent(in), optional, check(lower == 0 || lower == 1) :: lower = 0
@@ -377,10 +386,13 @@ subroutine <prefix>tbsv(n,k,a,lda,x,incx,offx,lower,trans,diag)
   check(len(x)>offx+(n-1)*abs(incx)) :: x
   depend(offx,n,incx) :: x
 
+    integer intent(hide) :: len0 = 1
+    integer intent(hide) :: len1 = 1
+    integer intent(hide) :: len2 = 1
 end subroutine <prefix>tbsv
 
 
-subroutine <prefix>tpsv(n,ap,x,incx,offx,lower,trans,diag)
+subroutine <prefix>tpsv(n,ap,x,incx,offx,lower,trans,diag,len0,len1,len2)
   ! Solves one of the systems of equations
   !
   !    A*xout = x,   or   A**T*xout = x,   or   A**H*xout = x,
@@ -391,8 +403,8 @@ subroutine <prefix>tpsv(n,ap,x,incx,offx,lower,trans,diag)
   ! No test for singularity or near-singularity is included in this
   ! routine. Such tests must be performed before calling this routine.
 
-  callstatement (*f2py_func)((lower?"L":"U"),(trans?(trans==2?"C":"T"):"N"),(diag?"U":"N"),&n,ap,x+offx,&incx)
-  callprotoargument char*,char*,char*,F_INT*,<ctype>*,<ctype>*,F_INT*
+  callstatement (*f2py_func)((lower?"L":"U"),(trans?(trans==2?"C":"T"):"N"),(diag?"U":"N"),&n,ap,x+offx,&incx,len0,len1,len2)
+  callprotoargument char*,char*,char*,F_INT*,<ctype>*,<ctype>*,F_INT*,F_INT,F_INT,F_INT
 
   integer intent(in),check(n>=0) :: n
   integer intent(in), optional, check(lower == 0 || lower == 1) :: lower = 0
@@ -408,18 +420,21 @@ subroutine <prefix>tpsv(n,ap,x,incx,offx,lower,trans,diag)
   check(len(x)>offx+(n-1)*abs(incx)) :: x
   depend(offx,n,incx) :: x
 
+    integer intent(hide) :: len0 = 1
+    integer intent(hide) :: len1 = 1
+    integer intent(hide) :: len2 = 1
 end subroutine <prefix>tpsv
 
 
-subroutine <prefix>trmv(n,a,x,offx,incx,lower,trans,diag)
+subroutine <prefix>trmv(n,a,x,offx,incx,lower,trans,diag,len0,len1,len2)
   ! Computes a matrix-vector product using a triangular matrix
   !
   ! x <- op(A) * x, A is triangular
   !
 
   callstatement (*f2py_func)((lower?"L":"U"), (trans?(trans==2?"C":"T"):"N"), &
-       (diag?"U":"N"),&n,a,&n,x+offx,&incx)
-  callprotoargument char*,char*,char*,F_INT*,<ctype>*,F_INT*,<ctype>*,F_INT*
+       (diag?"U":"N"),&n,a,&n,x+offx,&incx,len0,len1,len2)
+  callprotoargument char*,char*,char*,F_INT*,<ctype>*,F_INT*,<ctype>*,F_INT*,F_INT,F_INT,F_INT
 
   integer optional, intent(in), check(trans>=0 && trans <=2) :: trans = 0
   integer optional, intent(in), check(lower==0||lower==1) :: lower = 0
@@ -436,10 +451,13 @@ subroutine <prefix>trmv(n,a,x,offx,incx,lower,trans,diag)
   check(len(x)>offx+(n-1)*abs(incx)) :: n
   depend(x,offx,incx) :: n
 
+    integer intent(hide) :: len0 = 1
+    integer intent(hide) :: len1 = 1
+    integer intent(hide) :: len2 = 1
 end subroutine <prefix>trmv
 
 
-subroutine <prefix>trsv(n,a,lda,x,incx,offx,lower,trans,diag)
+subroutine <prefix>trsv(n,a,lda,x,incx,offx,lower,trans,diag,len0,len1,len2)
   ! Solves one of the systems of equations
   !
   !    A*xout = x,   or   A**T*xout = x,   or   A**H*xout = x,
@@ -450,8 +468,8 @@ subroutine <prefix>trsv(n,a,lda,x,incx,offx,lower,trans,diag)
   ! No test for singularity or near-singularity is included in this
   ! routine. Such tests must be performed before calling this routine.
 
-  callstatement (*f2py_func)((lower?"L":"U"),(trans?(trans==2?"C":"T"):"N"),(diag?"U":"N"),&n,a,&lda,x+offx,&incx)
-  callprotoargument char*,char*,char*,F_INT*,<ctype>*,F_INT*,<ctype>*,F_INT*
+  callstatement (*f2py_func)((lower?"L":"U"),(trans?(trans==2?"C":"T"):"N"),(diag?"U":"N"),&n,a,&lda,x+offx,&incx,len0,len1,len2)
+  callprotoargument char*,char*,char*,F_INT*,<ctype>*,F_INT*,<ctype>*,F_INT*,F_INT,F_INT,F_INT
 
   integer intent(hide),check(n>=0),depend(a) :: n = shape(a,0)
   integer intent(in), optional, check(lower == 0 || lower == 1) :: lower = 0
@@ -468,10 +486,13 @@ subroutine <prefix>trsv(n,a,lda,x,incx,offx,lower,trans,diag)
   check(len(x)>offx+(n-1)*abs(incx)) :: x
   depend(offx,n,incx) :: x
 
+    integer intent(hide) :: len0 = 1
+    integer intent(hide) :: len1 = 1
+    integer intent(hide) :: len2 = 1
 end subroutine <prefix>trsv
 
 
-subroutine <prefix>tbmv(n,k,a,lda,x,incx,offx,lower,trans,diag)
+subroutine <prefix>tbmv(n,k,a,lda,x,incx,offx,lower,trans,diag,len0,len1,len2)
   ! Solves one of the systems of equations
   !
   !    A*xout = x,   or   A**T*xout = x,   or   A**H*xout = x,
@@ -479,8 +500,8 @@ subroutine <prefix>tbmv(n,k,a,lda,x,incx,offx,lower,trans,diag)
   ! where xout and x are an n element vector and  A is an n by n unit, or non-unit,
   ! upper or lower triangular band matrix, with ( k + 1 ) diagonals.
 
-  callstatement (*f2py_func)((lower?"L":"U"),(trans?(trans==2?"C":"T"):"N"),(diag?"U":"N"),&n,&k,a,&lda,x+offx,&incx)
-  callprotoargument char*,char*,char*,F_INT*,F_INT*,<ctype>*,F_INT*,<ctype>*,F_INT*
+  callstatement (*f2py_func)((lower?"L":"U"),(trans?(trans==2?"C":"T"):"N"),(diag?"U":"N"),&n,&k,a,&lda,x+offx,&incx,len0,len1,len2)
+  callprotoargument char*,char*,char*,F_INT*,F_INT*,<ctype>*,F_INT*,<ctype>*,F_INT*,F_INT,F_INT,F_INT
 
   integer intent(hide),check(n>=0),depend(a) :: n = shape(a,1)
   integer intent(in), optional, check(lower == 0 || lower == 1) :: lower = 0
@@ -498,10 +519,13 @@ subroutine <prefix>tbmv(n,k,a,lda,x,incx,offx,lower,trans,diag)
   check(len(x)>offx+(n-1)*abs(incx)) :: x
   depend(offx,n,incx) :: x
 
+    integer intent(hide) :: len0 = 1
+    integer intent(hide) :: len1 = 1
+    integer intent(hide) :: len2 = 1
 end subroutine <prefix>tbmv
 
 
-subroutine <prefix>tpmv(n,ap,x,incx,offx,lower,trans,diag)
+subroutine <prefix>tpmv(n,ap,x,incx,offx,lower,trans,diag,len0,len1,len2)
   ! performs one of the matrix-vector operations
   !
   !  x := A*x,   or   x := A**T*x,
@@ -509,8 +533,8 @@ subroutine <prefix>tpmv(n,ap,x,incx,offx,lower,trans,diag)
   ! where x is n element vectors and A is an n by n unit, or
   ! non-unit, upper or lower triangular matrix, supplied in packed form.
 
-  callstatement (*f2py_func)((lower?"L":"U"),(trans?(trans==2?"C":"T"):"N"),(diag?"U":"N"),&n,ap,x+offx,&incx)
-  callprotoargument char*,char*,char*,F_INT*,<ctype>*,<ctype>*,F_INT*
+  callstatement (*f2py_func)((lower?"L":"U"),(trans?(trans==2?"C":"T"):"N"),(diag?"U":"N"),&n,ap,x+offx,&incx,len0,len1,len2)
+  callprotoargument char*,char*,char*,F_INT*,<ctype>*,<ctype>*,F_INT*,F_INT,F_INT,F_INT
 
   integer intent(in),check(n>=0) :: n
   integer intent(in), optional, check(lower == 0 || lower == 1) :: lower = 0
@@ -526,4 +550,7 @@ subroutine <prefix>tpmv(n,ap,x,incx,offx,lower,trans,diag)
   check(len(x)>offx+(n-1)*abs(incx)) :: x
   depend(offx,n,incx) :: x
 
+    integer intent(hide) :: len0 = 1
+    integer intent(hide) :: len1 = 1
+    integer intent(hide) :: len2 = 1
 end subroutine <prefix>tpmv
diff --git a/scipy/linalg/fblas_l3.pyf.src b/scipy/linalg/fblas_l3.pyf.src
index 11789a5eb8..8128204103 100644
--- a/scipy/linalg/fblas_l3.pyf.src
+++ b/scipy/linalg/fblas_l3.pyf.src
@@ -13,7 +13,7 @@
 !
 
 
-subroutine <prefix>gemm(m,n,k,alpha,a,b,beta,c,trans_a,trans_b,lda,ka,ldb,kb)
+subroutine <prefix>gemm(m,n,k,alpha,a,b,beta,c,trans_a,trans_b,lda,ka,ldb,kb,len0,len1)
   ! Computes a scalar-matrix-matrix product and adds the result to a
   ! scalar-matrix product.
   !
@@ -21,9 +21,9 @@ subroutine <prefix>gemm(m,n,k,alpha,a,b,beta,c,trans_a,trans_b,lda,ka,ldb,kb)
   ! Calculate C <- alpha * op(A) * op(B) + beta * C
 
   callstatement (*f2py_func)((trans_a?(trans_a==2?"C":"T"):"N"), &
-       (trans_b?(trans_b==2?"C":"T"):"N"),&m,&n,&k,&alpha,a,&lda,b,&ldb,&beta,c,&m)
+       (trans_b?(trans_b==2?"C":"T"):"N"),&m,&n,&k,&alpha,a,&lda,b,&ldb,&beta,c,&m,len0,len1)
   callprotoargument char*,char*,F_INT*,F_INT*,F_INT*,<ctype>*,<ctype>*,F_INT*,<ctype>*, &
-       F_INT*,<ctype>*,<ctype>*,F_INT*
+       F_INT*,<ctype>*,<ctype>*,F_INT*,F_INT,F_INT
 
   integer optional,intent(in),check(trans_a>=0 && trans_a <=2) :: trans_a = 0
   integer optional,intent(in),check(trans_b>=0 && trans_b <=2) :: trans_b = 0
@@ -45,10 +45,12 @@ subroutine <prefix>gemm(m,n,k,alpha,a,b,beta,c,trans_a,trans_b,lda,ka,ldb,kb)
   integer depend(b,trans_b,kb,ldb,k),intent(hide),check(trans_b?kb==k:ldb==k) :: &
        n = (trans_b?ldb:kb)
 
+    integer intent(hide) :: len0 = 1
+    integer intent(hide) :: len1 = 1
 end subroutine <prefix>gemm
 
 
-subroutine <prefix6><sy,\0,\0,\0,he,he>mm(m, n, alpha, a, b, beta, c, side, lower, lda, ka, ldb, kb)
+subroutine <prefix6><sy,\0,\0,\0,he,he>mm(m, n, alpha, a, b, beta, c, side, lower, lda, ka, ldb, kb,len0,len1)
   ! Computes a scalar-matrix-matrix product and adds the result to a
   ! scalar-matrix product, where one of the matrices is symmetric.
   !
@@ -57,9 +59,9 @@ subroutine <prefix6><sy,\0,\0,\0,he,he>mm(m, n, alpha, a, b, beta, c, side, lowe
   !           C <- alpha * B * A + beta * C
 
   callstatement (*f2py_func)((side?"R":"L"), &
-       (lower?"L":"U"),&m,&n,&alpha,a,&lda,b,&ldb,&beta,c,&m)
+       (lower?"L":"U"),&m,&n,&alpha,a,&lda,b,&ldb,&beta,c,&m,len0,len1)
   callprotoargument char*,char*,F_INT*,F_INT*,<ctype6>*,<ctype6>*,F_INT*,<ctype6>*, &
-       F_INT*,<ctype6>*,<ctype6>*,F_INT*
+       F_INT*,<ctype6>*,<ctype6>*,F_INT*,F_INT,F_INT
 
   integer optional, intent(in),check(side==0||side==1) :: side = 0
   integer optional, intent(in),check(lower==0||lower==1) :: lower = 0
@@ -81,20 +83,22 @@ subroutine <prefix6><sy,\0,\0,\0,he,he>mm(m, n, alpha, a, b, beta, c, side, lowe
   integer depend(side, a, lda, ka, b, ldb, kb), intent(hide), &
         check(side? kb==lda : ka==ldb) :: n = (side ? ka : kb)
 
+    integer intent(hide) :: len0 = 1
+    integer intent(hide) :: len1 = 1
 end subroutine <prefix6><sy,\0,\0,\0,he,he>mm
 
 
 
-subroutine <prefix6><sy,\0,\0,\0,he,he>rk(n,k,alpha,a,beta,c,trans,lower,lda,ka)
+subroutine <prefix6><sy,\0,\0,\0,he,he>rk(n,k,alpha,a,beta,c,trans,lower,lda,ka,len0,len1)
   !  performs one of the symmetric rank k operations
   !     C := alpha*A*A**T + beta*C,  or   C := alpha*A**T*A + beta*C,
   !
   ! c = syrk(alpha,a,beta=0,c=0,trans=0,lower=0,overwrite_c=0)
   !
   callstatement (*f2py_func)((lower?"L":"U"), &
-        (trans?(trans==2?"C":"T"):"N"), &n,&k,&alpha,a,&lda,&beta,c,&n)
+        (trans?(trans==2?"C":"T"):"N"), &n,&k,&alpha,a,&lda,&beta,c,&n,len0,len1)
   callprotoargument char*,char*,F_INT*,F_INT*,<ctype6>*,<ctype6>*,F_INT*,<ctype6>*, &
-        <ctype6>*,F_INT*
+        <ctype6>*,F_INT*,F_INT,F_INT
 
   integer optional, intent(in),check(lower==0||lower==1) :: lower = 0
   integer optional,intent(in),check(trans>=0 && trans <=2) :: trans = 0
@@ -112,10 +116,12 @@ subroutine <prefix6><sy,\0,\0,\0,he,he>rk(n,k,alpha,a,beta,c,trans,lower,lda,ka)
   integer depend(a, trans, ka, lda), intent(hide) :: n = (trans ? ka : lda)
   integer depend(a, trans, ka, lda), intent(hide) :: k = (trans ? lda : ka)
 
+    integer intent(hide) :: len0 = 1
+    integer intent(hide) :: len1 = 1
 end subroutine <prefix6><sy,\0,\0,\0,he,he>rk
 
 
-subroutine <prefix6><sy,\0,\0,\0,he,he>r2k(n,k,alpha,a,b,beta,c,trans,lower,lda,ka, ldb, kb)
+subroutine <prefix6><sy,\0,\0,\0,he,he>r2k(n,k,alpha,a,b,beta,c,trans,lower,lda,ka, ldb, kb,len0,len1)
   !  performs one of the symmetric/hermitian rank 2k operations
   !     C := alpha*A*B**T + alpha*B*A**T + beta*C,  or
   !     C:=alpha*A**T*B + alpha*B**T*A + beta*C
@@ -123,9 +129,9 @@ subroutine <prefix6><sy,\0,\0,\0,he,he>r2k(n,k,alpha,a,b,beta,c,trans,lower,lda,
   ! c = syr2k(alpha,a,b,beta=0,c=0,trans=0,lower=0,overwrite_c=0)
   !
   callstatement (*f2py_func)((lower?"L":"U"), &
-        (trans?(trans==2?"C":"T"):"N"), &n,&k,&alpha,a,&lda,b,&ldb,&beta,c,&n)
+        (trans?(trans==2?"C":"T"):"N"), &n,&k,&alpha,a,&lda,b,&ldb,&beta,c,&n,len0,len1)
   callprotoargument char*,char*,F_INT*,F_INT*,<ctype6>*,<ctype6>*,F_INT*,<ctype6>*,F_INT*, &
-        <ctype6>*, <ctype6>*,F_INT*
+        <ctype6>*, <ctype6>*,F_INT*,F_INT,F_INT
 
   integer optional, intent(in),check(lower==0||lower==1) :: lower = 0
   integer optional,intent(in),check(trans>=0 && trans <=2) :: trans = 0
@@ -147,10 +153,12 @@ subroutine <prefix6><sy,\0,\0,\0,he,he>r2k(n,k,alpha,a,b,beta,c,trans,lower,lda,
   integer depend(a, b, trans, ka, lda, kb, ldb), intent(hide), &
         check(trans ? lda==ldb: ka==kb) :: k = (trans ? lda : ka)
 
+    integer intent(hide) :: len0 = 1
+    integer intent(hide) :: len1 = 1
 end subroutine <prefix6><sy,\0,\0,\0,he,he>r2k
 
 
-subroutine <prefix>trmm(m, n, k, alpha, a, b, lda, ldb, side, lower, trans_a, diag)
+subroutine <prefix>trmm(m, n, k, alpha, a, b, lda, ldb, side, lower, trans_a, diag,len0,len1,len2,len3)
 
   !  performs one of the matrix-matrix operations
   !
@@ -163,8 +171,8 @@ subroutine <prefix>trmm(m, n, k, alpha, a, b, lda, ldb, side, lower, trans_a, di
   !
   ! c = trmm(alpha, a, b, side=0, lower=0, trans_a=0, diag=0)
 
-  callstatement (*f2py_func)((side?"R":"L"), (lower?"L":"U"),(trans_a?(trans_a==2?"C":"T"):"N"), (diag?"U":"N"), &m, &n, &alpha, a, &lda, b, &ldb)
-  callprotoargument char*, char*, char*, char*, F_INT*, F_INT*, <ctype>*,<ctype>*,F_INT*,<ctype>*, F_INT*
+  callstatement (*f2py_func)((side?"R":"L"), (lower?"L":"U"),(trans_a?(trans_a==2?"C":"T"):"N"), (diag?"U":"N"), &m, &n, &alpha, a, &lda, b, &ldb,len0,len1,len2,len3)
+  callprotoargument char*, char*, char*, char*, F_INT*, F_INT*, <ctype>*,<ctype>*,F_INT*,<ctype>*, F_INT*,F_INT,F_INT,F_INT,F_INT
 
   integer optional, intent(in), check(side==0 || side==1) :: side = 0
   integer optional, intent(in), check(lower==0 || lower==1) :: lower = 0
@@ -183,10 +191,14 @@ subroutine <prefix>trmm(m, n, k, alpha, a, b, lda, ldb, side, lower, trans_a, di
   integer intent(hide), depend(b) :: m = shape(b, 0)
   integer intent(hide), depend(b) :: n = shape(b, 1)
 
+    integer intent(hide) :: len0 = 1
+    integer intent(hide) :: len1 = 1
+    integer intent(hide) :: len2 = 1
+    integer intent(hide) :: len3 = 1
 end subroutine <prefix>trmm
 
 
-subroutine <prefix>trsm(m, n, alpha, a, b, lda, ldb, side, lower, trans_a, diag)
+subroutine <prefix>trsm(m, n, alpha, a, b, lda, ldb, side, lower, trans_a, diag,len0,len1,len2,len3)
   !
   !  Solves one of the matrix equations
   !
@@ -199,8 +211,8 @@ subroutine <prefix>trsm(m, n, alpha, a, b, lda, ldb, side, lower, trans_a, diag)
   !
 
   callstatement (*f2py_func)((side?"R":"L"), (lower?"L":"U"), &
-        (trans_a?(trans_a==2?"C":"T"):"N"), (diag?"U":"N"), &m, &n, &alpha, a, &lda, b, &ldb)
-  callprotoargument char*, char*, char*, char*, F_INT*, F_INT*, <ctype>*,<ctype>*,F_INT*,<ctype>*, F_INT*
+        (trans_a?(trans_a==2?"C":"T"):"N"), (diag?"U":"N"), &m, &n, &alpha, a, &lda, b, &ldb,len0,len1,len2,len3)
+  callprotoargument char*, char*, char*, char*, F_INT*, F_INT*, <ctype>*,<ctype>*,F_INT*,<ctype>*, F_INT*,F_INT,F_INT,F_INT,F_INT
 
   integer optional, intent(in), check(side==0 || side==1) :: side = 0
   integer optional, intent(in), check(lower==0 || lower==1) :: lower = 0
@@ -219,4 +231,8 @@ subroutine <prefix>trsm(m, n, alpha, a, b, lda, ldb, side, lower, trans_a, diag)
   check(shape(a,0)==shape(a,1)) :: a
   check(shape(a,0)==(side?n:m)) :: a
 
+    integer intent(hide) :: len0 = 1
+    integer intent(hide) :: len1 = 1
+    integer intent(hide) :: len2 = 1
+    integer intent(hide) :: len3 = 1
 end subroutine <prefix>trsm
diff --git a/scipy/linalg/flapack_gen.pyf.src b/scipy/linalg/flapack_gen.pyf.src
index 04037fdcab..7de01f169d 100644
--- a/scipy/linalg/flapack_gen.pyf.src
+++ b/scipy/linalg/flapack_gen.pyf.src
@@ -1,7 +1,7 @@
 ! Signatures for f2py-wrappers of FORTRAN LAPACK General Matrix functions.
 !
 
-subroutine <prefix>gebal(scale,permute,n,a,m,lo,hi,pivscale,info)
+subroutine <prefix>gebal(scale,permute,n,a,m,lo,hi,pivscale,info,len0)
     !
     ! ba,lo,hi,pivscale,info = gebal(a,scale=0,permute=0,overwrite_a=0)
     ! Balance general matrix a.
@@ -16,8 +16,8 @@ subroutine <prefix>gebal(scale,permute,n,a,m,lo,hi,pivscale,info)
     ! where D = diag(d), T1,T2 are upper triangular matrices.
     ! lo,hi mark the starting and ending columns of submatrix B.
 
-    callstatement { (*f2py_func)((permute?(scale?"B":"P"):(scale?"S":"N")),&n,a,&m,&lo,&hi,pivscale,&info); hi--; lo--; }
-    callprotoargument char*,F_INT*,<ctype>*,F_INT*,F_INT*,F_INT*,<ctypereal>*,F_INT*
+    callstatement { (*f2py_func)((permute?(scale?"B":"P"):(scale?"S":"N")),&n,a,&m,&lo,&hi,pivscale,&info,len0); hi--; lo--; }
+    callprotoargument char*,F_INT*,<ctype>*,F_INT*,F_INT*,F_INT*,<ctypereal>*,F_INT*,F_INT
     integer intent(in),optional :: permute = 0
     integer intent(in),optional :: scale = 0
     integer intent(hide),depend(a,n) :: m = shape(a,0)
@@ -28,6 +28,7 @@ subroutine <prefix>gebal(scale,permute,n,a,m,lo,hi,pivscale,info)
     <ftype> dimension(m,n),intent(in,out,copy,out=ba) :: a
     integer intent(out) :: info
 
+    integer intent(hide) :: len0 = 1
 end subroutine <prefix>gebal
 
 subroutine <prefix>gehrd(n,lo,hi,a,tau,work,lwork,info)
@@ -99,13 +100,13 @@ subroutine <prefix>gesv(n,nrhs,a,piv,b,info)
     intent(in,out,copy,out=lu) a
 end subroutine <prefix>gesv
 
-subroutine <prefix2>gesvx(fact,trans,n,nrhs,a,lda,af,ldaf,ipiv,equed,r,c,b,ldb,x,ldx,rcond,ferr,berr,work,iwork,info)
+subroutine <prefix2>gesvx(fact,trans,n,nrhs,a,lda,af,ldaf,ipiv,equed,r,c,b,ldb,x,ldx,rcond,ferr,berr,work,iwork,info,len0,len1,len2)
     ! Solve A * X = B using LU decomposition
     ! The expert driver of ?GESV with condition number, backward/forward error estimates, and iterative refinement
     ! This part takes care of the data types, single and double reals (sgesvx and dgesvx)
     threadsafe
-    callstatement {F_INT i;(*f2py_func)(fact,trans,&n,&nrhs,a,&lda,af,&ldaf,ipiv,equed,r,c,b,&ldb,x,&ldx,&rcond,ferr,berr,work,iwork,&info);for(i=0;i\<n;--ipiv[i++]);}
-    callprotoargument char*,char*,F_INT*,F_INT*,<ctype2>*,F_INT*,<ctype2>*,F_INT*,F_INT*,char*,<ctype2>*,<ctype2>*,<ctype2>*,F_INT*,<ctype2>*,F_INT*,<ctype2>*,<ctype2>*,<ctype2>*,<ctype2>*,F_INT*,F_INT*
+    callstatement {F_INT i;(*f2py_func)(fact,trans,&n,&nrhs,a,&lda,af,&ldaf,ipiv,equed,r,c,b,&ldb,x,&ldx,&rcond,ferr,berr,work,iwork,&info,len0,len1,len2);for(i=0;i\<n;--ipiv[i++]);}
+    callprotoargument char*,char*,F_INT*,F_INT*,<ctype2>*,F_INT*,<ctype2>*,F_INT*,F_INT*,char*,<ctype2>*,<ctype2>*,<ctype2>*,F_INT*,<ctype2>*,F_INT*,<ctype2>*,<ctype2>*,<ctype2>*,<ctype2>*,F_INT*,F_INT*,F_INT,F_INT,F_INT
 
     character optional,intent(in):: trans = "N"
     character optional,intent(in):: fact = "E"
@@ -130,15 +131,18 @@ subroutine <prefix2>gesvx(fact,trans,n,nrhs,a,lda,af,ldaf,ipiv,equed,r,c,b,ldb,x
     integer intent(hide,cache),dimension(n),depend(n) :: iwork
     integer intent(out):: info
 
+    integer intent(hide) :: len0 = 1
+    integer intent(hide) :: len1 = 1
+    integer intent(hide) :: len2 = 1
 end subroutine <prefix2>gesvx
 
-subroutine <prefix2c>gesvx(fact,trans,n,nrhs,a,lda,af,ldaf,ipiv,equed,r,c,b,ldb,x,ldx,rcond,ferr,berr,work,rwork,info)
+subroutine <prefix2c>gesvx(fact,trans,n,nrhs,a,lda,af,ldaf,ipiv,equed,r,c,b,ldb,x,ldx,rcond,ferr,berr,work,rwork,info,len0,len1,len2)
     ! Solve A * X = B using LU decomposition
     ! The expert driver of ?GESV with condition number, backward/forward error estimates, and iterative refinement
     ! This part takes care of the data types, complex and double complex (cgesvx and zgesvx)
     threadsafe
-    callstatement {F_INT i;(*f2py_func)(fact,trans,&n,&nrhs,a,&lda,af,&ldaf,ipiv,equed,r,c,b,&ldb,x,&ldx,&rcond,ferr,berr,work,rwork,&info);for(i=0;i\<n;--ipiv[i++]);}
-    callprotoargument char*,char*,F_INT*,F_INT*,<ctype2c>*,F_INT*,<ctype2c>*,F_INT*,F_INT*,char*,<ctype2>*,<ctype2>*,<ctype2c>*,F_INT*,<ctype2c>*,F_INT*,<ctype2>*,<ctype2>*,<ctype2>*,<ctype2c>*,<ctype2>*,F_INT*
+    callstatement {F_INT i;(*f2py_func)(fact,trans,&n,&nrhs,a,&lda,af,&ldaf,ipiv,equed,r,c,b,&ldb,x,&ldx,&rcond,ferr,berr,work,rwork,&info,len0,len1,len2);for(i=0;i\<n;--ipiv[i++]);}
+    callprotoargument char*,char*,F_INT*,F_INT*,<ctype2c>*,F_INT*,<ctype2c>*,F_INT*,F_INT*,char*,<ctype2>*,<ctype2>*,<ctype2c>*,F_INT*,<ctype2c>*,F_INT*,<ctype2>*,<ctype2>*,<ctype2>*,<ctype2c>*,<ctype2>*,F_INT*,F_INT,F_INT,F_INT
 
     character optional,intent(in):: trans = "N"
     character optional,intent(in):: fact = "E"
@@ -163,13 +167,16 @@ subroutine <prefix2c>gesvx(fact,trans,n,nrhs,a,lda,af,ldaf,ipiv,equed,r,c,b,ldb,
     <ftype2> intent(hide,cache),dimension(2*n),depend(n) :: rwork
     integer intent(out):: info
 
+    integer intent(hide) :: len0 = 1
+    integer intent(hide) :: len1 = 1
+    integer intent(hide) :: len2 = 1
 end subroutine <prefix2c>gesvx
 
-subroutine <prefix>gecon(norm,n,a,lda,anorm,rcond,work,irwork,info)
+subroutine <prefix>gecon(norm,n,a,lda,anorm,rcond,work,irwork,info,len0)
    ! Computes the 1- or inf- norm reciprocal condition number estimate.
     threadsafe
-    callstatement (*f2py_func)(norm,&n,a,&lda,&anorm,&rcond,work,irwork,&info)
-    callprotoargument char*,F_INT*,<ctype>*,F_INT*,<ctypereal>*,<ctypereal>*,<ctype>*,<F_INT,F_INT,float,double>*,F_INT*
+    callstatement (*f2py_func)(norm,&n,a,&lda,&anorm,&rcond,work,irwork,&info,len0)
+    callprotoargument char*,F_INT*,<ctype>*,F_INT*,<ctypereal>*,<ctypereal>*,<ctype>*,<F_INT,F_INT,float,double>*,F_INT*,F_INT
 
     character optional,intent(in):: norm = '1'
     integer depend(a),intent(hide):: n = shape(a,0)
@@ -181,6 +188,7 @@ subroutine <prefix>gecon(norm,n,a,lda,anorm,rcond,work,irwork,info)
     <integer,integer,real, double precision> depend(n),dimension(<n,n,2*n,2*n>),intent(hide,cache):: irwork
     integer intent(out):: info
 
+    integer intent(hide) :: len0 = 1
 end subroutine <prefix>gecon
 
 subroutine <prefix>getrf(m,n,a,piv,info)
@@ -199,15 +207,15 @@ subroutine <prefix>getrf(m,n,a,piv,info)
 
 end subroutine <prefix>getrf
 
-subroutine <prefix>getrs(n,nrhs,lu,piv,b,info,trans)
+subroutine <prefix>getrs(n,nrhs,lu,piv,b,info,trans,len0)
     ! x,info = getrs(lu,piv,b,trans=0,overwrite_b=0)
     ! Solve  A  * X = B if trans=0
     ! Solve A^T * X = B if trans=1
     ! Solve A^H * X = B if trans=2
     ! A = P * L * U
     threadsafe
-    callstatement {F_INT i;for(i=0;i\<n;++piv[i++]);(*f2py_func)((trans?(trans==2?"C":"T"):"N"),&n,&nrhs,lu,&n,piv,b,&n,&info);for(i=0;i\<n;--piv[i++]);}
-    callprotoargument char*,F_INT*,F_INT*,<ctype>*,F_INT*,F_INT*,<ctype>*,F_INT*,F_INT*
+    callstatement {F_INT i;for(i=0;i\<n;++piv[i++]);(*f2py_func)((trans?(trans==2?"C":"T"):"N"),&n,&nrhs,lu,&n,piv,b,&n,&info,len0);for(i=0;i\<n;--piv[i++]);}
+    callprotoargument char*,F_INT*,F_INT*,<ctype>*,F_INT*,F_INT*,<ctype>*,F_INT*,F_INT*,F_INT
 
     integer optional,intent(in),check(trans>=0 && trans <=2) :: trans = 0
 
@@ -219,6 +227,7 @@ subroutine <prefix>getrs(n,nrhs,lu,piv,b,info,trans)
     <ftype> dimension(n,nrhs),intent(in,out,copy,out=x),depend(n),check(shape(lu,0)==shape(b,0)) :: b
     integer intent(out):: info
 
+    integer intent(hide) :: len0 = 1
 end subroutine <prefix>getrs
 
 subroutine <prefix>getc2(n,a,lda,ipiv,jpiv,info)
@@ -290,7 +299,7 @@ subroutine <prefix>getri_lwork(n,lu,piv,work,lwork,info)
     <ftype> intent(out) :: work
 end subroutine <prefix>getri_lwork
 
-subroutine <prefix2>gesdd(m,n,minmn,u0,u1,vt0,vt1,a,compute_uv,full_matrices,u,s,vt,work,lwork,iwork,info)
+subroutine <prefix2>gesdd(m,n,minmn,u0,u1,vt0,vt1,a,compute_uv,full_matrices,u,s,vt,work,lwork,iwork,info,len0)
     ! u,s,vt,info = gesdd(a,compute_uv=1,lwork=..,overwrite_a=0)
     ! Compute the singular value decomposition (SVD) using divide and conquer:
     !   A = U * SIGMA * transpose(V)
@@ -300,8 +309,8 @@ subroutine <prefix2>gesdd(m,n,minmn,u0,u1,vt0,vt1,a,compute_uv,full_matrices,u,s
     !               singular values
     ! transpose(V) - N x N matrix or N x min(M,N) if full_matrices=False
 
-    callstatement (*f2py_func)((compute_uv?(full_matrices?"A":"S"):"N"),&m,&n,a,&m,s,u,&u0,vt,&vt0,work,&lwork,iwork,&info)
-    callprotoargument char*,F_INT*,F_INT*,<ctype2>*,F_INT*,<ctype2>*,<ctype2>*,F_INT*,<ctype2>*,F_INT*,<ctype2>*,F_INT*,F_INT*,F_INT*
+    callstatement (*f2py_func)((compute_uv?(full_matrices?"A":"S"):"N"),&m,&n,a,&m,s,u,&u0,vt,&vt0,work,&lwork,iwork,&info,len0)
+    callprotoargument char*,F_INT*,F_INT*,<ctype2>*,F_INT*,<ctype2>*,<ctype2>*,F_INT*,<ctype2>*,F_INT*,<ctype2>*,F_INT*,F_INT*,F_INT*,F_INT
 
     integer intent(in),optional,check(compute_uv==0||compute_uv==1):: compute_uv = 1
     integer intent(in),optional,check(full_matrices==0||full_matrices==1):: full_matrices = 1
@@ -322,14 +331,15 @@ subroutine <prefix2>gesdd(m,n,minmn,u0,u1,vt0,vt1,a,compute_uv,full_matrices,u,s
     integer intent(hide,cache),dimension(8*minmn),depend(minmn) :: iwork
     integer intent(out)::info
 
+    integer intent(hide) :: len0 = 1
 end subroutine <prefix2>gesdd
 
-subroutine <prefix2>gesdd_lwork(m,n,minmn,u0,vt0,a,compute_uv,full_matrices,u,s,vt,work,lwork,iwork,info)
+subroutine <prefix2>gesdd_lwork(m,n,minmn,u0,vt0,a,compute_uv,full_matrices,u,s,vt,work,lwork,iwork,info,len0)
     ! LWORK computation for (S/D)GESDD
 
     fortranname <prefix2>gesdd
-    callstatement (*f2py_func)((compute_uv?(full_matrices?"A":"S"):"N"),&m,&n,&a,&m,&s,&u,&u0,&vt,&vt0,&work,&lwork,&iwork,&info)
-    callprotoargument char*,F_INT*,F_INT*,<ctype2>*,F_INT*,<ctype2>*,<ctype2>*,F_INT*,<ctype2>*,F_INT*,<ctype2>*,F_INT*,F_INT*,F_INT*
+    callstatement (*f2py_func)((compute_uv?(full_matrices?"A":"S"):"N"),&m,&n,&a,&m,&s,&u,&u0,&vt,&vt0,&work,&lwork,&iwork,&info,len0)
+    callprotoargument char*,F_INT*,F_INT*,<ctype2>*,F_INT*,<ctype2>*,<ctype2>*,F_INT*,<ctype2>*,F_INT*,<ctype2>*,F_INT*,F_INT*,F_INT*,F_INT
 
     integer intent(in),optional,check(compute_uv==0||compute_uv==1):: compute_uv = 1
     integer intent(in),optional,check(full_matrices==0||full_matrices==1):: full_matrices = 1
@@ -347,9 +357,10 @@ subroutine <prefix2>gesdd_lwork(m,n,minmn,u0,vt0,a,compute_uv,full_matrices,u,s,
     integer intent(hide) :: iwork
     integer intent(out) :: info
 
+    integer intent(hide) :: len0 = 1
 end subroutine <prefix2>gesdd_lwork
 
-subroutine <prefix2c>gesdd(m,n,minmn,u0,u1,vt0,vt1,a,compute_uv,full_matrices,u,s,vt,work,rwork,lwork,iwork,info)
+subroutine <prefix2c>gesdd(m,n,minmn,u0,u1,vt0,vt1,a,compute_uv,full_matrices,u,s,vt,work,rwork,lwork,iwork,info,len0)
     ! u,s,vt,info = gesdd(a,compute_uv=1,lwork=..,overwrite_a=0)
     ! Compute the singular value decomposition (SVD) using divide and conquer:
     !   A = U * SIGMA * conjugate-transpose(V)
@@ -359,8 +370,8 @@ subroutine <prefix2c>gesdd(m,n,minmn,u0,u1,vt0,vt1,a,compute_uv,full_matrices,u,
     !               singular values
     ! transpose(V) - N x N matrix or N x min(M,N) if full_matrices=False
 
-    callstatement (*f2py_func)((compute_uv?(full_matrices?"A":"S"):"N"),&m,&n,a,&m,s,u,&u0,vt,&vt0,work,&lwork,rwork,iwork,&info)
-    callprotoargument char*,F_INT*,F_INT*,<ctype2c>*,F_INT*,<ctype2>*,<ctype2c>*,F_INT*,<ctype2c>*,F_INT*,<ctype2c>*,F_INT*,<ctype2>*,F_INT*,F_INT*
+    callstatement (*f2py_func)((compute_uv?(full_matrices?"A":"S"):"N"),&m,&n,a,&m,s,u,&u0,vt,&vt0,work,&lwork,rwork,iwork,&info,len0)
+    callprotoargument char*,F_INT*,F_INT*,<ctype2c>*,F_INT*,<ctype2>*,<ctype2c>*,F_INT*,<ctype2c>*,F_INT*,<ctype2c>*,F_INT*,<ctype2>*,F_INT*,F_INT*,F_INT
 
     integer intent(in),optional,check(compute_uv==0||compute_uv==1):: compute_uv = 1
     integer intent(in),optional,check(full_matrices==0||full_matrices==1):: full_matrices = 1
@@ -382,14 +393,15 @@ subroutine <prefix2c>gesdd(m,n,minmn,u0,u1,vt0,vt1,a,compute_uv,full_matrices,u,
     integer intent(hide,cache),dimension(8*minmn),depend(minmn) :: iwork
     integer intent(out)::info
 
+    integer intent(hide) :: len0 = 1
 end subroutine <prefix2c>gesdd
 
-subroutine <prefix2c>gesdd_lwork(m,n,minmn,u0,vt0,a,compute_uv,full_matrices,u,s,vt,work,rwork,lwork,iwork,info)
+subroutine <prefix2c>gesdd_lwork(m,n,minmn,u0,vt0,a,compute_uv,full_matrices,u,s,vt,work,rwork,lwork,iwork,info,len0)
     ! (C/Z)GESDD call with LWORK=-1 -- copypaste of above gesdd with dummy arrays
 
     fortranname <prefix2c>gesdd
-    callstatement (*f2py_func)((compute_uv?(full_matrices?"A":"S"):"N"),&m,&n,&a,&m,&s,&u,&u0,&vt,&vt0,&work,&lwork,&rwork,&iwork,&info)
-    callprotoargument char*,F_INT*,F_INT*,<ctype2c>*,F_INT*,<ctype2>*,<ctype2c>*,F_INT*,<ctype2c>*,F_INT*,<ctype2c>*,F_INT*,<ctype2>*,F_INT*,F_INT*
+    callstatement (*f2py_func)((compute_uv?(full_matrices?"A":"S"):"N"),&m,&n,&a,&m,&s,&u,&u0,&vt,&vt0,&work,&lwork,&rwork,&iwork,&info,len0)
+    callprotoargument char*,F_INT*,F_INT*,<ctype2c>*,F_INT*,<ctype2>*,<ctype2c>*,F_INT*,<ctype2c>*,F_INT*,<ctype2c>*,F_INT*,<ctype2>*,F_INT*,F_INT*,F_INT
 
     integer intent(in),optional,check(compute_uv==0||compute_uv==1):: compute_uv = 1
     integer intent(in),optional,check(full_matrices==0||full_matrices==1):: full_matrices = 1
@@ -408,9 +420,10 @@ subroutine <prefix2c>gesdd_lwork(m,n,minmn,u0,vt0,a,compute_uv,full_matrices,u,s
     integer intent(hide) :: iwork
     integer intent(out) :: info
 
+    integer intent(hide) :: len0 = 1
 end subroutine <prefix2c>gesdd_lwork
 
-subroutine <prefix2>gesvd(m,n,minmn,u0,u1,vt0,vt1,a,compute_uv,full_matrices,u,s,vt,work,lwork,info)
+subroutine <prefix2>gesvd(m,n,minmn,u0,u1,vt0,vt1,a,compute_uv,full_matrices,u,s,vt,work,lwork,info,len0,len1)
     ! u,s,vt,info = gesvd(a,compute_uv=1,lwork=..,overwrite_a=0)
     ! Compute the singular value decomposition (SVD):
     !   A = U * SIGMA * transpose(V)
@@ -420,8 +433,8 @@ subroutine <prefix2>gesvd(m,n,minmn,u0,u1,vt0,vt1,a,compute_uv,full_matrices,u,s
     !               singular values
     ! transpose(V) - N x N matrix or N x min(M,N) if full_matrices=False
 
-    callstatement (*f2py_func)((compute_uv?(full_matrices?"A":"S"):"N"),(compute_uv?(full_matrices?"A":"S"):"N"),&m,&n,a,&m,s,u,&u0,vt,&vt0,work,&lwork,&info)
-    callprotoargument char*,char*,F_INT*,F_INT*,<ctype2>*,F_INT*,<ctype2>*,<ctype2>*,F_INT*,<ctype2>*,F_INT*,<ctype2>*,F_INT*,F_INT*
+    callstatement (*f2py_func)((compute_uv?(full_matrices?"A":"S"):"N"),(compute_uv?(full_matrices?"A":"S"):"N"),&m,&n,a,&m,s,u,&u0,vt,&vt0,work,&lwork,&info,len0,len1)
+    callprotoargument char*,char*,F_INT*,F_INT*,<ctype2>*,F_INT*,<ctype2>*,<ctype2>*,F_INT*,<ctype2>*,F_INT*,<ctype2>*,F_INT*,F_INT*,F_INT,F_INT
 
     integer intent(in),optional,check(compute_uv==0||compute_uv==1):: compute_uv = 1
     integer intent(in),optional,check(full_matrices==0||full_matrices==1):: full_matrices = 1
@@ -440,14 +453,16 @@ subroutine <prefix2>gesvd(m,n,minmn,u0,u1,vt0,vt1,a,compute_uv,full_matrices,u,s
     integer optional,intent(in),depend(minmn) :: lwork = max(MAX(3*minmn+MAX(m,n),5*minmn),1)
     integer intent(out) :: info
 
+    integer intent(hide) :: len0 = 1
+    integer intent(hide) :: len1 = 1
 end subroutine <prefix2>gesvd
 
-subroutine <prefix2>gesvd_lwork(m,n,minmn,u0,vt0,a,compute_uv,full_matrices,u,s,vt,work,lwork,info)
+subroutine <prefix2>gesvd_lwork(m,n,minmn,u0,vt0,a,compute_uv,full_matrices,u,s,vt,work,lwork,info,len0,len1)
     ! LWORK computation for (S/D)GESVD
 
     fortranname <prefix2>gesvd
-    callstatement (*f2py_func)((compute_uv?(full_matrices?"A":"S"):"N"),(compute_uv?(full_matrices?"A":"S"):"N"),&m,&n,&a,&m,&s,&u,&u0,&vt,&vt0,&work,&lwork,&info)
-    callprotoargument char*,char*,F_INT*,F_INT*,<ctype2>*,F_INT*,<ctype2>*,<ctype2>*,F_INT*,<ctype2>*,F_INT*,<ctype2>*,F_INT*,F_INT*
+    callstatement (*f2py_func)((compute_uv?(full_matrices?"A":"S"):"N"),(compute_uv?(full_matrices?"A":"S"):"N"),&m,&n,&a,&m,&s,&u,&u0,&vt,&vt0,&work,&lwork,&info,len0,len1)
+    callprotoargument char*,char*,F_INT*,F_INT*,<ctype2>*,F_INT*,<ctype2>*,<ctype2>*,F_INT*,<ctype2>*,F_INT*,<ctype2>*,F_INT*,F_INT*,F_INT,F_INT
 
     integer intent(in),optional,check(compute_uv==0||compute_uv==1):: compute_uv = 1
     integer intent(in),optional,check(full_matrices==0||full_matrices==1):: full_matrices = 1
@@ -464,9 +479,11 @@ subroutine <prefix2>gesvd_lwork(m,n,minmn,u0,vt0,a,compute_uv,full_matrices,u,s,
     <ftype2> intent(out) :: work
     integer intent(out) :: info
 
+    integer intent(hide) :: len0 = 1
+    integer intent(hide) :: len1 = 1
 end subroutine <prefix2>gesvd_lwork
 
-subroutine <prefix2c>gesvd(m,n,minmn,u0,u1,vt0,vt1,a,compute_uv,full_matrices,u,s,vt,work,rwork,lwork,info)
+subroutine <prefix2c>gesvd(m,n,minmn,u0,u1,vt0,vt1,a,compute_uv,full_matrices,u,s,vt,work,rwork,lwork,info,len0,len1)
     ! u,s,vt,info = gesvd(a,compute_uv=1,lwork=..,overwrite_a=0)
     ! Compute the singular value decomposition (SVD):
     !   A = U * SIGMA * conjugate-transpose(V)
@@ -476,8 +493,8 @@ subroutine <prefix2c>gesvd(m,n,minmn,u0,u1,vt0,vt1,a,compute_uv,full_matrices,u,
     !               singular values
     ! transpose(V) - N x N matrix or N x min(M,N) if full_matrices=False
 
-    callstatement (*f2py_func)((compute_uv?(full_matrices?"A":"S"):"N"),(compute_uv?(full_matrices?"A":"S"):"N"),&m,&n,a,&m,s,u,&u0,vt,&vt0,work,&lwork,rwork,&info)
-    callprotoargument char*,char*,F_INT*,F_INT*,<ctype2c>*,F_INT*,<ctype2>*,<ctype2c>*,F_INT*,<ctype2c>*,F_INT*,<ctype2c>*,F_INT*,<ctype2>*,F_INT*
+    callstatement (*f2py_func)((compute_uv?(full_matrices?"A":"S"):"N"),(compute_uv?(full_matrices?"A":"S"):"N"),&m,&n,a,&m,s,u,&u0,vt,&vt0,work,&lwork,rwork,&info,len0,len1)
+    callprotoargument char*,char*,F_INT*,F_INT*,<ctype2c>*,F_INT*,<ctype2>*,<ctype2c>*,F_INT*,<ctype2c>*,F_INT*,<ctype2c>*,F_INT*,<ctype2>*,F_INT*,F_INT,F_INT
 
     integer intent(in),optional,check(compute_uv==0||compute_uv==1):: compute_uv = 1
     integer intent(in),optional,check(full_matrices==0||full_matrices==1):: full_matrices = 1
@@ -497,14 +514,16 @@ subroutine <prefix2c>gesvd(m,n,minmn,u0,u1,vt0,vt1,a,compute_uv,full_matrices,u,
     integer optional,intent(in),depend(minmn) :: lwork = MAX(2*minmn+MAX(m,n),1)
     integer intent(out) :: info
 
+    integer intent(hide) :: len0 = 1
+    integer intent(hide) :: len1 = 1
 end subroutine <prefix2c>gesvd
 
-subroutine <prefix2c>gesvd_lwork(m,n,minmn,u0,vt0,a,compute_uv,full_matrices,u,s,vt,work,rwork,lwork,info)
+subroutine <prefix2c>gesvd_lwork(m,n,minmn,u0,vt0,a,compute_uv,full_matrices,u,s,vt,work,rwork,lwork,info,len0,len1)
     ! (C/Z)GESVD call with LWORK=-1 -- copypaste of above gesvd with dummy arrays
 
     fortranname <prefix2c>gesvd
-    callstatement (*f2py_func)((compute_uv?(full_matrices?"A":"S"):"N"),(compute_uv?(full_matrices?"A":"S"):"N"),&m,&n,&a,&m,&s,&u,&u0,&vt,&vt0,&work,&lwork,&rwork,&info)
-    callprotoargument char*,char*,F_INT*,F_INT*,<ctype2c>*,F_INT*,<ctype2>*,<ctype2c>*,F_INT*,<ctype2c>*,F_INT*,<ctype2c>*,F_INT*,<ctype2>*,F_INT*
+    callstatement (*f2py_func)((compute_uv?(full_matrices?"A":"S"):"N"),(compute_uv?(full_matrices?"A":"S"):"N"),&m,&n,&a,&m,&s,&u,&u0,&vt,&vt0,&work,&lwork,&rwork,&info,len0,len1)
+    callprotoargument char*,char*,F_INT*,F_INT*,<ctype2c>*,F_INT*,<ctype2>*,<ctype2c>*,F_INT*,<ctype2c>*,F_INT*,<ctype2c>*,F_INT*,<ctype2>*,F_INT*,F_INT,F_INT
 
     integer intent(in),optional,check(compute_uv==0||compute_uv==1):: compute_uv = 1
     integer intent(in),optional,check(full_matrices==0||full_matrices==1):: full_matrices = 1
@@ -522,14 +541,16 @@ subroutine <prefix2c>gesvd_lwork(m,n,minmn,u0,vt0,a,compute_uv,full_matrices,u,s
     <ftype2> intent(hide) :: rwork
     integer intent(out) :: info
 
+    integer intent(hide) :: len0 = 1
+    integer intent(hide) :: len1 = 1
 end subroutine <prefix2c>gesvd_lwork
 
-subroutine <prefix>gels(trans,m,n,nrhs,a,lda,b,ldb,work,lwork,info)
+subroutine <prefix>gels(trans,m,n,nrhs,a,lda,b,ldb,work,lwork,info,len0)
     ! lqr,x,info = gels(a,b,lwork=..,overwrite_a=False,overwrite_b=False)
     ! Solve Minimize 2-norm(A * X - B).
 
-    callstatement (*f2py_func)(trans,&m,&n,&nrhs,a,&lda,b,&ldb,work,&lwork,&info)
-    callprotoargument char*,F_INT*,F_INT*,F_INT*,<ctype>*,F_INT*,<ctype>*,F_INT*,<ctype>*,F_INT*,F_INT*
+    callstatement (*f2py_func)(trans,&m,&n,&nrhs,a,&lda,b,&ldb,work,&lwork,&info,len0)
+    callprotoargument char*,F_INT*,F_INT*,F_INT*,<ctype>*,F_INT*,<ctype>*,F_INT*,<ctype>*,F_INT*,F_INT*,F_INT
 
     character optional,intent(in),check(*trans=='N'||*trans==<'T',\0,'C',\2>):: trans = 'N'
     integer intent(hide),depend(a):: m = shape(a,0)
@@ -543,14 +564,15 @@ subroutine <prefix>gels(trans,m,n,nrhs,a,lda,b,ldb,work,lwork,info)
     <ftype> depend(lwork),dimension(MAX(1,lwork)),intent(hide,cache):: work
     integer intent(out)::info
 
+    integer intent(hide) :: len0 = 1
 end subroutine <prefix>gels
 
-subroutine <prefix>gels_lwork(trans,m,n,nrhs,a,lda,b,ldb,work,lwork,info)
+subroutine <prefix>gels_lwork(trans,m,n,nrhs,a,lda,b,ldb,work,lwork,info,len0)
     ! ?GELS LWORK Query for optimal block size
 
     fortranname <prefix>gels
-    callstatement (*f2py_func)(trans,&m,&n,&nrhs,&a,&lda,&b,&ldb,&work,&lwork,&info)
-    callprotoargument char*,F_INT*,F_INT*,F_INT*,<ctype>*,F_INT*,<ctype>*,F_INT*,<ctype>*,F_INT*,F_INT*
+    callstatement (*f2py_func)(trans,&m,&n,&nrhs,&a,&lda,&b,&ldb,&work,&lwork,&info,len0)
+    callprotoargument char*,F_INT*,F_INT*,F_INT*,<ctype>*,F_INT*,<ctype>*,F_INT*,<ctype>*,F_INT*,F_INT*,F_INT
 
     character optional,intent(in),check(*trans=='N'||*trans==<'T',\0,'C',\2>):: trans = 'N'
     integer intent(in),check(m>=0) :: m
@@ -566,6 +588,7 @@ subroutine <prefix>gels_lwork(trans,m,n,nrhs,a,lda,b,ldb,work,lwork,info)
     <ftype> intent(out):: work
     integer intent(out)::info
 
+    integer intent(hide) :: len0 = 1
 end subroutine <prefix>gels_lwork
 
 subroutine <prefix2>gelss(m,n,minmn,maxmn,nrhs,a,b,s,cond,r,work,lwork,info)
@@ -1062,11 +1085,11 @@ subroutine <prefix>gerqf(m,n,a,tau,work,lwork,info)
 
 end subroutine <prefix>gerqf
 
-subroutine <prefix2>geev(compute_vl,compute_vr,n,a,wr,wi,vl,ldvl,vr,ldvr,work,lwork,info)
+subroutine <prefix2>geev(compute_vl,compute_vr,n,a,wr,wi,vl,ldvl,vr,ldvr,work,lwork,info,len0,len1)
     ! wr,wi,vl,vr,info = geev(a,compute_vl=1,compute_vr=1,lwork=4*n,overwrite_a=0)
 
-    callstatement {(*f2py_func)((compute_vl?"V":"N"),(compute_vr?"V":"N"),&n,a,&n,wr,wi,vl,&ldvl,vr,&ldvr,work,&lwork,&info);}
-    callprotoargument char*,char*,F_INT*,<ctype2>*,F_INT*,<ctype2>*,<ctype2>*,<ctype2>*,F_INT*,<ctype2>*,F_INT*,<ctype2>*,F_INT*,F_INT*
+    callstatement {(*f2py_func)((compute_vl?"V":"N"),(compute_vr?"V":"N"),&n,a,&n,wr,wi,vl,&ldvl,vr,&ldvr,work,&lwork,&info,len0,len1);}
+    callprotoargument char*,char*,F_INT*,<ctype2>*,F_INT*,<ctype2>*,<ctype2>*,<ctype2>*,F_INT*,<ctype2>*,F_INT*,<ctype2>*,F_INT*,F_INT*,F_INT,F_INT
 
     integer optional,intent(in):: compute_vl = 1
     check(compute_vl==1||compute_vl==0) compute_vl
@@ -1092,14 +1115,16 @@ subroutine <prefix2>geev(compute_vl,compute_vr,n,a,wr,wi,vl,ldvl,vr,ldvr,work,lw
 
     integer intent(out):: info
 
+    integer intent(hide) :: len0 = 1
+    integer intent(hide) :: len1 = 1
 end subroutine <prefix2>geev
 
-subroutine <prefix2>geev_lwork(compute_vl,compute_vr,n,a,wr,wi,vl,ldvl,vr,ldvr,work,lwork,info)
+subroutine <prefix2>geev_lwork(compute_vl,compute_vr,n,a,wr,wi,vl,ldvl,vr,ldvr,work,lwork,info,len0,len1)
     ! LWORK=-1 call for (S/D)GEEV --- keep in sync with above (S/D)GEEV definition
 
     fortranname <prefix2>geev
-    callstatement {(*f2py_func)((compute_vl?"V":"N"),(compute_vr?"V":"N"),&n,&a,&n,&wr,&wi,&vl,&ldvl,&vr,&ldvr,&work,&lwork,&info);}
-    callprotoargument char*,char*,F_INT*,<ctype2>*,F_INT*,<ctype2>*,<ctype2>*,<ctype2>*,F_INT*,<ctype2>*,F_INT*,<ctype2>*,F_INT*,F_INT*
+    callstatement {(*f2py_func)((compute_vl?"V":"N"),(compute_vr?"V":"N"),&n,&a,&n,&wr,&wi,&vl,&ldvl,&vr,&ldvr,&work,&lwork,&info,len0,len1);}
+    callprotoargument char*,char*,F_INT*,<ctype2>*,F_INT*,<ctype2>*,<ctype2>*,<ctype2>*,F_INT*,<ctype2>*,F_INT*,<ctype2>*,F_INT*,F_INT*,F_INT,F_INT
 
     integer optional,intent(in):: compute_vl = 1
     check(compute_vl==1||compute_vl==0) compute_vl
@@ -1123,13 +1148,15 @@ subroutine <prefix2>geev_lwork(compute_vl,compute_vr,n,a,wr,wi,vl,ldvl,vr,ldvr,w
 
     integer intent(out):: info
 
+    integer intent(hide) :: len0 = 1
+    integer intent(hide) :: len1 = 1
 end subroutine <prefix2>geev_lwork
 
-subroutine <prefix2c>geev(compute_vl,compute_vr,n,a,w,vl,ldvl,vr,ldvr,work,lwork,rwork,info)
+subroutine <prefix2c>geev(compute_vl,compute_vr,n,a,w,vl,ldvl,vr,ldvr,work,lwork,rwork,info,len0,len1)
     ! w,vl,vr,info = geev(a,compute_vl=1,compute_vr=1,lwork=2*n,overwrite_a=0)
 
-    callstatement (*f2py_func)((compute_vl?"V":"N"),(compute_vr?"V":"N"),&n,a,&n,w,vl,&ldvl,vr,&ldvr,work,&lwork,rwork,&info)
-    callprotoargument char*,char*,F_INT*,<ctype2c>*,F_INT*,<ctype2c>*,<ctype2c>*,F_INT*,<ctype2c>*,F_INT*,<ctype2c>*,F_INT*,<ctype2>*,F_INT*
+    callstatement (*f2py_func)((compute_vl?"V":"N"),(compute_vr?"V":"N"),&n,a,&n,w,vl,&ldvl,vr,&ldvr,work,&lwork,rwork,&info,len0,len1)
+    callprotoargument char*,char*,F_INT*,<ctype2c>*,F_INT*,<ctype2c>*,<ctype2c>*,F_INT*,<ctype2c>*,F_INT*,<ctype2c>*,F_INT*,<ctype2>*,F_INT*,F_INT,F_INT
 
     integer optional,intent(in):: compute_vl = 1
     check(compute_vl==1||compute_vl==0) compute_vl
@@ -1155,14 +1182,16 @@ subroutine <prefix2c>geev(compute_vl,compute_vr,n,a,w,vl,ldvl,vr,ldvr,work,lwork
 
     integer intent(out):: info
 
+    integer intent(hide) :: len0 = 1
+    integer intent(hide) :: len1 = 1
 end subroutine <prefix2c>geev
 
-subroutine <prefix2c>geev_lwork(compute_vl,compute_vr,n,a,w,vl,ldvl,vr,ldvr,work,lwork,rwork,info)
+subroutine <prefix2c>geev_lwork(compute_vl,compute_vr,n,a,w,vl,ldvl,vr,ldvr,work,lwork,rwork,info,len0,len1)
     ! LWORK=-1 call for (C/Z)GEEV --- keep in sync with above (C/Z)GEEV definition
 
     fortranname <prefix2c>geev
-    callstatement (*f2py_func)((compute_vl?"V":"N"),(compute_vr?"V":"N"),&n,&a,&n,&w,&vl,&ldvl,&vr,&ldvr,&work,&lwork,&rwork,&info)
-    callprotoargument char*,char*,F_INT*,<ctype2c>*,F_INT*,<ctype2c>*,<ctype2c>*,F_INT*,<ctype2c>*,F_INT*,<ctype2c>*,F_INT*,<ctype2>*,F_INT*
+    callstatement (*f2py_func)((compute_vl?"V":"N"),(compute_vr?"V":"N"),&n,&a,&n,&w,&vl,&ldvl,&vr,&ldvr,&work,&lwork,&rwork,&info,len0,len1)
+    callprotoargument char*,char*,F_INT*,<ctype2c>*,F_INT*,<ctype2c>*,<ctype2c>*,F_INT*,<ctype2c>*,F_INT*,<ctype2c>*,F_INT*,<ctype2>*,F_INT*,F_INT,F_INT
 
     integer optional,intent(in):: compute_vl = 1
     check(compute_vl==1||compute_vl==0) compute_vl
@@ -1186,18 +1215,20 @@ subroutine <prefix2c>geev_lwork(compute_vl,compute_vr,n,a,w,vl,ldvl,vr,ldvr,work
 
     integer intent(out):: info
 
+    integer intent(hide) :: len0 = 1
+    integer intent(hide) :: len1 = 1
 end subroutine <prefix2c>geev_lwork
 
 
-subroutine <prefix2c>gees(compute_v,sort_t,<prefix2c>select,n,a,nrows,sdim,w,vs,ldvs,work,lwork,rwork,bwork,info)
+subroutine <prefix2c>gees(compute_v,sort_t,<prefix2c>select,n,a,nrows,sdim,w,vs,ldvs,work,lwork,rwork,bwork,info,len0,len1)
     ! t,sdim,w,vs,work,info=gees(compute_v=1,sort_t=0,select,a,lwork=3*n)
     ! For an NxN matrix compute the eigenvalues, the schur form T, and optionally
     !  the matrix of Schur vectors Z.  This gives the Schur factorization
     !  A = Z * T * Z^H  -- a complex matrix is in Schur form if it is upper
     !  triangular
 
-    callstatement (*f2py_func)((compute_v?"V":"N"),(sort_t?"S":"N"),cb_<prefix2c>select_in_gees__user__routines,&n,a,&nrows,&sdim,w,vs,&ldvs,work,&lwork,rwork,bwork,&info,1,1)
-    callprotoargument char*,char*,F_INT(*)(<ctype2c>*),F_INT*,<ctype2c>*,F_INT*,F_INT*,<ctype2c>*,<ctype2c>*,F_INT*,<ctype2c>*,F_INT*,<ctype2>*,F_INT*,F_INT*,F_INT,F_INT
+    callstatement (*f2py_func)((compute_v?"V":"N"),(sort_t?"S":"N"),cb_<prefix2c>select_in_gees__user__routines,&n,a,&nrows,&sdim,w,vs,&ldvs,work,&lwork,rwork,bwork,&info,len0,len1,1,1)
+    callprotoargument char*,char*,F_INT(*)(<ctype2c>*),F_INT*,<ctype2c>*,F_INT*,F_INT*,<ctype2c>*,<ctype2c>*,F_INT*,<ctype2c>*,F_INT*,<ctype2>*,F_INT*,F_INT*,F_INT,F_INT,F_INT,F_INT
 
     use gees__user__routines
 
@@ -1217,17 +1248,19 @@ subroutine <prefix2c>gees(compute_v,sort_t,<prefix2c>select,n,a,nrows,sdim,w,vs,
     logical optional,intent(hide),depend(n),dimension(n) :: bwork
     integer intent(out) :: info
 
+    integer intent(hide) :: len0 = 1
+    integer intent(hide) :: len1 = 1
 end subroutine <prefix2c>gees
 
-subroutine <prefix2>gees(compute_v,sort_t,<prefix2>select,n,a,nrows,sdim,wr,wi,vs,ldvs,work,lwork,bwork,info)
+subroutine <prefix2>gees(compute_v,sort_t,<prefix2>select,n,a,nrows,sdim,wr,wi,vs,ldvs,work,lwork,bwork,info,len0,len1)
     ! t,sdim,w,vs,work,info=gees(compute_v=1,sort_t=0,select,a,lwork=3*n)
     ! For an NxN matrix compute the eigenvalues, the schur form T, and optionally
     !  the matrix of Schur vectors Z.  This gives the Schur factorization
     !  A = Z * T * Z^H  -- a real matrix is in Schur form if it is upper quasi-
     !  triangular with 1x1 and 2x2 blocks.
 
-    callstatement (*f2py_func)((compute_v?"V":"N"),(sort_t?"S":"N"),cb_<prefix2>select_in_gees__user__routines,&n,a,&nrows,&sdim,wr,wi,vs,&ldvs,work,&lwork,bwork,&info,1,1)
-    callprotoargument char*,char*,F_INT(*)(<ctype2>*,<ctype2>*),F_INT*,<ctype2>*,F_INT*,F_INT*,<ctype2>*,<ctype2>*,<ctype2>*,F_INT*,<ctype2>*,F_INT*,F_INT*,F_INT*,F_INT,F_INT
+    callstatement (*f2py_func)((compute_v?"V":"N"),(sort_t?"S":"N"),cb_<prefix2>select_in_gees__user__routines,&n,a,&nrows,&sdim,wr,wi,vs,&ldvs,work,&lwork,bwork,&info,len0,len1,1,1)
+    callprotoargument char*,char*,F_INT(*)(<ctype2>*,<ctype2>*),F_INT*,<ctype2>*,F_INT*,F_INT*,<ctype2>*,<ctype2>*,<ctype2>*,F_INT*,<ctype2>*,F_INT*,F_INT*,F_INT*,F_INT,F_INT,F_INT,F_INT
 
     use gees__user__routines
 
@@ -1248,17 +1281,19 @@ subroutine <prefix2>gees(compute_v,sort_t,<prefix2>select,n,a,nrows,sdim,wr,wi,v
     logical optional,intent(hide),depend(n),dimension(n) :: bwork
     integer intent(out) :: info
 
+    integer intent(hide) :: len0 = 1
+    integer intent(hide) :: len1 = 1
 end subroutine <prefix2>gees
 
-subroutine <prefix2>gges(jobvsl,jobvsr,sort_t,<prefix2>select,n,a,lda,b,ldb,sdim,alphar,alphai,beta,vsl,ldvsl,vsr,ldvsr,work,lwork,bwork,info)
+subroutine <prefix2>gges(jobvsl,jobvsr,sort_t,<prefix2>select,n,a,lda,b,ldb,sdim,alphar,alphai,beta,vsl,ldvsl,vsr,ldvsr,work,lwork,bwork,info,len0,len1,len2)
     ! For a pair of N-by-N real nonsymmetric matrices (A,B) computes
     ! the generalized eigenvalues, the generalized real Schur form (S,T),
     ! optionally, the left and/or right matrices of Schur vectors (VSL
     ! and VSR).
     ! (A,B) = ( (VSL)*S*(VSR)**T, (VSL)*T*(VSR)**T )
 
-    callstatement (*f2py_func)((jobvsl?"V":"N"),(jobvsr?"V":"N"),(sort_t?"S":"N"),cb_<prefix2>select_in_gges__user__routines,&n,a,&lda,b,&ldb,&sdim,alphar,alphai,beta,vsl,&ldvsl,vsr,&ldvsr,work,&lwork,bwork,&info)
-    callprotoargument char*,char*,char*,F_INT(*)(<ctype2>*,<ctype2>*,<ctype2>*),F_INT*,<ctype2>*,F_INT*,<ctype2>*,F_INT*,F_INT*,<ctype2>*,<ctype2>*,<ctype2>*,<ctype2>*,F_INT*,<ctype2>*,F_INT*,<ctype2>*,F_INT*,F_INT*,F_INT*
+    callstatement (*f2py_func)((jobvsl?"V":"N"),(jobvsr?"V":"N"),(sort_t?"S":"N"),cb_<prefix2>select_in_gges__user__routines,&n,a,&lda,b,&ldb,&sdim,alphar,alphai,beta,vsl,&ldvsl,vsr,&ldvsr,work,&lwork,bwork,&info,len0,len1,len2)
+    callprotoargument char*,char*,char*,F_INT(*)(<ctype2>*,<ctype2>*,<ctype2>*),F_INT*,<ctype2>*,F_INT*,<ctype2>*,F_INT*,F_INT*,<ctype2>*,<ctype2>*,<ctype2>*,<ctype2>*,F_INT*,<ctype2>*,F_INT*,<ctype2>*,F_INT*,F_INT*,F_INT*,F_INT,F_INT,F_INT
 
     use gges__user__routines
 
@@ -1284,17 +1319,20 @@ subroutine <prefix2>gges(jobvsl,jobvsr,sort_t,<prefix2>select,n,a,lda,b,ldb,sdim
     logical optional,intent(hide),depend(n),dimension(n) :: bwork
     integer intent(out):: info
 
+    integer intent(hide) :: len0 = 1
+    integer intent(hide) :: len1 = 1
+    integer intent(hide) :: len2 = 1
 end subroutine <prefix2>gges
 
-subroutine <prefix2c>gges(jobvsl,jobvsr,sort_t,<prefix2c>select,n,a,lda,b,ldb,sdim,alpha,beta,vsl,ldvsl,vsr,ldvsr,work,lwork,rwork,bwork,info)
+subroutine <prefix2c>gges(jobvsl,jobvsr,sort_t,<prefix2c>select,n,a,lda,b,ldb,sdim,alpha,beta,vsl,ldvsl,vsr,ldvsr,work,lwork,rwork,bwork,info,len0,len1,len2)
     ! For a pair of N-by-N complex nonsymmetric matrices (A,B) computes
     ! the generalized eigenvalues, the generalized real Schur form (S,T),
     ! optionally, the left and/or right matrices of Schur vectors (VSL
     ! and VSR).
     ! (A,B) = ( (VSL)*S*(VSR)**T, (VSL)*T*(VSR)**H )
 
-    callstatement (*f2py_func)((jobvsl?"V":"N"),(jobvsr?"V":"N"),(sort_t?"S":"N"),cb_<prefix2c>select_in_gges__user__routines,&n,a,&lda,b,&ldb,&sdim,alpha,beta,vsl,&ldvsl,vsr,&ldvsr,work,&lwork,rwork,bwork,&info)
-    callprotoargument char*,char*,char*,F_INT(*)(<ctype2c>*,<ctype2c>*),F_INT*,<ctype2c>*,F_INT*,<ctype2c>*,F_INT*,F_INT*,<ctype2c>*,<ctype2c>*,<ctype2c>*,F_INT*,<ctype2c>*,F_INT*,<ctype2c>*,F_INT*,<ctype2>*,F_INT*,F_INT*
+    callstatement (*f2py_func)((jobvsl?"V":"N"),(jobvsr?"V":"N"),(sort_t?"S":"N"),cb_<prefix2c>select_in_gges__user__routines,&n,a,&lda,b,&ldb,&sdim,alpha,beta,vsl,&ldvsl,vsr,&ldvsr,work,&lwork,rwork,bwork,&info,len0,len1,len2)
+    callprotoargument char*,char*,char*,F_INT(*)(<ctype2c>*,<ctype2c>*),F_INT*,<ctype2c>*,F_INT*,<ctype2c>*,F_INT*,F_INT*,<ctype2c>*,<ctype2c>*,<ctype2c>*,F_INT*,<ctype2c>*,F_INT*,<ctype2c>*,F_INT*,<ctype2>*,F_INT*,F_INT*,F_INT,F_INT,F_INT
 
     use gges__user__routines
 
@@ -1320,12 +1358,15 @@ subroutine <prefix2c>gges(jobvsl,jobvsr,sort_t,<prefix2c>select,n,a,lda,b,ldb,sd
     logical optional,intent(hide),depend(n),dimension(n) :: bwork
     integer intent(out):: info
 
+    integer intent(hide) :: len0 = 1
+    integer intent(hide) :: len1 = 1
+    integer intent(hide) :: len2 = 1
 end subroutine <prefix2c>gges
 
-subroutine <prefix2>ggev(compute_vl,compute_vr,n,a,b,alphar,alphai,beta,vl,ldvl,vr,ldvr,work,lwork,info)
+subroutine <prefix2>ggev(compute_vl,compute_vr,n,a,b,alphar,alphai,beta,vl,ldvl,vr,ldvr,work,lwork,info,len0,len1)
 
-    callstatement {(*f2py_func)((compute_vl?"V":"N"),(compute_vr?"V":"N"),&n,a,&n,b,&n,alphar,alphai,beta,vl,&ldvl,vr,&ldvr,work,&lwork,&info);}
-    callprotoargument char*,char*,F_INT*,<ctype2>*,F_INT*,<ctype2>*,F_INT*,<ctype2>*,<ctype2>*,<ctype2>*,<ctype2>*,F_INT*,<ctype2>*,F_INT*,<ctype2>*,F_INT*,F_INT*
+    callstatement {(*f2py_func)((compute_vl?"V":"N"),(compute_vr?"V":"N"),&n,a,&n,b,&n,alphar,alphai,beta,vl,&ldvl,vr,&ldvr,work,&lwork,&info,len0,len1);}
+    callprotoargument char*,char*,F_INT*,<ctype2>*,F_INT*,<ctype2>*,F_INT*,<ctype2>*,<ctype2>*,<ctype2>*,<ctype2>*,F_INT*,<ctype2>*,F_INT*,<ctype2>*,F_INT*,F_INT*,F_INT,F_INT
 
     integer optional,intent(in):: compute_vl = 1
     check(compute_vl==1||compute_vl==0) compute_vl
@@ -1355,12 +1396,14 @@ subroutine <prefix2>ggev(compute_vl,compute_vr,n,a,b,alphar,alphai,beta,vl,ldvl,
 
     integer intent(out):: info
 
+    integer intent(hide) :: len0 = 1
+    integer intent(hide) :: len1 = 1
 end subroutine <prefix2>ggev
 
-subroutine <prefix2c>ggev(compute_vl,compute_vr,n,a,b,alpha,beta,vl,ldvl,vr,ldvr,work,lwork,rwork,info)
+subroutine <prefix2c>ggev(compute_vl,compute_vr,n,a,b,alpha,beta,vl,ldvl,vr,ldvr,work,lwork,rwork,info,len0,len1)
 
-    callstatement {(*f2py_func)((compute_vl?"V":"N"),(compute_vr?"V":"N"),&n,a,&n,b,&n,alpha,beta,vl,&ldvl,vr,&ldvr,work,&lwork,rwork,&info);}
-    callprotoargument char*,char*,F_INT*,<ctype2c>*,F_INT*,<ctype2c>*,F_INT*,<ctype2c>*,<ctype2c>*,<ctype2c>*,F_INT*,<ctype2c>*,F_INT*,<ctype2c>*,F_INT*,<ctype2>*,F_INT*
+    callstatement {(*f2py_func)((compute_vl?"V":"N"),(compute_vr?"V":"N"),&n,a,&n,b,&n,alpha,beta,vl,&ldvl,vr,&ldvr,work,&lwork,rwork,&info,len0,len1);}
+    callprotoargument char*,char*,F_INT*,<ctype2c>*,F_INT*,<ctype2c>*,F_INT*,<ctype2c>*,<ctype2c>*,<ctype2c>*,F_INT*,<ctype2c>*,F_INT*,<ctype2c>*,F_INT*,<ctype2>*,F_INT*,F_INT,F_INT
 
     integer optional,intent(in):: compute_vl = 1
     check(compute_vl==1||compute_vl==0) compute_vl
@@ -1390,6 +1433,8 @@ subroutine <prefix2c>ggev(compute_vl,compute_vr,n,a,b,alpha,beta,vl,ldvl,vr,ldvr
 
     integer intent(out):: info
 
+    integer intent(hide) :: len0 = 1
+    integer intent(hide) :: len1 = 1
 end subroutine <prefix2>ggev
 
 subroutine <prefix>geequ(m,n,a,lda,r,c,rowcnd,colcnd,amax,info)
diff --git a/scipy/linalg/flapack_gen_banded.pyf.src b/scipy/linalg/flapack_gen_banded.pyf.src
index e09a0edd98..94c651a11c 100644
--- a/scipy/linalg/flapack_gen_banded.pyf.src
+++ b/scipy/linalg/flapack_gen_banded.pyf.src
@@ -47,7 +47,7 @@ subroutine <prefix>gbtrf(m,n,ab,kl,ku,ldab,ipiv,info)
 
 end subroutine <prefix>gbtrf
 
-subroutine <prefix>gbtrs(ab,kl,ku,b,ipiv,trans,n,nrhs,ldab,ldb,info) ! in :Band:dgbtrs.f
+subroutine <prefix>gbtrs(ab,kl,ku,b,ipiv,trans,n,nrhs,ldab,ldb,info,len0) ! in :Band:dgbtrs.f
     ! x,info = dgbtrs(ab,kl,ku,b,ipiv,[trans,n,ldab,ldb,overwrite_b])
     ! solve a system of linear equations A * X = B or A' * X = B
     ! with a general band matrix A using the  LU  factorization
@@ -58,8 +58,8 @@ subroutine <prefix>gbtrs(ab,kl,ku,b,ipiv,trans,n,nrhs,ldab,ldb,info) ! in :Band:
     !  1  = 'T':  A'* X = B  (Transpose)
     !  2  = 'C':  A'* X = B  (Conjugate transpose = Transpose)
     
-    callstatement {F_INT i;for(i=0;i\<n;++ipiv[i++]);(*f2py_func)((trans>0?(trans==1?"T":"C"):"N"),&n,&kl,&ku,&nrhs,ab,&ldab,ipiv,b,&ldb,&info);for(i=0;i\<n;--ipiv[i++]);}
-    callprotoargument char*,F_INT*,F_INT *,F_INT*,F_INT*,<ctype>*,F_INT*,F_INT*,<ctype>*,F_INT*,F_INT*
+    callstatement {F_INT i;for(i=0;i\<n;++ipiv[i++]);(*f2py_func)((trans>0?(trans==1?"T":"C"):"N"),&n,&kl,&ku,&nrhs,ab,&ldab,ipiv,b,&ldb,&info,len0);for(i=0;i\<n;--ipiv[i++]);}
+    callprotoargument char*,F_INT*,F_INT *,F_INT*,F_INT*,<ctype>*,F_INT*,F_INT*,<ctype>*,F_INT*,F_INT*,F_INT
     !character optional:: trans='N'
     integer optional:: trans=0
     integer optional,depend(ab) :: n=shape(ab,1)
@@ -76,4 +76,5 @@ subroutine <prefix>gbtrs(ab,kl,ku,b,ipiv,trans,n,nrhs,ldab,ldb,info) ! in :Band:
     !integer optional,check(shape(b,0)==ldb),depend(b) :: ldb=shape(b,0)
     integer intent(out):: info
 
+    integer intent(hide) :: len0 = 1
 end subroutine <prefix>gbtrs
diff --git a/scipy/linalg/flapack_gen_tri.pyf.src b/scipy/linalg/flapack_gen_tri.pyf.src
index d4e66a9480..674c35aaf7 100644
--- a/scipy/linalg/flapack_gen_tri.pyf.src
+++ b/scipy/linalg/flapack_gen_tri.pyf.src
@@ -40,15 +40,15 @@ subroutine <prefix>gttrf(n, dl, d, du, du2, ipiv, info)
 end subroutine <prefix>gttrf
 
 
-subroutine <prefix>gttrs(trans, n, nrhs, dl, d, du, du2, ipiv, b, ldb, info)
+subroutine <prefix>gttrs(trans, n, nrhs, dl, d, du, du2, ipiv, b, ldb, info,len0)
     ! x, info  = gttrs(dl, d, du, du2, ipiv, b, trans="N", overwrite_b=0)
     !
     ! ?GTTRS solves one of the systems of equations:
     ! A*X = B  or  A**T*X = B,
     ! with a tridiagonal matrix A using the LU factorization computed
     ! by ?GTTRF.
-    callstatement (*f2py_func)(trans, &n, &nrhs, dl, d, du, du2, ipiv, b, &ldb, &info)
-    callprotoargument char*, F_INT*, F_INT*, <ctype>*, <ctype>*, <ctype>*, <ctype>*, F_INT*, <ctype>*, F_INT*, F_INT*
+    callstatement (*f2py_func)(trans, &n, &nrhs, dl, d, du, du2, ipiv, b, &ldb, &info,len0)
+    callprotoargument char*, F_INT*, F_INT*, <ctype>*, <ctype>*, <ctype>*, <ctype>*, F_INT*, <ctype>*, F_INT*, F_INT*,F_INT
     threadsafe
 
     character optional, intent(in), check(*trans=='N'||*trans=='T'||*trans=='C') :: trans = "N"
@@ -63,18 +63,19 @@ subroutine <prefix>gttrs(trans, n, nrhs, dl, d, du, du2, ipiv, b, ldb, info)
     <ftype> intent(in, out, copy, out=x), dimension(ldb, nrhs) :: b
     integer intent(out) :: info
 
+    integer intent(hide) :: len0 = 1
 end subroutine gttrs
 
 
-subroutine <prefix2>gtcon(norm,n,dl,d,du,du2,ipiv,anorm,rcond,work,iwork,info)
+subroutine <prefix2>gtcon(norm,n,dl,d,du,du2,ipiv,anorm,rcond,work,iwork,info,len0)
     ! ?GTCON estimates the reciprocal of the condition number of a real
     ! tridiagonal matrix A using the LU factorization as computed by
     ! ?GTTRF.
     ! An estimate is obtained for norm(inv(A)), and the reciprocal of the
     ! condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).
     threadsafe
-    callstatement (*f2py_func)(norm,&n,dl,d,du,du2,ipiv,&anorm,&rcond,work,iwork,&info)
-    callprotoargument char*, F_INT*, <ctype2>*, <ctype2>*, <ctype2>*, <ctype2>*, F_INT*, <ctype2>*, <ctype2>*, <ctype2>*, F_INT*, F_INT*
+    callstatement (*f2py_func)(norm,&n,dl,d,du,du2,ipiv,&anorm,&rcond,work,iwork,&info,len0)
+    callprotoargument char*, F_INT*, <ctype2>*, <ctype2>*, <ctype2>*, <ctype2>*, F_INT*, <ctype2>*, <ctype2>*, <ctype2>*, F_INT*, F_INT*,F_INT
 
     character optional, intent(in) :: norm = '1'
     integer intent(hide), depend(d) :: n = max(3, len(d))
@@ -89,18 +90,19 @@ subroutine <prefix2>gtcon(norm,n,dl,d,du,du2,ipiv,anorm,rcond,work,iwork,info)
     integer intent(hide, cache), dimension(n), depend(n) :: iwork
     integer intent(out) :: info
 
+    integer intent(hide) :: len0 = 1
 end subroutine <prefix2>gtcon
 
 
-subroutine <prefix2c>gtcon(norm,n,dl,d,du,du2,ipiv,anorm,rcond,work,info)
+subroutine <prefix2c>gtcon(norm,n,dl,d,du,du2,ipiv,anorm,rcond,work,info,len0)
     ! ?GTCON estimates the reciprocal of the condition number of a real
     ! tridiagonal matrix A using the LU factorization as computed by
     ! ?GTTRF.
     ! An estimate is obtained for norm(inv(A)), and the reciprocal of the
     ! condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).
     threadsafe
-    callstatement (*f2py_func)(norm,&n,dl,d,du,du2,ipiv,&anorm,&rcond,work,&info)
-    callprotoargument char*, F_INT*, <ctype2c>*, <ctype2c>*, <ctype2c>*, <ctype2c>*, F_INT*, <ctype2>*, <ctype2>*, <ctype2c>*, F_INT*
+    callstatement (*f2py_func)(norm,&n,dl,d,du,du2,ipiv,&anorm,&rcond,work,&info,len0)
+    callprotoargument char*, F_INT*, <ctype2c>*, <ctype2c>*, <ctype2c>*, <ctype2c>*, F_INT*, <ctype2>*, <ctype2>*, <ctype2c>*, F_INT*,F_INT
 
     character optional, intent(in) :: norm = '1'
     integer intent(hide), depend(d) :: n = max(3, len(d))
@@ -114,10 +116,11 @@ subroutine <prefix2c>gtcon(norm,n,dl,d,du,du2,ipiv,anorm,rcond,work,info)
     <ftype2c> intent(hide, cache), dimension(2*n), depend(n) :: work
     integer intent(out) :: info
 
+    integer intent(hide) :: len0 = 1
 end subroutine <prefix2c>gtcon
 
 
-subroutine <prefix2>gtsvx(fact,trans,n,nrhs,dl,d,du,dlf,df,duf,du2,ipiv,b,ldb,x,ldx,rcond,ferr,berr,work,iwork,info)
+subroutine <prefix2>gtsvx(fact,trans,n,nrhs,dl,d,du,dlf,df,duf,du2,ipiv,b,ldb,x,ldx,rcond,ferr,berr,work,iwork,info,len0,len1)
     ! ?GTSVX uses the LU factorization to compute the solution to a real
     ! system of linear equations A * X = B or A**T * X = B,
     ! where A is a tridiagonal matrix of order N and X and B are N-by-NRHS
@@ -125,8 +128,8 @@ subroutine <prefix2>gtsvx(fact,trans,n,nrhs,dl,d,du,dlf,df,duf,du2,ipiv,b,ldb,x,
     !
     ! Error bounds on the solution and a condition estimate are also
     !provided.
-    callstatement (*f2py_func)(fact,trans,&n,&nrhs,dl,d,du,dlf,df,duf,du2,ipiv,b,&ldb,x,&ldx,&rcond,ferr,berr,work,iwork,&info);
-    callprotoargument char*,char*,F_INT*,F_INT*,<ctype2>*,<ctype2>*,<ctype2>*,<ctype2>*,<ctype2>*,<ctype2>*,<ctype2>*,F_INT*,<ctype2>*,F_INT*,<ctype2>*,F_INT*,<ctype2>*,<ctype2>*,<ctype2>*,<ctype2>*,F_INT*,F_INT*
+    callstatement (*f2py_func)(fact,trans,&n,&nrhs,dl,d,du,dlf,df,duf,du2,ipiv,b,&ldb,x,&ldx,&rcond,ferr,berr,work,iwork,&info,len0,len1);
+    callprotoargument char*,char*,F_INT*,F_INT*,<ctype2>*,<ctype2>*,<ctype2>*,<ctype2>*,<ctype2>*,<ctype2>*,<ctype2>*,F_INT*,<ctype2>*,F_INT*,<ctype2>*,F_INT*,<ctype2>*,<ctype2>*,<ctype2>*,<ctype2>*,F_INT*,F_INT*,F_INT,F_INT
 
     character optional, intent(in), check(*fact=='F'||*fact=='N') :: fact = 'N'
     character optional, intent(in), check(*trans=='N'||*trans=='C'||*trans=='T') :: trans = 'N'
@@ -151,10 +154,12 @@ subroutine <prefix2>gtsvx(fact,trans,n,nrhs,dl,d,du,dlf,df,duf,du2,ipiv,b,ldb,x,
     integer intent(hide, cache), dimension(n), depend(n) :: iwork
     integer intent(out) :: info
 
+    integer intent(hide) :: len0 = 1
+    integer intent(hide) :: len1 = 1
 end subroutine <prefix2>gtsvx
 
 
-subroutine <prefix2c>gtsvx(fact,trans,n,nrhs,dl,d,du,dlf,df,duf,du2,ipiv,b,ldb,x,ldx,rcond,ferr,berr,work,rwork,info)
+subroutine <prefix2c>gtsvx(fact,trans,n,nrhs,dl,d,du,dlf,df,duf,du2,ipiv,b,ldb,x,ldx,rcond,ferr,berr,work,rwork,info,len0,len1)
     ! ?GTSVX uses the LU factorization to compute the solution to a
     ! complex system of linear equations A * X = B or A**T * X = B,
     ! where A is a tridiagonal matrix of order N and X and B are N-by-NRHS
@@ -162,8 +167,8 @@ subroutine <prefix2c>gtsvx(fact,trans,n,nrhs,dl,d,du,dlf,df,duf,du2,ipiv,b,ldb,x
     !
     ! Error bounds on the solution and a condition estimate are also
     !provided.
-    callstatement (*f2py_func)(fact,trans,&n,&nrhs,dl,d,du,dlf,df,duf,du2,ipiv,b,&ldb,x,&ldx,&rcond,ferr,berr,work,rwork,&info);
-    callprotoargument char*,char*,F_INT*,F_INT*,<ctype2c>*,<ctype2c>*,<ctype2c>*,<ctype2c>*,<ctype2c>*,<ctype2c>*,<ctype2c>*,F_INT*,<ctype2c>*,F_INT*,<ctype2c>*,F_INT*,<ctype2>*,<ctype2>*,<ctype2>*,<ctype2c>*,<ctype2>*,F_INT*
+    callstatement (*f2py_func)(fact,trans,&n,&nrhs,dl,d,du,dlf,df,duf,du2,ipiv,b,&ldb,x,&ldx,&rcond,ferr,berr,work,rwork,&info,len0,len1);
+    callprotoargument char*,char*,F_INT*,F_INT*,<ctype2c>*,<ctype2c>*,<ctype2c>*,<ctype2c>*,<ctype2c>*,<ctype2c>*,<ctype2c>*,F_INT*,<ctype2c>*,F_INT*,<ctype2c>*,F_INT*,<ctype2>*,<ctype2>*,<ctype2>*,<ctype2c>*,<ctype2>*,F_INT*,F_INT,F_INT
 
     character optional, intent(in), check(*fact=='F'||*fact=='N') :: fact = 'N'
     character optional, intent(in), check(*trans=='N'||*trans=='C'||*trans=='T') :: trans = 'N'
@@ -188,4 +193,6 @@ subroutine <prefix2c>gtsvx(fact,trans,n,nrhs,dl,d,du,dlf,df,duf,du2,ipiv,b,ldb,x
     <ftype2> intent(hide,cache),dimension(n),depend(n) :: rwork
     integer intent(out) :: info
 
+    integer intent(hide) :: len0 = 1
+    integer intent(hide) :: len1 = 1
 end subroutine <prefix2c>gtsvx
diff --git a/scipy/linalg/flapack_other.pyf.src b/scipy/linalg/flapack_other.pyf.src
index d1a87f182a..fbcf71e4fa 100644
--- a/scipy/linalg/flapack_other.pyf.src
+++ b/scipy/linalg/flapack_other.pyf.src
@@ -1,7 +1,7 @@
 ! Signatures for f2py-wrappers of FORTRAN LAPACK Other Auxiliary and Computational functions.
 !
 
-subroutine <prefix2>gejsv(joba,jobu,jobv,jobr,jobt,jobp,m,n,a,lda,sva,u,ldu,v,ldv,work,workout,lwork,iwork,iworkout,info)
+subroutine <prefix2>gejsv(joba,jobu,jobv,jobr,jobt,jobp,m,n,a,lda,sva,u,ldu,v,ldv,work,workout,lwork,iwork,iworkout,info,len0,len1,len2,len3,len4,len5)
     ! ?GEJSV computes the singular value decomposition (SVD) of a complex
     ! M-by-N matrix [A], where M >= N. The SVD of [A] is written as
     !
@@ -14,8 +14,8 @@ subroutine <prefix2>gejsv(joba,jobu,jobv,jobr,jobt,jobp,m,n,a,lda,sva,u,ldu,v,ld
     ! the right singular vectors of [A], respectively. The matrices [U] and [V]
     ! are computed and stored in the arrays U and V, respectively. The diagonal
     ! of [SIGMA] is computed and stored in the array SVA.
-    callstatement {F_INT i;(*f2py_func)(&"CEFGAR"[joba],&"UFWN"[jobu],&"VJWN"[jobv],(jobr?"R":"N"),(jobt?"T":"N"),(jobp?"P":"N"),&m,&n,a,&lda,sva,u,&ldu,v,&ldv,work,&lwork,iwork,&info);for(i=0;i\<7;i++){workout[i] = work[i];}for(i=0;i\<3;i++){iworkout[i] = iwork[i];}}
-    callprotoargument char*,char*,char*,char*,char*,char*,F_INT*,F_INT*,<ctype2>*,F_INT*,<ctype2>*,<ctype2>*,F_INT*,<ctype2>*,F_INT*,<ctype2>*,F_INT*,F_INT*,F_INT*
+    callstatement {F_INT i;(*f2py_func)(&"CEFGAR"[joba],&"UFWN"[jobu],&"VJWN"[jobv],(jobr?"R":"N"),(jobt?"T":"N"),(jobp?"P":"N"),&m,&n,a,&lda,sva,u,&ldu,v,&ldv,work,&lwork,iwork,&info,len0,len1,len2,len3,len4,len5);for(i=0;i\<7;i++){workout[i] = work[i];}for(i=0;i\<3;i++){iworkout[i] = iwork[i];}}
+    callprotoargument char*,char*,char*,char*,char*,char*,F_INT*,F_INT*,<ctype2>*,F_INT*,<ctype2>*,<ctype2>*,F_INT*,<ctype2>*,F_INT*,<ctype2>*,F_INT*,F_INT*,F_INT*,F_INT,F_INT,F_INT,F_INT,F_INT,F_INT
 
     integer intent(in, optional), check((0 <= joba) && (joba < 6)) :: joba = 4
     integer intent(in, optional), check((0 <= jobu) && (jobu < 4)) :: jobu = 0
@@ -40,14 +40,20 @@ subroutine <prefix2>gejsv(joba,jobu,jobv,jobr,jobt,jobp,m,n,a,lda,sva,u,ldu,v,ld
     integer intent(out), dimension(3) :: iworkout
     integer intent(out) :: info
 
+    integer intent(hide) :: len0 = 1
+    integer intent(hide) :: len1 = 1
+    integer intent(hide) :: len2 = 1
+    integer intent(hide) :: len3 = 1
+    integer intent(hide) :: len4 = 1
+    integer intent(hide) :: len5 = 1
 end subroutine <prefix2>gejsv
 
-subroutine <prefix2>trexc(wantq,n,a,lda,q,ldq,ifst,ilst,work,info)
+subroutine <prefix2>trexc(wantq,n,a,lda,q,ldq,ifst,ilst,work,info,len0)
     ! Reorder the Schur decomposition of a real matrix
     ! using an orthogonal or unitary equivalence transformation.
 
-    callstatement (*f2py_func)((wantq?"V":"N"),&n,a,&lda,q,&ldq,&ifst,&ilst,work,&info)
-    callprotoargument char*,F_INT*,<ctype2>*,F_INT*,<ctype2>*,F_INT*,F_INT*,F_INT*,<ctype2>*,F_INT*
+    callstatement (*f2py_func)((wantq?"V":"N"),&n,a,&lda,q,&ldq,&ifst,&ilst,work,&info,len0)
+    callprotoargument char*,F_INT*,<ctype2>*,F_INT*,<ctype2>*,F_INT*,F_INT*,F_INT*,<ctype2>*,F_INT*,F_INT
 
     integer optional,intent(in),check(wantq==0||wantq==1) :: wantq=1
     integer intent(hide),depend(a) :: n=shape(a,1)
@@ -60,14 +66,15 @@ subroutine <prefix2>trexc(wantq,n,a,lda,q,ldq,ifst,ilst,work,info)
     <ftype2> intent(hide),depend(n),dimension(n) :: work
     integer intent(out) :: info
 
+    integer intent(hide) :: len0 = 1
 end subroutine <prefix2>trexc
 
-subroutine <prefix2c>trexc(wantq,n,a,lda,q,ldq,ifst,ilst,info)
+subroutine <prefix2c>trexc(wantq,n,a,lda,q,ldq,ifst,ilst,info,len0)
     ! Reorder the Schur decomposition of a complex matrix
     ! using an orthogonal or unitary equivalence transformation.
 
-    callstatement (*f2py_func)((wantq?"V":"N"),&n,a,&lda,q,&ldq,&ifst,&ilst,&info)
-    callprotoargument char*,F_INT*,<ctype2c>*,F_INT*,<ctype2c>*,F_INT*,F_INT*,F_INT*,F_INT*
+    callstatement (*f2py_func)((wantq?"V":"N"),&n,a,&lda,q,&ldq,&ifst,&ilst,&info,len0)
+    callprotoargument char*,F_INT*,<ctype2c>*,F_INT*,<ctype2c>*,F_INT*,F_INT*,F_INT*,F_INT*,F_INT
 
     integer optional,intent(in),check(wantq==0||wantq==1) :: wantq=1
     integer intent(hide),depend(a) :: n=shape(a,1)
@@ -79,6 +86,7 @@ subroutine <prefix2c>trexc(wantq,n,a,lda,q,ldq,ifst,ilst,info)
     integer intent(in) :: ilst
     integer intent(out) :: info
 
+    integer intent(hide) :: len0 = 1
 end subroutine <prefix2c>trexc
 
 subroutine <prefix2>tgexc(wantq,wantz,n,a,lda,b,ldb,q,ldq,z,ldz,ifst,ilst,work,lwork,info)
@@ -131,10 +139,10 @@ subroutine <prefix2c>tgexc(wantq,wantz,n,a,lda,b,ldb,q,ldq,z,ldz,ifst,ilst,info)
 
 end subroutine <prefix2c>tgexc
 
-subroutine <prefix2>trsen(job,wantq,select,n,t,ldt,q,ldq,wr,wi,m,s,sep,work,lwork,iwork,liwork,info)
+subroutine <prefix2>trsen(job,wantq,select,n,t,ldt,q,ldq,wr,wi,m,s,sep,work,lwork,iwork,liwork,info,len0,len1)
 
-    callstatement (*f2py_func)(job,(wantq?"V":"N"),select,&n,t,&ldt,q,&ldq,wr,wi,&m,&s,&sep,work,&lwork,iwork,&liwork,&info)
-    callprotoargument char*,char*,F_INT*,F_INT*,<ctype2>*,F_INT*,<ctype2>*,F_INT*,<ctype2>*,<ctype2>*,F_INT*,<ctype2>*,<ctype2>*,<ctype2>*,F_INT*,F_INT*,F_INT*,F_INT*
+    callstatement (*f2py_func)(job,(wantq?"V":"N"),select,&n,t,&ldt,q,&ldq,wr,wi,&m,&s,&sep,work,&lwork,iwork,&liwork,&info,len0,len1)
+    callprotoargument char*,char*,F_INT*,F_INT*,<ctype2>*,F_INT*,<ctype2>*,F_INT*,<ctype2>*,<ctype2>*,F_INT*,<ctype2>*,<ctype2>*,<ctype2>*,F_INT*,F_INT*,F_INT*,F_INT*,F_INT,F_INT
 
     character optional,intent(in),check(*job=='N'||*job=='E'||*job=='V'||*job=='B'):: job = 'B'
     logical optional, intent(in),check(wantq==0||wantq==1) :: wantq=1
@@ -159,13 +167,15 @@ subroutine <prefix2>trsen(job,wantq,select,n,t,ldt,q,ldq,wr,wi,m,s,sep,work,lwor
     integer optional,intent(in),check(liwork == -1 || liwork >= 1) :: liwork=1
     integer intent(out) :: info
 
+    integer intent(hide) :: len0 = 1
+    integer intent(hide) :: len1 = 1
 end subroutine <prefix2>trsen
 
-subroutine <prefix2>trsen_lwork(job,wantq,select,n,t,ldt,q,ldq,wr,wi,m,s,sep,work,lwork,iwork,liwork,info)
+subroutine <prefix2>trsen_lwork(job,wantq,select,n,t,ldt,q,ldq,wr,wi,m,s,sep,work,lwork,iwork,liwork,info,len0,len1)
 
     fortranname <prefix2>trsen
-    callstatement (*f2py_func)(job,(wantq?"V":"N"),select,&n,t,&ldt,&q,&ldq,&wr,&wi,&m,&s,&sep,&work,&lwork,&iwork,&liwork,&info)
-    callprotoargument char*,char*,F_INT*,F_INT*,<ctype2>*,F_INT*,<ctype2>*,F_INT*,<ctype2>*,<ctype2>*,F_INT*,<ctype2>*,<ctype2>*,<ctype2>*,F_INT*,F_INT*,F_INT*,F_INT*
+    callstatement (*f2py_func)(job,(wantq?"V":"N"),select,&n,t,&ldt,&q,&ldq,&wr,&wi,&m,&s,&sep,&work,&lwork,&iwork,&liwork,&info,len0,len1)
+    callprotoargument char*,char*,F_INT*,F_INT*,<ctype2>*,F_INT*,<ctype2>*,F_INT*,<ctype2>*,<ctype2>*,F_INT*,<ctype2>*,<ctype2>*,<ctype2>*,F_INT*,F_INT*,F_INT*,F_INT*,F_INT,F_INT
 
     character optional,intent(in),check(*job=='N'||*job=='E'||*job=='V'||*job=='B'):: job = 'B'
     logical intent(in),dimension(n),depend(n) :: select
@@ -188,12 +198,14 @@ subroutine <prefix2>trsen_lwork(job,wantq,select,n,t,ldt,q,ldq,wr,wi,m,s,sep,wor
     integer intent(out) :: iwork
     integer intent(out) :: info
 
+    integer intent(hide) :: len0 = 1
+    integer intent(hide) :: len1 = 1
 end subroutine <prefix2>trsen_lwork
 
-subroutine <prefix2c>trsen(job,wantq,select,n,t,ldt,q,ldq,w,m,s,sep,work,lwork,info)
+subroutine <prefix2c>trsen(job,wantq,select,n,t,ldt,q,ldq,w,m,s,sep,work,lwork,info,len0,len1)
 
-    callstatement (*f2py_func)(job,(wantq?"V":"N"),select,&n,t,&ldt,q,&ldq,w,&m,&s,&sep,work,&lwork,&info)
-    callprotoargument char*,char*,F_INT*,F_INT*,<ctype2c>*,F_INT*,<ctype2c>*,F_INT*,<ctype2c>*,F_INT*,<ctype2>*,<ctype2>*,<ctype2c>*,F_INT*,F_INT*
+    callstatement (*f2py_func)(job,(wantq?"V":"N"),select,&n,t,&ldt,q,&ldq,w,&m,&s,&sep,work,&lwork,&info,len0,len1)
+    callprotoargument char*,char*,F_INT*,F_INT*,<ctype2c>*,F_INT*,<ctype2c>*,F_INT*,<ctype2c>*,F_INT*,<ctype2>*,<ctype2>*,<ctype2c>*,F_INT*,F_INT*,F_INT,F_INT
 
     character optional,intent(in),check(*job=='N'||*job=='E'||*job=='V'||*job=='B'):: job = 'B'
     logical optional, intent(in),check(wantq==0||wantq==1) :: wantq=1
@@ -215,13 +227,15 @@ subroutine <prefix2c>trsen(job,wantq,select,n,t,ldt,q,ldq,w,m,s,sep,work,lwork,i
     integer optional,intent(in),depend(n),check(lwork == -1 || lwork >= 1) :: lwork=MAX(1,n)
     integer intent(out) :: info
 
+    integer intent(hide) :: len0 = 1
+    integer intent(hide) :: len1 = 1
 end subroutine <prefix2c>trsen
 
-subroutine <prefix2c>trsen_lwork(job,wantq,select,n,t,ldt,q,ldq,w,m,s,sep,work,lwork,info)
+subroutine <prefix2c>trsen_lwork(job,wantq,select,n,t,ldt,q,ldq,w,m,s,sep,work,lwork,info,len0,len1)
 
     fortranname <prefix2c>trsen
-    callstatement (*f2py_func)(job,(wantq?"V":"N"),select,&n,t,&ldt,&q,&ldq,&w,&m,&s,&sep,&work,&lwork,&info)
-    callprotoargument char*,char*,F_INT*,F_INT*,<ctype2c>*,F_INT*,<ctype2c>*,F_INT*,<ctype2c>*,F_INT*,<ctype2>*,<ctype2>*,<ctype2c>*,F_INT*,F_INT*
+    callstatement (*f2py_func)(job,(wantq?"V":"N"),select,&n,t,&ldt,&q,&ldq,&w,&m,&s,&sep,&work,&lwork,&info,len0,len1)
+    callprotoargument char*,char*,F_INT*,F_INT*,<ctype2c>*,F_INT*,<ctype2c>*,F_INT*,<ctype2c>*,F_INT*,<ctype2>*,<ctype2>*,<ctype2c>*,F_INT*,F_INT*,F_INT,F_INT
 
     character optional,intent(in),check(*job=='N'||*job=='E'||*job=='V'||*job=='B'):: job = 'B'
     logical intent(in),dimension(n),depend(n) :: select
@@ -241,6 +255,8 @@ subroutine <prefix2c>trsen_lwork(job,wantq,select,n,t,ldt,q,ldq,w,m,s,sep,work,l
     <ftype2c> intent(out) :: work
     integer intent(out) :: info
 
+    integer intent(hide) :: len0 = 1
+    integer intent(hide) :: len1 = 1
 end subroutine <prefix2c>trsen_lwork
 
 subroutine <prefix2>tgsen(ijob,wantq,wantz,select,n,a,lda,b,ldb,alphar,alphai,beta,q,ldq,z,ldz,m,pl,pr,dif,work,lwork,iwork,liwork,info)
@@ -386,7 +402,7 @@ subroutine <prefix2c>tgsen_lwork(ijob,wantq,wantz,select,n,a,lda,b,ldb,alpha,bet
 
 end subroutine <prefix2c>tgsen_lwork
 
-subroutine <prefix2>tgsyl(trans,ijob,m,n,a,lda,b,ldb,c,ldc,d,ldd,e,lde,f,ldf,scale,dif,work,lwork,iwork,info)
+subroutine <prefix2>tgsyl(trans,ijob,m,n,a,lda,b,ldb,c,ldc,d,ldd,e,lde,f,ldf,scale,dif,work,lwork,iwork,info,len0)
 
     ! Solves the generalized Sylvester equation:
     ! A * R - L * B = scale * C
@@ -399,8 +415,8 @@ subroutine <prefix2>tgsyl(trans,ijob,m,n,a,lda,b,ldb,c,ldc,d,ldd,e,lde,f,ldf,sca
     ! The solution (R, L) overwrites (C, F). 0 <= SCALE <= 1 is an output
     ! scaling factor chosen to avoid overflow.
 
-    callstatement (*f2py_func)(trans,&ijob,&m,&n,a,&lda,b,&ldb,c,&ldc,d,&ldd,e,&lde,f,&ldf,&scale,&dif,work,&lwork,iwork,&info)
-    callprotoargument char*,F_INT*,F_INT*,F_INT*,<ctype2>*,F_INT*,<ctype2>*,F_INT*,<ctype2>*,F_INT*,<ctype2>*,F_INT*,<ctype2>*,F_INT*,<ctype2>*,F_INT*,<ctype2>*,<ctype2>*,<ctype2>*,F_INT*,F_INT*,F_INT*
+    callstatement (*f2py_func)(trans,&ijob,&m,&n,a,&lda,b,&ldb,c,&ldc,d,&ldd,e,&lde,f,&ldf,&scale,&dif,work,&lwork,iwork,&info,len0)
+    callprotoargument char*,F_INT*,F_INT*,F_INT*,<ctype2>*,F_INT*,<ctype2>*,F_INT*,<ctype2>*,F_INT*,<ctype2>*,F_INT*,<ctype2>*,F_INT*,<ctype2>*,F_INT*,<ctype2>*,<ctype2>*,<ctype2>*,F_INT*,F_INT*,F_INT*,F_INT
 
     character optional,intent(in),check((*trans=='N')||(*trans=='T')) :: trans = 'N'
     integer optional,intent(in),check(ijob>=0 && ijob<=4):: ijob = 0
@@ -432,17 +448,18 @@ subroutine <prefix2>tgsyl(trans,ijob,m,n,a,lda,b,ldb,c,ldc,d,ldd,e,lde,f,ldf,sca
     integer intent(hide),depend(m,n),dimension(m+n+6):: iwork
     integer intent(out):: info
 
+    integer intent(hide) :: len0 = 1
 end subroutine <prefix2>tgsyl
 
-subroutine <prefix2>pbtrf(lower,n,kd,ab,ldab,info)
+subroutine <prefix2>pbtrf(lower,n,kd,ab,ldab,info,len0)
     ! Compute Cholesky decomposition of banded symmetric positive definite
     ! matrix:
     ! A = U^T * U, C = U if lower = 0
     ! A = L * L^T, C = L if lower = 1
     ! C is triangular matrix of the corresponding Cholesky decomposition.
 
-    callstatement (*f2py_func)((lower?"L":"U"),&n,&kd,ab,&ldab,&info);
-    callprotoargument char*,F_INT*,F_INT*,<ctype2>*,F_INT*,F_INT*
+    callstatement (*f2py_func)((lower?"L":"U"),&n,&kd,ab,&ldab,&info,len0);
+    callprotoargument char*,F_INT*,F_INT*,<ctype2>*,F_INT*,F_INT*,F_INT
 
     integer optional,check(shape(ab,0)==ldab),depend(ab) :: ldab=shape(ab,0)
     integer intent(hide),depend(ab) :: n=shape(ab,1)
@@ -452,17 +469,18 @@ subroutine <prefix2>pbtrf(lower,n,kd,ab,ldab,info)
     <ftype2> dimension(ldab,n),intent(in,out,copy,out=c) :: ab
     integer intent(out) :: info
 
+    integer intent(hide) :: len0 = 1
 end subroutine <prefix2>pbtrf
 
-subroutine <prefix2c>pbtrf(lower,n,kd,ab,ldab,info)
+subroutine <prefix2c>pbtrf(lower,n,kd,ab,ldab,info,len0)
     ! Compute Cholesky decomposition of banded symmetric positive definite
     ! matrix:
     ! A = U^H * U, C = U if lower = 0
     ! A = L * L^H, C = L if lower = 1
     ! C is triangular matrix of the corresponding Cholesky decomposition.
 
-    callstatement (*f2py_func)((lower?"L":"U"),&n,&kd,ab,&ldab,&info);
-    callprotoargument char*,F_INT*,F_INT*,<ctype2c>*,F_INT*,F_INT*
+    callstatement (*f2py_func)((lower?"L":"U"),&n,&kd,ab,&ldab,&info,len0);
+    callprotoargument char*,F_INT*,F_INT*,<ctype2c>*,F_INT*,F_INT*,F_INT
 
     integer optional,check(shape(ab,0)==ldab),depend(ab) :: ldab=shape(ab,0)
     integer intent(hide),depend(ab) :: n=shape(ab,1)
@@ -472,9 +490,10 @@ subroutine <prefix2c>pbtrf(lower,n,kd,ab,ldab,info)
     <ftype2c> dimension(ldab,n),intent(in,out,copy,out=c) :: ab
     integer intent(out) :: info
 
+    integer intent(hide) :: len0 = 1
 end subroutine <prefix2c>pbtrf
 
-subroutine <prefix2>pbtrs(lower, n, kd, nrhs, ab, ldab, b, ldb, info)
+subroutine <prefix2>pbtrs(lower, n, kd, nrhs, ab, ldab, b, ldb, info,len0)
 
     ! Solve a system of linear equations A*X = B with a symmetric
     ! positive definite band matrix A using the Cholesky factorization.
@@ -483,8 +502,8 @@ subroutine <prefix2>pbtrs(lower, n, kd, nrhs, ab, ldab, b, ldb, info)
     ! A = U^T * U, AB = U if lower = 0
     ! A = L * L^T, AB = L if lower = 1
 
-    callstatement (*f2py_func)((lower?"L":"U"),&n,&kd,&nrhs,ab,&ldab,b,&ldb,&info);
-    callprotoargument char*,F_INT*,F_INT*,F_INT*,<ctype2>*,F_INT*,<ctype2>*,F_INT*,F_INT*
+    callstatement (*f2py_func)((lower?"L":"U"),&n,&kd,&nrhs,ab,&ldab,b,&ldb,&info,len0);
+    callprotoargument char*,F_INT*,F_INT*,F_INT*,<ctype2>*,F_INT*,<ctype2>*,F_INT*,F_INT*,F_INT
 
     integer optional,check(shape(ab,0)==ldab),depend(ab) :: ldab=shape(ab,0)
     integer intent(hide),depend(ab) :: n=shape(ab,1)
@@ -497,9 +516,10 @@ subroutine <prefix2>pbtrs(lower, n, kd, nrhs, ab, ldab, b, ldb, info)
     <ftype2> dimension(ldab,n),intent(in) :: ab
     integer intent(out) :: info
 
+    integer intent(hide) :: len0 = 1
 end subroutine <tchar=s,d>pbtrs
 
-subroutine <prefix2c>pbtrs(lower, n, kd, nrhs, ab, ldab, b, ldb, info)
+subroutine <prefix2c>pbtrs(lower, n, kd, nrhs, ab, ldab, b, ldb, info,len0)
     ! Solve a system of linear equations A*X = B with a symmetric
     ! positive definite band matrix A using the Cholesky factorization.
     ! AB is the triangular factur U or L from the Cholesky factorization
@@ -507,8 +527,8 @@ subroutine <prefix2c>pbtrs(lower, n, kd, nrhs, ab, ldab, b, ldb, info)
     ! A = U^T * U, AB = U if lower = 0
     ! A = L * L^T, AB = L if lower = 1
 
-    callstatement (*f2py_func)((lower?"L":"U"),&n,&kd,&nrhs,ab,&ldab,b,&ldb,&info);
-    callprotoargument char*,F_INT*,F_INT*,F_INT*,<ctype2c>*,F_INT*,<ctype2c>*,F_INT*,F_INT*
+    callstatement (*f2py_func)((lower?"L":"U"),&n,&kd,&nrhs,ab,&ldab,b,&ldb,&info,len0);
+    callprotoargument char*,F_INT*,F_INT*,F_INT*,<ctype2c>*,F_INT*,<ctype2c>*,F_INT*,F_INT*,F_INT
 
     integer optional,check(shape(ab,0)==ldab),depend(ab) :: ldab=shape(ab,0)
     integer intent(hide),depend(ab) :: n=shape(ab,1)
@@ -521,15 +541,16 @@ subroutine <prefix2c>pbtrs(lower, n, kd, nrhs, ab, ldab, b, ldb, info)
     <ftype2c> dimension(ldab,n),intent(in) :: ab
     integer intent(out) :: info
 
+    integer intent(hide) :: len0 = 1
 end subroutine <prefix2c>pbtrs
 
-subroutine <prefix>trtrs(lower, trans, unitdiag, n, nrhs, a, lda, b, ldb, info)
+subroutine <prefix>trtrs(lower, trans, unitdiag, n, nrhs, a, lda, b, ldb, info,len0,len1,len2)
 
     ! Solve a system of linear equations A*X = B with a triangular
     ! matrix A.
 
-    callstatement (*f2py_func)((lower?"L":"U"),(trans?(trans==2?"C":"T"):"N"),(unitdiag?"U":"N"),&n,&nrhs,a,&lda,b,&ldb,&info);
-    callprotoargument char*,char*,char*,F_INT*,F_INT*,<ctype>*,F_INT*,<ctype>*,F_INT*,F_INT*
+    callstatement (*f2py_func)((lower?"L":"U"),(trans?(trans==2?"C":"T"):"N"),(unitdiag?"U":"N"),&n,&nrhs,a,&lda,b,&ldb,&info,len0,len1,len2);
+    callprotoargument char*,char*,char*,F_INT*,F_INT*,<ctype>*,F_INT*,<ctype>*,F_INT*,F_INT*,F_INT,F_INT,F_INT
 
     integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
     integer optional,intent(in),check(trans>=0 && trans <=2) :: trans = 0
@@ -543,16 +564,19 @@ subroutine <prefix>trtrs(lower, trans, unitdiag, n, nrhs, a, lda, b, ldb, info)
     <ftype> dimension(lda,n),intent(in) :: a
     integer intent(out) :: info
 
+    integer intent(hide) :: len0 = 1
+    integer intent(hide) :: len1 = 1
+    integer intent(hide) :: len2 = 1
 end subroutine <prefix>trtrs
 
 
-subroutine <prefix>trcon(norm, uplo, diag, n, a, lda, rcond, work, irwork, info)
+subroutine <prefix>trcon(norm, uplo, diag, n, a, lda, rcond, work, irwork, info,len0,len1,len2)
 
     ! ?TRCON estimates the reciprocal of the condition number of a
     ! triangular matrix A, in either the 1-norm or the infinity-norm.
 
-    callstatement (*f2py_func)(norm,uplo,diag,&n,a,&lda,&rcond,work,irwork,&info);
-    callprotoargument char*,char*,char*,F_INT*,<ctype>*,F_INT*,<ctypereal>*,<ctype>*,<F_INT,F_INT,float,double>*,F_INT*
+    callstatement (*f2py_func)(norm,uplo,diag,&n,a,&lda,&rcond,work,irwork,&info,len0,len1,len2);
+    callprotoargument char*,char*,char*,F_INT*,<ctype>*,F_INT*,<ctypereal>*,<ctype>*,<F_INT,F_INT,float,double>*,F_INT*,F_INT,F_INT,F_INT
 
     character optional intent(in), check(*norm=='1'||*norm=='I'||*norm=='O') :: norm = '1'
     character optional intent(in), check(*uplo=='U'||*uplo=='L') :: uplo = 'U'
@@ -565,10 +589,13 @@ subroutine <prefix>trcon(norm, uplo, diag, n, a, lda, rcond, work, irwork, info)
     <ftypereal> intent(out) :: rcond
     integer intent(out) :: info
 
+    integer intent(hide) :: len0 = 1
+    integer intent(hide) :: len1 = 1
+    integer intent(hide) :: len2 = 1
 end subroutine <prefix>trcon
 
 
-subroutine <prefix>tbtrs(uplo,trans,diag,n,kd,nrhs,ab,ldab,b,ldb,info)
+subroutine <prefix>tbtrs(uplo,trans,diag,n,kd,nrhs,ab,ldab,b,ldb,info,len0,len1,len2)
     ! x, info  = tbtrs(ab, b, uplo="U", trans="N", diag="N", overwrite_b=0)
     ! ?TBTRS solves a triangular system of the form
     !
@@ -579,8 +606,8 @@ subroutine <prefix>tbtrs(uplo,trans,diag,n,kd,nrhs,ab,ldab,b,ldb,info)
     !   * B is an N-by NRHS matrix.
     ! A check is made to verify that A is nonsingular.
 
-    callstatement (*f2py_func)(uplo,trans,diag,&n,&kd,&nrhs,ab,&ldab,b,&ldb,&info)
-    callprotoargument char*,char*,char*,F_INT*,F_INT*,F_INT*,<ctype>*,F_INT*,<ctype>*,F_INT*,F_INT*
+    callstatement (*f2py_func)(uplo,trans,diag,&n,&kd,&nrhs,ab,&ldab,b,&ldb,&info,len0,len1,len2)
+    callprotoargument char*,char*,char*,F_INT*,F_INT*,F_INT*,<ctype>*,F_INT*,<ctype>*,F_INT*,F_INT*,F_INT,F_INT,F_INT
 
     <ftype> intent(in), dimension(ldab, n) :: ab
     <ftype> intent(in,out,copy,out=x), dimension(ldb, nrhs) :: b
@@ -596,9 +623,12 @@ subroutine <prefix>tbtrs(uplo,trans,diag,n,kd,nrhs,ab,ldab,b,ldb,info)
     integer intent(hide), depend(b, n), check(ldb >= n) :: ldb = MAX(1, shape(b, 0))
     integer intent(hide), depend(b) :: nrhs = MAX(1, shape(b, 1))
 
+    integer intent(hide) :: len0 = 1
+    integer intent(hide) :: len1 = 1
+    integer intent(hide) :: len2 = 1
 end subroutine <prefix>tbtrs
 
-subroutine <prefix2>pbsv(lower,n,kd,nrhs,ab,ldab,b,ldb,info)
+subroutine <prefix2>pbsv(lower,n,kd,nrhs,ab,ldab,b,ldb,info,len0)
     !
     ! Computes the solution to a real system of linear equations
     ! A * X = B,
@@ -613,8 +643,8 @@ subroutine <prefix2>pbsv(lower,n,kd,nrhs,ab,ldab,b,ldb,info)
     !  subdiagonals as A.  The factored form of A is then used to solve the
     !  system of equations A * X = B.
 
-    callstatement (*f2py_func)((lower?"L":"U"),&n,&kd,&nrhs,ab,&ldab,b,&ldb,&info);
-    callprotoargument char*,F_INT*,F_INT*,F_INT*,<ctype2>*,F_INT*,<ctype2>*,F_INT*,F_INT*
+    callstatement (*f2py_func)((lower?"L":"U"),&n,&kd,&nrhs,ab,&ldab,b,&ldb,&info,len0);
+    callprotoargument char*,F_INT*,F_INT*,F_INT*,<ctype2>*,F_INT*,<ctype2>*,F_INT*,F_INT*,F_INT
 
     integer optional,check(shape(ab,0)==ldab),depend(ab) :: ldab=shape(ab,0)
     integer intent(hide),depend(ab) :: n=shape(ab,1)
@@ -627,9 +657,10 @@ subroutine <prefix2>pbsv(lower,n,kd,nrhs,ab,ldab,b,ldb,info)
     <ftype2> dimension(ldab,n),intent(in,out,copy,out=c) :: ab
     integer intent(out) :: info
 
+    integer intent(hide) :: len0 = 1
 end subroutine <prefix2>pbsv
 
-subroutine <prefix2c>pbsv(lower,n,kd,nrhs,ab,ldab,b,ldb,info)
+subroutine <prefix2c>pbsv(lower,n,kd,nrhs,ab,ldab,b,ldb,info,len0)
     ! Computes the solution to a real system of linear equations
     ! A * X = B,
     !  where A is an N-by-N Hermitian positive definite band matrix and X
@@ -643,8 +674,8 @@ subroutine <prefix2c>pbsv(lower,n,kd,nrhs,ab,ldab,b,ldb,info)
     !  subdiagonals as A.  The factored form of A is then used to solve the
     !  system of equations A * X = B.
 
-    callstatement (*f2py_func)((lower?"L":"U"),&n,&kd,&nrhs,ab,&ldab,b,&ldb,&info);
-    callprotoargument char*,F_INT*,F_INT*,F_INT*,<ctype2c>*,F_INT*,<ctype2c>*,F_INT*,F_INT*
+    callstatement (*f2py_func)((lower?"L":"U"),&n,&kd,&nrhs,ab,&ldab,b,&ldb,&info,len0);
+    callprotoargument char*,F_INT*,F_INT*,F_INT*,<ctype2c>*,F_INT*,<ctype2c>*,F_INT*,F_INT*,F_INT
 
     integer optional,check(shape(ab,0)==ldab),depend(ab) :: ldab=shape(ab,0)
     integer intent(hide),depend(ab) :: n=shape(ab,1)
@@ -657,9 +688,10 @@ subroutine <prefix2c>pbsv(lower,n,kd,nrhs,ab,ldab,b,ldb,info)
     <ftype2c> dimension(ldab,n),intent(in,out,copy,out=c) :: ab
     integer intent(out) :: info
 
+    integer intent(hide) :: len0 = 1
 end subroutine <prefix2c>pbsv
 
-subroutine <prefix2>orcsd(compute_u1,compute_u2,compute_v1t,compute_v2t,trans,signs,m,p,q,x11,ldx11,x12,ldx12,x21,ldx21,x22,ldx22,theta,u1,ldu1,u2,ldu2,v1t,ldv1t,v2t,ldv2t,work,lwork,iwork,info,mmp,mmq)
+subroutine <prefix2>orcsd(compute_u1,compute_u2,compute_v1t,compute_v2t,trans,signs,m,p,q,x11,ldx11,x12,ldx12,x21,ldx21,x22,ldx22,theta,u1,ldu1,u2,ldu2,v1t,ldv1t,v2t,ldv2t,work,lwork,iwork,info,mmp,mmq,len0,len1,len2,len3,len4,len5)
     ! DORCSD computes the CS decomposition of an M-by-M partitioned
     ! unitary matrix X:
     !
@@ -680,8 +712,8 @@ subroutine <prefix2>orcsd(compute_u1,compute_u2,compute_v1t,compute_v2t,trans,si
     !  min(p, m - q) - r, min(m - p, q) - r, and min(m - p, m - q) - r
     !  respectively.
 
-    callstatement (*f2py_func)((compute_u1?"Y":"N"),(compute_u2?"Y":"N"),(compute_v1t?"Y":"N"),(compute_v2t?"Y":"N"),(trans?"T":"N"),(signs?"O":"D"),&m,&p,&q,x11,&ldx11,x12,&ldx12,x21,&ldx21,x22,&ldx22,theta,u1,&ldu1,u2,&ldu2,v1t,&ldv1t,v2t,&ldv2t,work,&lwork,iwork,&info)
-    callprotoargument char*,char*,char*,char*,char*,char*,F_INT*,F_INT*,F_INT*,<ctype2>*,F_INT*,<ctype2>*,F_INT*,<ctype2>*,F_INT*,<ctype2>*,F_INT*,<ctype2>*,<ctype2>*,F_INT*,<ctype2>*,F_INT*,<ctype2>*,F_INT*,<ctype2>*,F_INT*,<ctype2>*,F_INT*,F_INT*,F_INT*
+    callstatement (*f2py_func)((compute_u1?"Y":"N"),(compute_u2?"Y":"N"),(compute_v1t?"Y":"N"),(compute_v2t?"Y":"N"),(trans?"T":"N"),(signs?"O":"D"),&m,&p,&q,x11,&ldx11,x12,&ldx12,x21,&ldx21,x22,&ldx22,theta,u1,&ldu1,u2,&ldu2,v1t,&ldv1t,v2t,&ldv2t,work,&lwork,iwork,&info,len0,len1,len2,len3,len4,len5)
+    callprotoargument char*,char*,char*,char*,char*,char*,F_INT*,F_INT*,F_INT*,<ctype2>*,F_INT*,<ctype2>*,F_INT*,<ctype2>*,F_INT*,<ctype2>*,F_INT*,<ctype2>*,<ctype2>*,F_INT*,<ctype2>*,F_INT*,<ctype2>*,F_INT*,<ctype2>*,F_INT*,<ctype2>*,F_INT*,F_INT*,F_INT*,F_INT,F_INT,F_INT,F_INT,F_INT,F_INT
 
     integer optional,intent(in),check(compute_u1==0||compute_u1==1) :: compute_u1 = 1
     integer optional,intent(in),check(compute_u2==0||compute_u2==1) :: compute_u2 = 1
@@ -724,14 +756,20 @@ subroutine <prefix2>orcsd(compute_u1,compute_u2,compute_v1t,compute_v2t,trans,si
     integer optional,intent(in),check(lwork==-1||lwork>0),depend(m,mmp,mmq) :: lwork = 2 + 2*m + 5*MAX(1,q-1) + 4*MAX(1,q) + 8*q
     integer intent(out) :: info
 
+    integer intent(hide) :: len0 = 1
+    integer intent(hide) :: len1 = 1
+    integer intent(hide) :: len2 = 1
+    integer intent(hide) :: len3 = 1
+    integer intent(hide) :: len4 = 1
+    integer intent(hide) :: len5 = 1
 end subroutine <prefix2>orcsd
 
-subroutine <prefix2>orcsd_lwork(m,p,q,x11,ldx11,x12,ldx12,x21,ldx21,x22,ldx22,theta,u1,ldu1,u2,ldu2,v1t,ldv1t,v2t,ldv2t,work,lwork,iwork,info,mmp,mmq)
+subroutine <prefix2>orcsd_lwork(m,p,q,x11,ldx11,x12,ldx12,x21,ldx21,x22,ldx22,theta,u1,ldu1,u2,ldu2,v1t,ldv1t,v2t,ldv2t,work,lwork,iwork,info,mmp,mmq,len0,len1,len2,len3,len4,len5)
     ! LWORK computation for (S/D)ORCSD
 
     fortranname <prefix2>orcsd
-    callstatement (*f2py_func)("Y","Y","Y","Y","N","D",&m,&p,&q,&x11,&ldx11,&x12,&ldx12,&x21,&ldx21,&x22,&ldx22,&theta,&u1,&ldu1,&u2,&ldu2,&v1t,&ldv1t,&v2t,&ldv2t,&work,&lwork,&iwork,&info)
-    callprotoargument char*,char*,char*,char*,char*,char*,F_INT*,F_INT*,F_INT*,<ctype2>*,F_INT*,<ctype2>*,F_INT*,<ctype2>*,F_INT*,<ctype2>*,F_INT*,<ctype2>*,<ctype2>*,F_INT*,<ctype2>*,F_INT*,<ctype2>*,F_INT*,<ctype2>*,F_INT*,<ctype2>*,F_INT*,F_INT*,F_INT*
+    callstatement (*f2py_func)("Y","Y","Y","Y","N","D",&m,&p,&q,&x11,&ldx11,&x12,&ldx12,&x21,&ldx21,&x22,&ldx22,&theta,&u1,&ldu1,&u2,&ldu2,&v1t,&ldv1t,&v2t,&ldv2t,&work,&lwork,&iwork,&info,len0,len1,len2,len3,len4,len5)
+    callprotoargument char*,char*,char*,char*,char*,char*,F_INT*,F_INT*,F_INT*,<ctype2>*,F_INT*,<ctype2>*,F_INT*,<ctype2>*,F_INT*,<ctype2>*,F_INT*,<ctype2>*,<ctype2>*,F_INT*,<ctype2>*,F_INT*,<ctype2>*,F_INT*,<ctype2>*,F_INT*,<ctype2>*,F_INT*,F_INT*,F_INT*,F_INT,F_INT,F_INT,F_INT,F_INT,F_INT
 
     integer intent(in) :: m
     integer intent(in) :: p
@@ -762,9 +800,15 @@ subroutine <prefix2>orcsd_lwork(m,p,q,x11,ldx11,x12,ldx12,x21,ldx21,x22,ldx22,th
     <ftype2> intent(out) :: work
     integer intent(out) :: info
 
+    integer intent(hide) :: len0 = 1
+    integer intent(hide) :: len1 = 1
+    integer intent(hide) :: len2 = 1
+    integer intent(hide) :: len3 = 1
+    integer intent(hide) :: len4 = 1
+    integer intent(hide) :: len5 = 1
 end subroutine <prefix2>orcsd_lwork
 
-subroutine <prefix2c>uncsd(compute_u1,compute_u2,compute_v1t,compute_v2t,trans,signs,m,p,q,x11,ldx11,x12,ldx12,x21,ldx21,x22,ldx22,theta,u1,ldu1,u2,ldu2,v1t,ldv1t,v2t,ldv2t,work,lwork,rwork,lrwork,iwork,info,mmp,mmq)
+subroutine <prefix2c>uncsd(compute_u1,compute_u2,compute_v1t,compute_v2t,trans,signs,m,p,q,x11,ldx11,x12,ldx12,x21,ldx21,x22,ldx22,theta,u1,ldu1,u2,ldu2,v1t,ldv1t,v2t,ldv2t,work,lwork,rwork,lrwork,iwork,info,mmp,mmq,len0,len1,len2,len3,len4,len5)
     ! ZUNCSD computes the CS decomposition of an M-by-M partitioned
     ! unitary matrix X:
     !
@@ -786,8 +830,8 @@ subroutine <prefix2c>uncsd(compute_u1,compute_u2,compute_v1t,compute_v2t,trans,s
     !  respectively.
 
 
-    callstatement (*f2py_func)((compute_u1?"Y":"N"),(compute_u2?"Y":"N"),(compute_v1t?"Y":"N"),(compute_v2t?"Y":"N"),(trans?"T":"N"),(signs?"O":"D"),&m,&p,&q,x11,&ldx11,x12,&ldx12,x21,&ldx21,x22,&ldx22,theta,u1,&ldu1,u2,&ldu2,v1t,&ldv1t,v2t,&ldv2t,work,&lwork,rwork,&lrwork,iwork,&info)
-    callprotoargument char*,char*,char*,char*,char*,char*,F_INT*,F_INT*,F_INT*,<ctype2c>*,F_INT*,<ctype2c>*,F_INT*,<ctype2c>*,F_INT*,<ctype2c>*,F_INT*,<ctype2>*,<ctype2c>*,F_INT*,<ctype2c>*,F_INT*,<ctype2c>*,F_INT*,<ctype2c>*,F_INT*,<ctype2c>*,F_INT*,<ctype2>*,F_INT*,F_INT*,F_INT*
+    callstatement (*f2py_func)((compute_u1?"Y":"N"),(compute_u2?"Y":"N"),(compute_v1t?"Y":"N"),(compute_v2t?"Y":"N"),(trans?"T":"N"),(signs?"O":"D"),&m,&p,&q,x11,&ldx11,x12,&ldx12,x21,&ldx21,x22,&ldx22,theta,u1,&ldu1,u2,&ldu2,v1t,&ldv1t,v2t,&ldv2t,work,&lwork,rwork,&lrwork,iwork,&info,len0,len1,len2,len3,len4,len5)
+    callprotoargument char*,char*,char*,char*,char*,char*,F_INT*,F_INT*,F_INT*,<ctype2c>*,F_INT*,<ctype2c>*,F_INT*,<ctype2c>*,F_INT*,<ctype2c>*,F_INT*,<ctype2>*,<ctype2c>*,F_INT*,<ctype2c>*,F_INT*,<ctype2c>*,F_INT*,<ctype2c>*,F_INT*,<ctype2c>*,F_INT*,<ctype2>*,F_INT*,F_INT*,F_INT*,F_INT,F_INT,F_INT,F_INT,F_INT,F_INT
 
     integer optional,intent(in),check(compute_u1==0||compute_u1==1) :: compute_u1 = 1
     integer optional,intent(in),check(compute_u2==0||compute_u2==1) :: compute_u2 = 1
@@ -832,14 +876,20 @@ subroutine <prefix2c>uncsd(compute_u1,compute_u2,compute_v1t,compute_v2t,trans,s
     integer optional,intent(in),check(lrwork==-1||lrwork>0),depend(q) :: lrwork = 5*MAX(1,q-1) + 4*MAX(1,q) + 8*q + 1
     integer intent(out) :: info
 
+    integer intent(hide) :: len0 = 1
+    integer intent(hide) :: len1 = 1
+    integer intent(hide) :: len2 = 1
+    integer intent(hide) :: len3 = 1
+    integer intent(hide) :: len4 = 1
+    integer intent(hide) :: len5 = 1
 end subroutine <prefix2c>uncsd
 
-subroutine <prefix2c>uncsd_lwork(m,p,q,x11,ldx11,x12,ldx12,x21,ldx21,x22,ldx22,theta,u1,ldu1,u2,ldu2,v1t,ldv1t,v2t,ldv2t,work,lwork,rwork,lrwork,iwork,info,mmp,mmq)
+subroutine <prefix2c>uncsd_lwork(m,p,q,x11,ldx11,x12,ldx12,x21,ldx21,x22,ldx22,theta,u1,ldu1,u2,ldu2,v1t,ldv1t,v2t,ldv2t,work,lwork,rwork,lrwork,iwork,info,mmp,mmq,len0,len1,len2,len3,len4,len5)
     ! LWORK computation for (C/Z)UNCSD
 
     fortranname <prefix2c>uncsd
-    callstatement (*f2py_func)("Y","Y","Y","Y","N","D",&m,&p,&q,&x11,&ldx11,&x12,&ldx12,&x21,&ldx21,&x22,&ldx22,&theta,&u1,&ldu1,&u2,&ldu2,&v1t,&ldv1t,&v2t,&ldv2t,&work,&lwork,&rwork,&lrwork,&iwork,&info)
-    callprotoargument char*,char*,char*,char*,char*,char*,F_INT*,F_INT*,F_INT*,<ctype2c>*,F_INT*,<ctype2c>*,F_INT*,<ctype2c>*,F_INT*,<ctype2c>*,F_INT*,<ctype2>*,<ctype2c>*,F_INT*,<ctype2c>*,F_INT*,<ctype2c>*,F_INT*,<ctype2c>*,F_INT*,<ctype2c>*,F_INT*,<ctype2>*,F_INT*,F_INT*,F_INT*
+    callstatement (*f2py_func)("Y","Y","Y","Y","N","D",&m,&p,&q,&x11,&ldx11,&x12,&ldx12,&x21,&ldx21,&x22,&ldx22,&theta,&u1,&ldu1,&u2,&ldu2,&v1t,&ldv1t,&v2t,&ldv2t,&work,&lwork,&rwork,&lrwork,&iwork,&info,len0,len1,len2,len3,len4,len5)
+    callprotoargument char*,char*,char*,char*,char*,char*,F_INT*,F_INT*,F_INT*,<ctype2c>*,F_INT*,<ctype2c>*,F_INT*,<ctype2c>*,F_INT*,<ctype2c>*,F_INT*,<ctype2>*,<ctype2c>*,F_INT*,<ctype2c>*,F_INT*,<ctype2c>*,F_INT*,<ctype2c>*,F_INT*,<ctype2c>*,F_INT*,<ctype2>*,F_INT*,F_INT*,F_INT*,F_INT,F_INT,F_INT,F_INT,F_INT,F_INT
 
     integer intent(in) :: m
     integer intent(in) :: p
@@ -872,6 +922,12 @@ subroutine <prefix2c>uncsd_lwork(m,p,q,x11,ldx11,x12,ldx12,x21,ldx21,x22,ldx22,t
     <ftype2> intent(out) :: rwork
     integer intent(out) :: info
 
+    integer intent(hide) :: len0 = 1
+    integer intent(hide) :: len1 = 1
+    integer intent(hide) :: len2 = 1
+    integer intent(hide) :: len3 = 1
+    integer intent(hide) :: len4 = 1
+    integer intent(hide) :: len5 = 1
 end subroutine <prefix2c>uncsd_lwork
 
 subroutine <prefix2>orghr(n,lo,hi,a,tau,work,lwork,info)
@@ -987,15 +1043,15 @@ subroutine <prefix2c>ungqr(m,n,k,a,tau,work,lwork,info)
 
 end subroutine <prefix2c>ungqr
 
-subroutine <prefix2>ormqr(side,trans,m,n,k,a,lda,tau,c,ldc,work,lwork,info)
+subroutine <prefix2>ormqr(side,trans,m,n,k,a,lda,tau,c,ldc,work,lwork,info,len0,len1)
     ! cq,work,info = ormqr(side,trans,a,tau,c,lwork)
     ! multiplies the real matrix C with the real orthogonal matrix Q,
     ! which is defined as the first N columns of a product of K elementary
     ! reflectors of order M (e.g. output of geqrf)
 
     threadsafe
-    callstatement (*f2py_func)(side,trans,&m,&n,&k,a,&lda,tau,c,&ldc,work,&lwork,&info)
-    callprotoargument char*,char*,F_INT*,F_INT*,F_INT*,<ctype2>*,F_INT*,<ctype2>*,<ctype2>*,F_INT*,<ctype2>*,F_INT*,F_INT*
+    callstatement (*f2py_func)(side,trans,&m,&n,&k,a,&lda,tau,c,&ldc,work,&lwork,&info,len0,len1)
+    callprotoargument char*,char*,F_INT*,F_INT*,F_INT*,<ctype2>*,F_INT*,<ctype2>*,<ctype2>*,F_INT*,<ctype2>*,F_INT*,F_INT*,F_INT,F_INT
 
     character intent(in),check(*side=='L'||*side=='R'):: side
     character intent(in),check(*trans=='N'||*trans=='T'):: trans
@@ -1011,17 +1067,19 @@ subroutine <prefix2>ormqr(side,trans,m,n,k,a,lda,tau,c,ldc,work,lwork,info)
     integer intent(in):: lwork
     integer intent(out) :: info
 
+    integer intent(hide) :: len0 = 1
+    integer intent(hide) :: len1 = 1
 end subroutine <prefix2>ormqr
 
-subroutine <prefix2c>unmqr(side,trans,m,n,k,a,lda,tau,c,ldc,work,lwork,info)
+subroutine <prefix2c>unmqr(side,trans,m,n,k,a,lda,tau,c,ldc,work,lwork,info,len0,len1)
     ! cq,work,info = unmqr(side,trans,a,tau,c,lwork)
     ! multiplies the complex matrix C with the complex unitary matrix Q,
     ! which is defined as the first N columns of a product of K elementary
     ! reflectors of order M (e.g. output of geqrf)
 
     threadsafe
-    callstatement (*f2py_func)(side,trans,&m,&n,&k,a,&lda,tau,c,&ldc,work,&lwork,&info)
-    callprotoargument char*,char*,F_INT*,F_INT*,F_INT*,<ctype2c>*,F_INT*,<ctype2c>*,<ctype2c>*,F_INT*,<ctype2c>*,F_INT*,F_INT*
+    callstatement (*f2py_func)(side,trans,&m,&n,&k,a,&lda,tau,c,&ldc,work,&lwork,&info,len0,len1)
+    callprotoargument char*,char*,F_INT*,F_INT*,F_INT*,<ctype2c>*,F_INT*,<ctype2c>*,<ctype2c>*,F_INT*,<ctype2c>*,F_INT*,F_INT*,F_INT,F_INT
 
     character intent(in),check(*side=='L'||*side=='R'):: side
     character intent(in),check(*trans=='N'||*trans=='C'):: trans
@@ -1037,6 +1095,8 @@ subroutine <prefix2c>unmqr(side,trans,m,n,k,a,lda,tau,c,ldc,work,lwork,info)
     integer intent(in):: lwork
     integer intent(out) :: info
 
+    integer intent(hide) :: len0 = 1
+    integer intent(hide) :: len1 = 1
 end subroutine <prefix2c>unmqr
 
 subroutine <prefix>geqrt(m,n,nb,a,lda,t,ldt,work,info)
@@ -1061,7 +1121,7 @@ subroutine <prefix>geqrt(m,n,nb,a,lda,t,ldt,work,info)
 
 end subroutine <prefix>geqrt
 
-subroutine <prefix>gemqrt(side,trans,m,n,k,nb,v,ldv,t,ldt,c,ldc,work,info)
+subroutine <prefix>gemqrt(side,trans,m,n,k,nb,v,ldv,t,ldt,c,ldc,work,info,len0,len1)
     ! c,info = gemqrt(side,trans,v,t,c,[overwrite_c=0])
     !
     ! Multiplies a general matrix C by the orthogonal matrix Q defined by the
@@ -1069,8 +1129,8 @@ subroutine <prefix>gemqrt(side,trans,m,n,k,nb,v,ldv,t,ldt,c,ldc,work,info)
     ! reflectors in matrix T. C may be multiplied by Q, its transpose (for real
     ! matrices), or its adjoint (for complex matrices) from the left or right.
 
-    callstatement (*f2py_func)(side,trans,&m,&n,&k,&nb,v,&ldv,t,&ldt,c,&ldc,work,&info)
-    callprotoargument char*,char*,F_INT*,F_INT*,F_INT*,F_INT*,<ctype>*,F_INT*,<ctype>*,F_INT*,<ctype>*,F_INT*,<ctype>*,F_INT*
+    callstatement (*f2py_func)(side,trans,&m,&n,&k,&nb,v,&ldv,t,&ldt,c,&ldc,work,&info,len0,len1)
+    callprotoargument char*,char*,F_INT*,F_INT*,F_INT*,F_INT*,<ctype>*,F_INT*,<ctype>*,F_INT*,<ctype>*,F_INT*,<ctype>*,F_INT*,F_INT,F_INT
 
     character optional,intent(in),check(*side=='L'||*side=='R'):: side = 'L'
     character optional,intent(in),check(*trans=='N'||*trans==<'T','T','C','C'>):: trans = 'N'
@@ -1087,6 +1147,8 @@ subroutine <prefix>gemqrt(side,trans,m,n,k,nb,v,ldv,t,ldt,c,ldc,work,info)
     <ftype> dimension((side[0]=='L'?n:m)*nb),intent(hide,cache):: work
     integer intent(out):: info
 
+    integer intent(hide) :: len0 = 1
+    integer intent(hide) :: len1 = 1
 end subroutine <prefix>gemqrt
 
 subroutine <prefix>tpqrt(m,n,l,nb,a,lda,b,ldb,t,ldt,work,info)
@@ -1116,7 +1178,7 @@ subroutine <prefix>tpqrt(m,n,l,nb,a,lda,b,ldb,t,ldt,work,info)
 
 end subroutine <prefix>tpqrt
 
-subroutine <prefix>tpmqrt(side,trans,m,n,k,l,nb,v,ldv,t,ldt,a,lda,b,ldb,work,info)
+subroutine <prefix>tpmqrt(side,trans,m,n,k,l,nb,v,ldv,t,ldt,a,lda,b,ldb,work,info,len0,len1)
     ! a,b,info = tpmqrt(side,trans,l,v,t,a,b,[overwrite_a=0,overwrite_b=0])
     !
     ! Multiplies a general matrix C by the orthogonal matrix Q defined by the
@@ -1126,8 +1188,8 @@ subroutine <prefix>tpmqrt(side,trans,m,n,k,l,nb,v,ldv,t,ldt,a,lda,b,ldb,work,inf
     ! multiplied by Q, its transpose (for real matrices), or its adjoint (for
     ! complex matrices) from the left or right.
 
-    callstatement (*f2py_func)(side,trans,&m,&n,&k,&l,&nb,v,&ldv,t,&ldt,a,&lda,b,&ldb,work,&info)
-    callprotoargument char*,char*,F_INT*,F_INT*,F_INT*,F_INT*,F_INT*,<ctype>*,F_INT*,<ctype>*,F_INT*,<ctype>*,F_INT*,<ctype>*,F_INT*,<ctype>*,F_INT*
+    callstatement (*f2py_func)(side,trans,&m,&n,&k,&l,&nb,v,&ldv,t,&ldt,a,&lda,b,&ldb,work,&info,len0,len1)
+    callprotoargument char*,char*,F_INT*,F_INT*,F_INT*,F_INT*,F_INT*,<ctype>*,F_INT*,<ctype>*,F_INT*,<ctype>*,F_INT*,<ctype>*,F_INT*,<ctype>*,F_INT*,F_INT,F_INT
 
     character optional,intent(in),check(*side=='L'||*side=='R'):: side = 'L'
     character optional,intent(in),check(*trans=='N'||*trans==<'T','T','C','C'>):: trans = 'N'
@@ -1147,9 +1209,11 @@ subroutine <prefix>tpmqrt(side,trans,m,n,k,l,nb,v,ldv,t,ldt,a,lda,b,ldb,work,inf
     <ftype> dimension((side[0]=='L'?n:m)*nb),intent(hide,cache):: work
     integer intent(out):: info
 
+    integer intent(hide) :: len0 = 1
+    integer intent(hide) :: len1 = 1
 end subroutine <prefix>tpmqrt
 
-subroutine <prefix><or,or,un,un>mrz(side,trans,m,n,k,l,a,lda,nt,tau,c,ldc,work,lwork,info)
+subroutine <prefix><or,or,un,un>mrz(side,trans,m,n,k,l,a,lda,nt,tau,c,ldc,work,lwork,info,len0,len1)
     !
     ! ?OR/UNMRZ overwrites the general complex M-by-N matrix C with
     !
@@ -1165,8 +1229,8 @@ subroutine <prefix><or,or,un,un>mrz(side,trans,m,n,k,l,a,lda,nt,tau,c,ldc,work,l
     ! as returned by ?TZRZF. Q is of order M if SIDE = 'L' and of order N
     ! if SIDE = 'R'.
     !
-    callstatement (*f2py_func)(side,trans,&m,&n,&k,&l,a,&lda,tau,c,&ldc,work,&lwork,&info)
-    callprotoargument char*,char*,F_INT*,F_INT*,F_INT*,F_INT*,<ctype>*,F_INT*,<ctype>*,<ctype>*,F_INT*,<ctype>*,F_INT*,F_INT*
+    callstatement (*f2py_func)(side,trans,&m,&n,&k,&l,a,&lda,tau,c,&ldc,work,&lwork,&info,len0,len1)
+    callprotoargument char*,char*,F_INT*,F_INT*,F_INT*,F_INT*,<ctype>*,F_INT*,<ctype>*,<ctype>*,F_INT*,<ctype>*,F_INT*,F_INT*,F_INT,F_INT
 
     character optional,intent(in),check(*side=='L'||*side=='R'):: side = 'L'
     character optional,intent(in),check(*trans=='N'||*trans==<'T','T','C','C'>):: trans = 'N'
@@ -1184,9 +1248,11 @@ subroutine <prefix><or,or,un,un>mrz(side,trans,m,n,k,l,a,lda,nt,tau,c,ldc,work,l
     integer optional,intent(in),depend(side,m,n),check(lwork>=(*side=='L'?n:m)||lwork==-1):: lwork=MAX((side[0]=='L'?n:m),1)
     integer intent(out):: info
 
+    integer intent(hide) :: len0 = 1
+    integer intent(hide) :: len1 = 1
 end subroutine <prefix><or,or,un,un>mrz
 
-subroutine <prefix><or,or,un,un>mrz_lwork(side,trans,m,n,k,l,a,lda,tau,c,ldc,work,lwork,info)
+subroutine <prefix><or,or,un,un>mrz_lwork(side,trans,m,n,k,l,a,lda,tau,c,ldc,work,lwork,info,len0,len1)
     !
     ! ?OR/UNMRZ overwrites the general complex M-by-N matrix C with
     !
@@ -1203,8 +1269,8 @@ subroutine <prefix><or,or,un,un>mrz_lwork(side,trans,m,n,k,l,a,lda,tau,c,ldc,wor
     ! if SIDE = 'R'.
     !
     fortranname <prefix><or,or,un,un>mrz
-    callstatement (*f2py_func)(side,trans,&m,&n,&k,&l,&a,&lda,&tau,&c,&ldc,&work,&lwork,&info)
-    callprotoargument char*,char*,F_INT*,F_INT*,F_INT*,F_INT*,<ctype>*,F_INT*,<ctype>*,<ctype>*,F_INT*,<ctype>*,F_INT*,F_INT*
+    callstatement (*f2py_func)(side,trans,&m,&n,&k,&l,&a,&lda,&tau,&c,&ldc,&work,&lwork,&info,len0,len1)
+    callprotoargument char*,char*,F_INT*,F_INT*,F_INT*,F_INT*,<ctype>*,F_INT*,<ctype>*,<ctype>*,F_INT*,<ctype>*,F_INT*,F_INT*,F_INT,F_INT
 
     character optional,intent(in),check(*side=='L'||*side=='R'):: side = 'L'
     character optional,intent(in),check(*trans=='N'||*trans==<'T','T','C','C'>):: trans = 'N'
@@ -1221,6 +1287,8 @@ subroutine <prefix><or,or,un,un>mrz_lwork(side,trans,m,n,k,l,a,lda,tau,c,ldc,wor
     integer intent(hide):: lwork=-1
     integer intent(out):: info
 
+    integer intent(hide) :: len0 = 1
+    integer intent(hide) :: len1 = 1
 end subroutine <prefix><or,or,un,un>mrz_lwork
 
 subroutine <prefix2>orgrq(m,n,k,a,tau,work,lwork,info)
@@ -1267,7 +1335,7 @@ subroutine <prefix2c>ungrq(m,n,k,a,tau,work,lwork,info)
 
 end subroutine <prefix2c>ungrq
 
-subroutine <prefix>trtri(n,c,info,lower,unitdiag)
+subroutine <prefix>trtri(n,c,info,lower,unitdiag,len0,len1)
 
     ! inv_c,info = trtri(c,lower=0,unitdiag=1,overwrite_c=0)
     ! Compute C inverse C^-1 where
@@ -1276,8 +1344,8 @@ subroutine <prefix>trtri(n,c,info,lower,unitdiag)
     ! C is non-unit triangular matrix if unitdiag = 0
     ! C is unit triangular matrix if unitdiag = 1
 
-    callstatement (*f2py_func)((lower?"L":"U"),(unitdiag?"U":"N"),&n,c,&n,&info)
-    callprotoargument char*,char*,F_INT*,<ctype>*,F_INT*,F_INT*
+    callstatement (*f2py_func)((lower?"L":"U"),(unitdiag?"U":"N"),&n,c,&n,&info,len0,len1)
+    callprotoargument char*,char*,F_INT*,<ctype>*,F_INT*,F_INT*,F_INT,F_INT
 
     integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
     integer optional,intent(in),check(unitdiag==0||unitdiag==1) :: unitdiag = 0
@@ -1287,9 +1355,11 @@ subroutine <prefix>trtri(n,c,info,lower,unitdiag)
     check(shape(c,0)==shape(c,1)) :: c
     integer intent(out) :: info
 
+    integer intent(hide) :: len0 = 1
+    integer intent(hide) :: len1 = 1
 end subroutine <prefix>trtri
 
-subroutine <prefix>trsyl(trana, tranb, isgn, m, n, a, lda, b, ldb, c, ldc, scale, info)
+subroutine <prefix>trsyl(trana, tranb, isgn, m, n, a, lda, b, ldb, c, ldc, scale, info,len0,len1)
     ! x,scale,info = trsyl(trana='N', tranb='N', isgn, a, b, c)
     !
     ! Solves the real Sylvester matrix equation:
@@ -1312,8 +1382,8 @@ subroutine <prefix>trsyl(trana, tranb, isgn, m, n, a, lda, b, ldb, c, ldc, scale
     !      1: A and B have common or very close eigenvalues; perturbed values
     !         were used to solve the equation
 
-    callstatement (*f2py_func)(trana,tranb,&isgn,&m,&n,a,&lda,b,&ldb,c,&ldc,&scale,&info)
-    callprotoargument char*,char*,F_INT*,F_INT*,F_INT*,<ctype>*,F_INT*,<ctype>*,F_INT*,<ctype>*,F_INT*,<ctypereal>*,F_INT*
+    callstatement (*f2py_func)(trana,tranb,&isgn,&m,&n,a,&lda,b,&ldb,c,&ldc,&scale,&info,len0,len1)
+    callprotoargument char*,char*,F_INT*,F_INT*,F_INT*,<ctype>*,F_INT*,<ctype>*,F_INT*,<ctype>*,F_INT*,<ctypereal>*,F_INT*,F_INT,F_INT
 
     character optional,intent(in),check(*trana=='N'||*trana=='T'||*trana=='C'):: trana='N'
     character optional,intent(in),check(*tranb=='N'||*tranb=='T'||*tranb=='C'):: tranb='N'
@@ -1338,13 +1408,15 @@ subroutine <prefix>trsyl(trana, tranb, isgn, m, n, a, lda, b, ldb, c, ldc, scale
 
     integer intent(out) :: info
 
+    integer intent(hide) :: len0 = 1
+    integer intent(hide) :: len1 = 1
 end subroutine <prefix>trsyl
 
-subroutine <prefix2c>hbevd(ab,compute_v,lower,n,ldab,kd,w,z,ldz,work,lwork,rwork,lrwork,iwork,liwork,info)
+subroutine <prefix2c>hbevd(ab,compute_v,lower,n,ldab,kd,w,z,ldz,work,lwork,rwork,lrwork,iwork,liwork,info,len0,len1)
     ! in :Band:zubevd.f
 
-    callstatement (*f2py_func)((compute_v?"V":"N"),(lower?"L":"U"),&n,&kd,ab,&ldab,w,z,&ldz,work,&lwork,rwork,&lrwork,iwork,&liwork,&info)
-    callprotoargument char*,char*,F_INT*,F_INT*,<ctype2c>*,F_INT*,<ctype2>*,<ctype2c>*,F_INT*,<ctype2c>*,F_INT*,<ctype2>*,F_INT*,F_INT*,F_INT*,F_INT*
+    callstatement (*f2py_func)((compute_v?"V":"N"),(lower?"L":"U"),&n,&kd,ab,&ldab,w,z,&ldz,work,&lwork,rwork,&lrwork,iwork,&liwork,&info,len0,len1)
+    callprotoargument char*,char*,F_INT*,F_INT*,<ctype2c>*,F_INT*,<ctype2>*,<ctype2c>*,F_INT*,<ctype2c>*,F_INT*,<ctype2>*,F_INT*,F_INT*,F_INT*,F_INT*,F_INT,F_INT
 
     ! Remark: if ab is fortran contiguous on input
     !         and overwrite_ab=1  ab will be overwritten.
@@ -1379,12 +1451,14 @@ subroutine <prefix2c>hbevd(ab,compute_v,lower,n,ldab,kd,w,z,ldz,work,lwork,rwork
     integer optional, check(liwork>=(compute_v?3+5*n:1)),depend(n) :: liwork=(compute_v?3+5*n:1)
     integer intent(hide),dimension(liwork),depend(liwork) :: iwork
 
+    integer intent(hide) :: len0 = 1
+    integer intent(hide) :: len1 = 1
 end subroutine <prefix2c>hbevd
 
-subroutine <prefix2c>hbevx(ab,ldab,compute_v,range,lower,n,kd,q,ldq,vl,vu,il,iu,abstol,w,z,m,mmax,ldz,work,rwork,iwork,ifail,info) ! in :Band:dsbevx.f
+subroutine <prefix2c>hbevx(ab,ldab,compute_v,range,lower,n,kd,q,ldq,vl,vu,il,iu,abstol,w,z,m,mmax,ldz,work,rwork,iwork,ifail,info,len0,len1,len2) ! in :Band:dsbevx.f
 
-    callstatement (*f2py_func)((compute_v?"V":"N"),(range>0?(range==1?"V":"I"):"A"),(lower?"L":"U"),&n,&kd,ab,&ldab,q,&ldq,&vl,&vu,&il,&iu,&abstol,&m,w,z,&ldz,work,rwork,iwork,ifail,&info)
-    callprotoargument char*,char*,char*,F_INT*,F_INT*,<ctype2c>*,F_INT*,<ctype2c>*,F_INT*,<ctype2>*,<ctype2>*,F_INT*,F_INT*,<ctype2>*,F_INT*,<ctype2>*,<ctype2c>*,F_INT*,<ctype2c>*,<ctype2>*,F_INT*,F_INT*,F_INT*
+    callstatement (*f2py_func)((compute_v?"V":"N"),(range>0?(range==1?"V":"I"):"A"),(lower?"L":"U"),&n,&kd,ab,&ldab,q,&ldq,&vl,&vu,&il,&iu,&abstol,&m,w,z,&ldz,work,rwork,iwork,ifail,&info,len0,len1,len2)
+    callprotoargument char*,char*,char*,F_INT*,F_INT*,<ctype2c>*,F_INT*,<ctype2c>*,F_INT*,<ctype2>*,<ctype2>*,F_INT*,F_INT*,<ctype2>*,F_INT*,<ctype2>*,<ctype2c>*,F_INT*,<ctype2c>*,<ctype2>*,F_INT*,F_INT*,F_INT*,F_INT,F_INT,F_INT
 
     integer optional,intent(in):: compute_v = 1
     check(compute_v==1||compute_v==0) compute_v
@@ -1452,6 +1526,9 @@ subroutine <prefix2c>hbevx(ab,ldab,compute_v,range,lower,n,kd,q,ldq,vl,vu,il,iu,
     integer dimension((compute_v?n:1)),depend(n,compute_v),intent(out) :: ifail
     integer intent(out):: info
 
+    integer intent(hide) :: len0 = 1
+    integer intent(hide) :: len1 = 1
+    integer intent(hide) :: len2 = 1
 end subroutine <prefix2c>hbevx
 
 subroutine <prefix>gglse(m,n,p,a,lda,b,ldb,c,d,x,work,lwork,info)
@@ -1521,7 +1598,7 @@ subroutine <prefix>gglse_lwork(m,n,p,a,lda,b,ldb,c,d,x,work,lwork,info)
 
 end subroutine <prefix>gglse_lwork
 
-subroutine <prefix>ppcon(lower,n,ap,anorm,rcond,work,irwork,info,L)
+subroutine <prefix>ppcon(lower,n,ap,anorm,rcond,work,irwork,info,L,len0)
     ! ?PPCON estimates the reciprocal of the condition number (in the
     ! 1-norm) of a symmetric/Hermitian positive definite packed matrix using
     ! the Cholesky factorization A = U**T*U or A = L*L**T computed by
@@ -1530,8 +1607,8 @@ subroutine <prefix>ppcon(lower,n,ap,anorm,rcond,work,irwork,info,L)
     ! An estimate is obtained for norm(inv(A)), and the reciprocal of the
     ! condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).
     threadsafe
-    callstatement (*f2py_func)((lower?"L":"U"),&n,ap,&anorm,&rcond,work,irwork,&info)
-    callprotoargument char*,F_INT*,<ctype>*,<ctypereal>*,<ctypereal>*,<ctype>*,<F_INT,F_INT,float,double>*,F_INT*
+    callstatement (*f2py_func)((lower?"L":"U"),&n,ap,&anorm,&rcond,work,irwork,&info,len0)
+    callprotoargument char*,F_INT*,<ctype>*,<ctypereal>*,<ctypereal>*,<ctype>*,<F_INT,F_INT,float,double>*,F_INT*,F_INT
 
     integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
     integer intent(in),check(n>=0) :: n
@@ -1543,9 +1620,10 @@ subroutine <prefix>ppcon(lower,n,ap,anorm,rcond,work,irwork,info,L)
     <integer,integer,real, double precision> dimension(n), intent(hide,cache),depend(n) :: irwork
     integer intent(out):: info
 
+    integer intent(hide) :: len0 = 1
 end subroutine <prefix>ppcon
 
-subroutine <prefix>ppsv(lower,n,nrhs,ap,b,ldb,info,L)
+subroutine <prefix>ppsv(lower,n,nrhs,ap,b,ldb,info,L,len0)
     ! DPPSV computes the solution to a real system of linear equations
     !    A * X = B,
     ! where A is an N-by-N symmetric positive definite matrix stored in
@@ -1558,8 +1636,8 @@ subroutine <prefix>ppsv(lower,n,nrhs,ap,b,ldb,info,L)
     ! matrix.  The factored form of A is then used to solve the system of
     ! equations A * X = B.
     threadsafe
-    callstatement (*f2py_func)((lower?"L":"U"),&n,&nrhs,ap,b,&ldb,&info)
-    callprotoargument char*,F_INT*,F_INT*,<ctype>*,<ctype>*,F_INT*,F_INT*
+    callstatement (*f2py_func)((lower?"L":"U"),&n,&nrhs,ap,b,&ldb,&info,len0)
+    callprotoargument char*,F_INT*,F_INT*,<ctype>*,<ctype>*,F_INT*,F_INT*,F_INT
 
     integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
     integer intent(in),check(n>=0) :: n
@@ -1570,9 +1648,10 @@ subroutine <prefix>ppsv(lower,n,nrhs,ap,b,ldb,info,L)
     <ftype> dimension(ldb,nrhs),intent(in,out,copy,out=x) :: b
     integer intent(out) :: info
 
+    integer intent(hide) :: len0 = 1
 end subroutine <prefix>ppsv
 
-subroutine <prefix>pptrf(lower,n,ap,info,L)
+subroutine <prefix>pptrf(lower,n,ap,info,L,len0)
     ! ?PPTRF computes the Cholesky factorization of a symmetric/hermitian
     ! positive definite matrix A stored in packed format.
     !
@@ -1581,8 +1660,8 @@ subroutine <prefix>pptrf(lower,n,ap,info,L)
     !    A = L  * L**T,  if UPLO = 'L',
     ! where U is an upper triangular matrix and L is lower triangular.
     threadsafe
-    callstatement (*f2py_func)((lower?"L":"U"),&n,ap,&info)
-    callprotoargument char*,F_INT*,<ctype>*,F_INT*
+    callstatement (*f2py_func)((lower?"L":"U"),&n,ap,&info,len0)
+    callprotoargument char*,F_INT*,<ctype>*,F_INT*,F_INT
 
     integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
     integer intent(in),check(n>=0) :: n
@@ -1590,15 +1669,16 @@ subroutine <prefix>pptrf(lower,n,ap,info,L)
     integer intent(hide),depend(ap,n),check(L>=(n*(n+1)/2)) :: L = len(ap)
     integer intent(out) :: info
 
+    integer intent(hide) :: len0 = 1
 end subroutine<prefix>pptrf
 
-subroutine <prefix>pptri(lower,n,ap,info,L)
+subroutine <prefix>pptri(lower,n,ap,info,L,len0)
     ! ?PPTRI computes the inverse of a symmetric/Hermitian positive definite
     ! matrix A using the Cholesky factorization A = U**T*U or A = L*L**T
     ! computed by ?PPTRF.
     threadsafe
-    callstatement (*f2py_func)((lower?"L":"U"),&n,ap,&info)
-    callprotoargument char*,F_INT*,<ctype>*,F_INT*
+    callstatement (*f2py_func)((lower?"L":"U"),&n,ap,&info,len0)
+    callprotoargument char*,F_INT*,<ctype>*,F_INT*,F_INT
 
     integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
     integer intent(in),check(n>=0) :: n
@@ -1606,15 +1686,16 @@ subroutine <prefix>pptri(lower,n,ap,info,L)
     integer intent(hide),depend(ap,n),check(L>=(n*(n+1)/2)) :: L = len(ap)
     integer intent(out) :: info
 
+    integer intent(hide) :: len0 = 1
 end subroutine<prefix>pptri
 
-subroutine <prefix>pptrs(lower,n,nrhs,ap,b,ldb,info,L)
+subroutine <prefix>pptrs(lower,n,nrhs,ap,b,ldb,info,L,len0)
     ! DPPTRS solves a system of linear equations A*X = B with a symmetric
     ! positive definite matrix A in packed storage using the Cholesky
     ! factorization A = U**T*U or A = L*L**T computed by DPPTRF.
     threadsafe
-    callstatement (*f2py_func)((lower?"L":"U"),&n,&nrhs,ap,b,&ldb,&info)
-    callprotoargument char*,F_INT*,F_INT*,<ctype>*,<ctype>*,F_INT*,F_INT*
+    callstatement (*f2py_func)((lower?"L":"U"),&n,&nrhs,ap,b,&ldb,&info,len0)
+    callprotoargument char*,F_INT*,F_INT*,<ctype>*,<ctype>*,F_INT*,F_INT*,F_INT
 
     integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
     integer intent(in),check(n>=0) :: n
@@ -1625,16 +1706,17 @@ subroutine <prefix>pptrs(lower,n,nrhs,ap,b,ldb,info,L)
     <ftype> dimension(ldb,nrhs),intent(in,out,copy,out=x) :: b
     integer intent(out) :: info
 
+    integer intent(hide) :: len0 = 1
 end subroutine <prefix>pptrs
 
-subroutine <prefix2>sbev(ab,compute_v,lower,n,ldab,kd,w,z,ldz,work,info)
+subroutine <prefix2>sbev(ab,compute_v,lower,n,ldab,kd,w,z,ldz,work,info,len0,len1)
     ! in :Band:dsbev.f
     ! principally <s,d>sbevd does the same, and are recommended for use.
     ! (see man dsbevd)
 
-    callstatement (*f2py_func)((compute_v?"V":"N"),(lower?"L":"U"),&n,&kd,ab,&ldab,w,z,&ldz,work,&info)
+    callstatement (*f2py_func)((compute_v?"V":"N"),(lower?"L":"U"),&n,&kd,ab,&ldab,w,z,&ldz,work,&info,len0,len1)
 
-    callprotoargument char*,char*,F_INT*,F_INT*,<ctype2>*,F_INT*,<ctype2>*,<ctype2>*,F_INT*,<ctype2>*,F_INT*
+    callprotoargument char*,char*,F_INT*,F_INT*,<ctype2>*,F_INT*,<ctype2>*,<ctype2>*,F_INT*,<ctype2>*,F_INT*,F_INT,F_INT
 
     ! Remark: if ab is fortran contiguous on input
     !         and overwrite_ab=1  ab will be overwritten.
@@ -1657,12 +1739,14 @@ subroutine <prefix2>sbev(ab,compute_v,lower,n,ldab,kd,w,z,ldz,work,info)
     <ftype2> dimension(MAX(1,3*n-1)),intent(hide),depend(n) :: work
     integer intent(out)::info
 
+    integer intent(hide) :: len0 = 1
+    integer intent(hide) :: len1 = 1
 end subroutine <prefix2>sbev
 
-subroutine <prefix2>sbevd(ab,compute_v,lower,n,ldab,kd,w,z,ldz,work,lwork,iwork,liwork,info)
+subroutine <prefix2>sbevd(ab,compute_v,lower,n,ldab,kd,w,z,ldz,work,lwork,iwork,liwork,info,len0,len1)
     ! in :Band:dsbevd.f
-    callstatement (*f2py_func)((compute_v?"V":"N"),(lower?"L":"U"),&n,&kd,ab,&ldab,w,z,&ldz,work,&lwork,iwork,&liwork,&info)
-    callprotoargument char*,char*,F_INT*,F_INT*,<ctype2>*,F_INT*,<ctype2>*,<ctype2>*,F_INT*,<ctype2>*,F_INT*,F_INT*,F_INT*,F_INT*
+    callstatement (*f2py_func)((compute_v?"V":"N"),(lower?"L":"U"),&n,&kd,ab,&ldab,w,z,&ldz,work,&lwork,iwork,&liwork,&info,len0,len1)
+    callprotoargument char*,char*,F_INT*,F_INT*,<ctype2>*,F_INT*,<ctype2>*,<ctype2>*,F_INT*,<ctype2>*,F_INT*,F_INT*,F_INT*,F_INT*,F_INT,F_INT
 
     ! Remark: if ab is fortran contiguous on input
     !         and overwrite_ab=1  ab will be overwritten.
@@ -1690,12 +1774,14 @@ subroutine <prefix2>sbevd(ab,compute_v,lower,n,ldab,kd,w,z,ldz,work,lwork,iwork,
     integer optional,check(liwork>=(compute_v?3+5*n:1)),depend(n) :: liwork=(compute_v?3+5*n:1)
     integer intent(hide),dimension(liwork),depend(liwork) :: iwork
 
+    integer intent(hide) :: len0 = 1
+    integer intent(hide) :: len1 = 1
 end subroutine <prefix2>sbevd
 
-subroutine <prefix2>sbevx(ab,ldab,compute_v,range,lower,n,kd,q,ldq,vl,vu,il,iu,abstol,w,z,m,mmax,ldz,work,iwork,ifail,info) ! in :Band:dsbevx.f
+subroutine <prefix2>sbevx(ab,ldab,compute_v,range,lower,n,kd,q,ldq,vl,vu,il,iu,abstol,w,z,m,mmax,ldz,work,iwork,ifail,info,len0,len1,len2) ! in :Band:dsbevx.f
 
-    callstatement (*f2py_func)((compute_v?"V":"N"),(range>0?(range==1?"V":"I"):"A"),(lower?"L":"U"),&n,&kd,ab,&ldab,q,&ldq,&vl,&vu,&il,&iu,&abstol,&m,w,z,&ldz,work,iwork,ifail,&info)
-    callprotoargument char*,char*,char*,F_INT*,F_INT*,<ctype2>*,F_INT*,<ctype2>*,F_INT*,<ctype2>*,<ctype2>*,F_INT*,F_INT*,<ctype2>*,F_INT*,<ctype2>*,<ctype2>*,F_INT*,<ctype2>*, F_INT*,F_INT*,F_INT*
+    callstatement (*f2py_func)((compute_v?"V":"N"),(range>0?(range==1?"V":"I"):"A"),(lower?"L":"U"),&n,&kd,ab,&ldab,q,&ldq,&vl,&vu,&il,&iu,&abstol,&m,w,z,&ldz,work,iwork,ifail,&info,len0,len1,len2)
+    callprotoargument char*,char*,char*,F_INT*,F_INT*,<ctype2>*,F_INT*,<ctype2>*,F_INT*,<ctype2>*,<ctype2>*,F_INT*,F_INT*,<ctype2>*,F_INT*,<ctype2>*,<ctype2>*,F_INT*,<ctype2>*, F_INT*,F_INT*,F_INT*,F_INT,F_INT,F_INT
 
     integer optional,intent(in):: compute_v = 1
     check(compute_v==1||compute_v==0) compute_v
@@ -1765,14 +1851,17 @@ subroutine <prefix2>sbevx(ab,ldab,compute_v,range,lower,n,kd,q,ldq,vl,vu,il,iu,a
     integer dimension((compute_v?n:1)),depend(n,compute_v),intent(out) :: ifail
     integer intent(out):: info
 
+    integer intent(hide) :: len0 = 1
+    integer intent(hide) :: len1 = 1
+    integer intent(hide) :: len2 = 1
 end subroutine <prefix2>sbevx
 
-subroutine <prefix2>stebz(d,e,range,vl,vu,il,iu,tol,order,n,work,iwork,m,nsplit,w,iblock,isplit,info)
+subroutine <prefix2>stebz(d,e,range,vl,vu,il,iu,tol,order,n,work,iwork,m,nsplit,w,iblock,isplit,info,len0,len1)
     ! computes all or selected eigenvalues of a real, symmetric tridiagonal
     ! matrix.
 
-    callstatement (*f2py_func)((range>0?(range==1?"V":"I"):"A"),order,&n,&vl,&vu,&il,&iu,&tol,d,e,&m,&nsplit,w,iblock,isplit,work,iwork,&info)
-    callprotoargument char*,char*,F_INT*,<ctype2>*,<ctype2>*,F_INT*,F_INT*,<ctype2>*,<ctype2>*,<ctype2>*,F_INT*,F_INT*,<ctype2>*,F_INT*,F_INT*,<ctype2>*,F_INT*,F_INT*
+    callstatement (*f2py_func)((range>0?(range==1?"V":"I"):"A"),order,&n,&vl,&vu,&il,&iu,&tol,d,e,&m,&nsplit,w,iblock,isplit,work,iwork,&info,len0,len1)
+    callprotoargument char*,char*,F_INT*,<ctype2>*,<ctype2>*,F_INT*,F_INT*,<ctype2>*,<ctype2>*,<ctype2>*,F_INT*,F_INT*,<ctype2>*,F_INT*,F_INT*,<ctype2>*,F_INT*,F_INT*,F_INT,F_INT
 
     <ftype2> dimension(n),intent(in) :: d
     <ftype2> dimension(n-1),depend(n),intent(in) :: e
@@ -1793,6 +1882,8 @@ subroutine <prefix2>stebz(d,e,range,vl,vu,il,iu,tol,order,n,work,iwork,m,nsplit,
     integer dimension(n),depend(n),intent(out) :: isplit
     integer intent(out) :: info
 
+    integer intent(hide) :: len0 = 1
+    integer intent(hide) :: len1 = 1
 end subroutine <prefix2>stebz
 
 subroutine <prefix2>sterf(d,e,n,info)
@@ -1831,11 +1922,11 @@ subroutine <prefix2>stein(d,e,w,iblock,isplit,m,n,z,ldz,work,iwork,ifail,info)
 
 end subroutine <prefix2>stein
 
-subroutine <prefix2>stemr(d,e,range,vl,vu,il,iu,compute_v,n,m,w,z,ldz,nzc,isuppz,tryrac,work,lwork,iwork,liwork,info)
+subroutine <prefix2>stemr(d,e,range,vl,vu,il,iu,compute_v,n,m,w,z,ldz,nzc,isuppz,tryrac,work,lwork,iwork,liwork,info,len0,len1)
     ! computes all eigenvalues of a real, symmetric tridiagonal matrix.
 
-    callstatement (*f2py_func)((compute_v?"V":"N"),(range>0?(range==1?"V":"I"):"A"),&n,d,e,&vl,&vu,&il,&iu,&m,w,z,&ldz,&nzc,isuppz,&tryrac,work,&lwork,iwork,&liwork,&info)
-    callprotoargument char*,char*,F_INT*,<ctype2>*,<ctype2>*,<ctype2>*,<ctype2>*,F_INT*,F_INT*,F_INT*,<ctype2>*,<ctype2>*,F_INT*,F_INT*,F_INT*,F_INT*,<ctype2>*,F_INT*,F_INT*,F_INT*,F_INT*
+    callstatement (*f2py_func)((compute_v?"V":"N"),(range>0?(range==1?"V":"I"):"A"),&n,d,e,&vl,&vu,&il,&iu,&m,w,z,&ldz,&nzc,isuppz,&tryrac,work,&lwork,iwork,&liwork,&info,len0,len1)
+    callprotoargument char*,char*,F_INT*,<ctype2>*,<ctype2>*,<ctype2>*,<ctype2>*,F_INT*,F_INT*,F_INT*,<ctype2>*,<ctype2>*,F_INT*,F_INT*,F_INT*,F_INT*,<ctype2>*,F_INT*,F_INT*,F_INT*,F_INT*,F_INT,F_INT
 
     <ftype2> dimension(n),intent(in,copy) :: d
     <ftype2> dimension(n),intent(in) :: e
@@ -1859,14 +1950,16 @@ subroutine <prefix2>stemr(d,e,range,vl,vu,il,iu,compute_v,n,m,w,z,ldz,nzc,isuppz
     integer dimension(liwork),depend(liwork),intent(hide) :: iwork
     integer intent(out) :: info
 
+    integer intent(hide) :: len0 = 1
+    integer intent(hide) :: len1 = 1
 end subroutine <prefix2>stemr
 
-subroutine <prefix2>stemr_lwork(d,e,range,vl,vu,il,iu,compute_v,n,m,w,z,ldz,nzc,isuppz,tryrac,work,lwork,iwork,liwork,info)
+subroutine <prefix2>stemr_lwork(d,e,range,vl,vu,il,iu,compute_v,n,m,w,z,ldz,nzc,isuppz,tryrac,work,lwork,iwork,liwork,info,len0,len1)
     ! LWORK=-1, LIWORK=-1 call for STEMR
 
     fortranname <prefix2c>stemr
-    callstatement (*f2py_func)((compute_v?"V":"N"),(range>0?(range==1?"V":"I"):"A"),&n,d,e,&vl,&vu,&il,&iu,&m,w,z,&ldz,&nzc,isuppz,&tryrac,&work,&lwork,&iwork,&liwork,&info)
-    callprotoargument char*,char*,F_INT*,<ctype2>*,<ctype2>*,<ctype2>*,<ctype2>*,F_INT*,F_INT*,F_INT*,<ctype2>*,<ctype2>*,F_INT*,F_INT*,F_INT*,F_INT*,<ctype2>*,F_INT*,F_INT*,F_INT*,F_INT*
+    callstatement (*f2py_func)((compute_v?"V":"N"),(range>0?(range==1?"V":"I"):"A"),&n,d,e,&vl,&vu,&il,&iu,&m,w,z,&ldz,&nzc,isuppz,&tryrac,&work,&lwork,&iwork,&liwork,&info,len0,len1)
+    callprotoargument char*,char*,F_INT*,<ctype2>*,<ctype2>*,<ctype2>*,<ctype2>*,F_INT*,F_INT*,F_INT*,<ctype2>*,<ctype2>*,F_INT*,F_INT*,F_INT*,F_INT*,<ctype2>*,F_INT*,F_INT*,F_INT*,F_INT*,F_INT,F_INT
 
     <ftype2> dimension(n),intent(in,copy) :: d
     <ftype2> dimension(n),intent(in,copy) :: e
@@ -1889,14 +1982,16 @@ subroutine <prefix2>stemr_lwork(d,e,range,vl,vu,il,iu,compute_v,n,m,w,z,ldz,nzc,
     integer intent(hide) :: liwork = -1
     integer intent(out) :: iwork
     integer intent(out) :: info
+    integer intent(hide) :: len0 = 1
+    integer intent(hide) :: len1 = 1
 end subroutine <prefix2>stemr_lwork
 
-subroutine <prefix2>stev(d,e,compute_v,n,z,ldz,work,info)
+subroutine <prefix2>stev(d,e,compute_v,n,z,ldz,work,info,len0)
     ! computes all eigenvalues, and, optionally eigvectors of a real,
     ! symmetric tridiagonal matrix.
 
-    callstatement (*f2py_func)((compute_v?"V":"N"),&n,d,e,z,&ldz,work,&info)
-    callprotoargument char*,F_INT*,<ctype2>*,<ctype2>*,<ctype2>*,F_INT*,<ctype2>*,F_INT*
+    callstatement (*f2py_func)((compute_v?"V":"N"),&n,d,e,z,&ldz,work,&info,len0)
+    callprotoargument char*,F_INT*,<ctype2>*,<ctype2>*,<ctype2>*,F_INT*,<ctype2>*,F_INT*,F_INT
 
     integer optional,intent(in):: compute_v = 1
     <ftype2> dimension(n),intent(in,out,copy,out=vals) :: d
@@ -1907,9 +2002,10 @@ subroutine <prefix2>stev(d,e,compute_v,n,z,ldz,work,info)
     <ftype2> dimension((compute_v?MAX(1,2*n-2):1)),depend(n),intent(hide) :: work
     integer intent(out) :: info
 
+    integer intent(hide) :: len0 = 1
 end subroutine <prefix2>stev
 
-subroutine <prefix><s,s,h,h>frk(transr,uplo,trans,n,k,nt,ka,alpha,a,lda,beta,c)
+subroutine <prefix><s,s,h,h>frk(transr,uplo,trans,n,k,nt,ka,alpha,a,lda,beta,c,len0,len1,len2)
     !
     ! (S/D)SFRK - (C/Z)HFRK performs one of the Sym/Hermitian rank--k operations
     !
@@ -1919,8 +2015,8 @@ subroutine <prefix><s,s,h,h>frk(transr,uplo,trans,n,k,nt,ka,alpha,a,lda,beta,c)
     ! matrix and A is an n--by--k matrix in the first case and a k--by--n
     ! matrix in the second case.
 
-    callstatement (*f2py_func)(transr,uplo,trans,&n,&k,&alpha,a,&lda,&beta,c)
-    callprotoargument char*,char*,char*,F_INT*,F_INT*,<ctypereal>*,<ctype>*,F_INT*,<ctypereal>*,<ctype>*
+    callstatement (*f2py_func)(transr,uplo,trans,&n,&k,&alpha,a,&lda,&beta,c,len0,len1,len2)
+    callprotoargument char*,char*,char*,F_INT*,F_INT*,<ctypereal>*,<ctype>*,F_INT*,<ctypereal>*,<ctype>*,F_INT,F_INT,F_INT
 
     character optional,intent(in),check(*transr=='N'||*transr==<'T','T','C','C'>):: transr = 'N'
     character optional,intent(in),check(*uplo=='U'||*uplo=='L'):: uplo = 'U'
@@ -1935,16 +2031,19 @@ subroutine <prefix><s,s,h,h>frk(transr,uplo,trans,n,k,nt,ka,alpha,a,lda,beta,c)
     <ftype> dimension(nt),intent(in,out,copy,out=cout):: c
     integer intent(hide),depend(c),check(nt==(n*(n+1)/2)):: nt=shape(c,0)
 
+    integer intent(hide) :: len0 = 1
+    integer intent(hide) :: len1 = 1
+    integer intent(hide) :: len2 = 1
 end subroutine <prefix><s,s,h,h>frk
 
-subroutine <prefix>tpttf(transr,uplo,n,nt,ap,arf,info)
+subroutine <prefix>tpttf(transr,uplo,n,nt,ap,arf,info,len0,len1)
     !
     ! copies a triangular matrix from the standard packed format (TP) to the
     ! rectangular full packed format (TF).
     !
 
-    callstatement (*f2py_func)(transr,uplo,&n,ap,arf,&info)
-    callprotoargument char*,char*,F_INT*,<ctype>*,<ctype>*,F_INT*
+    callstatement (*f2py_func)(transr,uplo,&n,ap,arf,&info,len0,len1)
+    callprotoargument char*,char*,F_INT*,<ctype>*,<ctype>*,F_INT*,F_INT,F_INT
 
     character optional,intent(in),check(*transr=='N'||*transr==<'T','T','C','C'>):: transr = 'N'
     character optional,intent(in),check(*uplo=='U'||*uplo=='L'):: uplo = 'U'
@@ -1954,16 +2053,18 @@ subroutine <prefix>tpttf(transr,uplo,n,nt,ap,arf,info)
     <ftype> dimension(nt),intent(out),depend(nt):: arf
     integer intent(out):: info
 
+    integer intent(hide) :: len0 = 1
+    integer intent(hide) :: len1 = 1
 end subroutine <prefix>tpttf
 
-subroutine <prefix>tpttr(uplo,n,nt,ap,a,lda,info)
+subroutine <prefix>tpttr(uplo,n,nt,ap,a,lda,info,len0)
     !
     ! TPTTR copies a triangular matrix from the standard packed format (TP)
     ! to the standard full format (TR).
     !
 
-    callstatement (*f2py_func)(uplo,&n,ap,a,&lda,&info)
-    callprotoargument char*,F_INT*,<ctype>*,<ctype>*,F_INT*,F_INT*
+    callstatement (*f2py_func)(uplo,&n,ap,a,&lda,&info,len0)
+    callprotoargument char*,F_INT*,<ctype>*,<ctype>*,F_INT*,F_INT*,F_INT
 
     character optional,intent(in),check(*uplo=='U'||*uplo=='L'):: uplo = 'U'
     integer intent(in), check(n>=0):: n
@@ -1973,16 +2074,17 @@ subroutine <prefix>tpttr(uplo,n,nt,ap,a,lda,info)
     integer intent(hide),depend(n):: lda=MAX(n,1)
     integer intent(out):: info
 
+    integer intent(hide) :: len0 = 1
 end subroutine <prefix>tpttr
 
-subroutine <prefix>tfttp(transr,uplo,n,nt,ap,arf,info)
+subroutine <prefix>tfttp(transr,uplo,n,nt,ap,arf,info,len0,len1)
     !
     ! copies a triangular matrix from the standard packed format (TP) to the
     ! rectangular full packed format (TF).
     !
 
-    callstatement (*f2py_func)(transr,uplo,&n,arf,ap,&info)
-    callprotoargument char*,char*,F_INT*,<ctype>*,<ctype>*,F_INT*
+    callstatement (*f2py_func)(transr,uplo,&n,arf,ap,&info,len0,len1)
+    callprotoargument char*,char*,F_INT*,<ctype>*,<ctype>*,F_INT*,F_INT,F_INT
 
     character optional,intent(in),check(*transr=='N'||*transr==<'T','T','C','C'>):: transr = 'N'
     character optional,intent(in),check(*uplo=='U'||*uplo=='L'):: uplo = 'U'
@@ -1992,15 +2094,17 @@ subroutine <prefix>tfttp(transr,uplo,n,nt,ap,arf,info)
     <ftype> dimension(nt),intent(out),depend(nt):: ap
     integer intent(out):: info
 
+    integer intent(hide) :: len0 = 1
+    integer intent(hide) :: len1 = 1
 end subroutine <prefix>tfttp
 
-subroutine <prefix>tfttr(transr,uplo,n,nt,arf,a,lda,info)
+subroutine <prefix>tfttr(transr,uplo,n,nt,arf,a,lda,info,len0,len1)
     !
     ! TFTTR copies a triangular matrix from the rectangular full packed
     ! format (TF) to the standard full format (TR).
     !
-    callstatement (*f2py_func)(transr,uplo,&n,arf,a,&lda,&info)
-    callprotoargument char*,char*,F_INT*,<ctype>*,<ctype>*,F_INT*,F_INT*
+    callstatement (*f2py_func)(transr,uplo,&n,arf,a,&lda,&info,len0,len1)
+    callprotoargument char*,char*,F_INT*,<ctype>*,<ctype>*,F_INT*,F_INT*,F_INT,F_INT
 
     character optional,intent(in),check(*transr=='N'||*transr==<'T','T','C','C'>):: transr = 'N'
     character optional,intent(in),check(*uplo=='U'||*uplo=='L'):: uplo = 'U'
@@ -2011,15 +2115,17 @@ subroutine <prefix>tfttr(transr,uplo,n,nt,arf,a,lda,info)
     integer intent(hide),depend(n):: lda = MAX(n,1)
     integer intent(out):: info
 
+    integer intent(hide) :: len0 = 1
+    integer intent(hide) :: len1 = 1
 end subroutine <prefix>tfttr
 
-subroutine <prefix>trttf(transr,uplo,n,a,lda,arf,info)
+subroutine <prefix>trttf(transr,uplo,n,a,lda,arf,info,len0,len1)
     !
     ! TRTTF copies a triangular matrix A from standard full format (TR)
     ! to rectangular full packed format (TF).
     !
-    callstatement (*f2py_func)(transr,uplo,&n,a,&lda,arf,&info)
-    callprotoargument char*,char*,F_INT*,<ctype>*,F_INT*,<ctype>*,F_INT*
+    callstatement (*f2py_func)(transr,uplo,&n,a,&lda,arf,&info,len0,len1)
+    callprotoargument char*,char*,F_INT*,<ctype>*,F_INT*,<ctype>*,F_INT*,F_INT,F_INT
 
     character optional,intent(in),check(*transr=='N'||*transr==<'T','T','C','C'>):: transr = 'N'
     character optional,intent(in),check(*uplo=='U'||*uplo=='L'):: uplo = 'U'
@@ -2029,15 +2135,17 @@ subroutine <prefix>trttf(transr,uplo,n,a,lda,arf,info)
     <ftype> dimension(n*(n+1)/2),intent(out),depend(n):: arf
     integer intent(out):: info
 
+    integer intent(hide) :: len0 = 1
+    integer intent(hide) :: len1 = 1
 end subroutine <prefix>trttf
 
-subroutine <prefix>trttp(uplo,n,a,lda,ap,info)
+subroutine <prefix>trttp(uplo,n,a,lda,ap,info,len0)
     !
     ! TRTTP copies a triangular matrix from the standard full format (TR) to
     ! the standard packed format (TP).
     !
-    callstatement (*f2py_func)(uplo,&n,a,&lda,ap,&info)
-    callprotoargument char*,F_INT*,<ctype>*,F_INT*,<ctype>*,F_INT*
+    callstatement (*f2py_func)(uplo,&n,a,&lda,ap,&info,len0)
+    callprotoargument char*,F_INT*,<ctype>*,F_INT*,<ctype>*,F_INT*,F_INT
 
     character optional, intent(F_INT),check(*uplo=='U'||*uplo=='L'):: uplo = 'U'
     integer intent(hide),depend(a):: n = shape(a,1)
@@ -2046,9 +2154,10 @@ subroutine <prefix>trttp(uplo,n,a,lda,ap,info)
     <ftype> dimension(n*(n+1)/2),intent(out),depend(n):: ap
     integer intent(out):: info
 
+    integer intent(hide) :: len0 = 1
 end subroutine <prefix>trttp
 
-subroutine <prefix>tfsm(transr,side,uplo,trans,diag,m,n,nt,alpha,a,b,ldb)
+subroutine <prefix>tfsm(transr,side,uplo,trans,diag,m,n,nt,alpha,a,b,ldb,len0,len1,len2,len3,len4)
     !
     ! Level 3 BLAS like routine for A in RFP Format.
     !
@@ -2064,8 +2173,8 @@ subroutine <prefix>tfsm(transr,side,uplo,trans,diag,m,n,nt,alpha,a,b,ldb)
     ! A is in Rectangular Full Packed (RFP) Format. The matrix X is overwritten on B.
     !
 
-    callstatement (*f2py_func)(transr,side,uplo,trans,diag,&m,&n,&alpha,a,b,&ldb)
-    callprotoargument char*,char*,char*,char*,char*,F_INT*,F_INT*,<ctype>*,<ctype>*,<ctype>*,F_INT*
+    callstatement (*f2py_func)(transr,side,uplo,trans,diag,&m,&n,&alpha,a,b,&ldb,len0,len1,len2,len3,len4)
+    callprotoargument char*,char*,char*,char*,char*,F_INT*,F_INT*,<ctype>*,<ctype>*,<ctype>*,F_INT*,F_INT,F_INT,F_INT,F_INT,F_INT
 
     character optional,intent(in),check(*transr=='N'||*transr==<'T','T','C','C'>):: transr = 'N'
     character optional,intent(in),check(*side=='L'||*side=='R'):: side = 'L'
@@ -2080,9 +2189,14 @@ subroutine <prefix>tfsm(transr,side,uplo,trans,diag,m,n,nt,alpha,a,b,ldb)
     <ftype> dimension(m,n),intent(in,out,copy,out=x):: b
     integer intent(hide),depend(b):: ldb=MAX(shape(b,0),1)
 
+    integer intent(hide) :: len0 = 1
+    integer intent(hide) :: len1 = 1
+    integer intent(hide) :: len2 = 1
+    integer intent(hide) :: len3 = 1
+    integer intent(hide) :: len4 = 1
 end subroutine <prefix>tfsm
 
-subroutine <prefix>pftrf(transr,uplo,n,nt,a,info)
+subroutine <prefix>pftrf(transr,uplo,n,nt,a,info,len0,len1)
     !
     ! Computes the Cholesky factorization of a complex Hermitian positive definite matrix A.
     ! The factorization has the form
@@ -2092,8 +2206,8 @@ subroutine <prefix>pftrf(transr,uplo,n,nt,a,info)
     ! where U is an upper triangular matrix and L is lower triangular.
     ! This is the block version of the algorithm, calling Level 3 BLAS.
     !
-    callstatement (*f2py_func)(transr,uplo,&n,a,&info)
-    callprotoargument char*,char*,F_INT*,<ctype>*,F_INT*
+    callstatement (*f2py_func)(transr,uplo,&n,a,&info,len0,len1)
+    callprotoargument char*,char*,F_INT*,<ctype>*,F_INT*,F_INT,F_INT
 
     character optional,intent(in),check(*transr=='N'||*transr==<'T','T','C','C'>):: transr = 'N'
     character optional,intent(in),check(*uplo=='U'||*uplo=='L'):: uplo = 'U'
@@ -2102,17 +2216,19 @@ subroutine <prefix>pftrf(transr,uplo,n,nt,a,info)
     integer intent(hide),depend(a,n),check(nt==(n*(n+1)/2)):: nt=shape(a,0)
     integer intent(out):: info
 
+    integer intent(hide) :: len0 = 1
+    integer intent(hide) :: len1 = 1
 end subroutine <prefix>pftrf
 
-subroutine <prefix>pftri(transr,uplo,n,nt,a,info)
+subroutine <prefix>pftri(transr,uplo,n,nt,a,info,len0,len1)
     !
     ! Computes the inverse of a real/complex Sym/Hermitian positive definite
     ! matrix A using the Cholesky factorization A = U**H*U or A = L*L**H
     ! computed by ?PFTRF.
     !
 
-    callstatement (*f2py_func)(transr,uplo,&n,a,&info)
-    callprotoargument char*,char*,F_INT*,<ctype>*,F_INT*
+    callstatement (*f2py_func)(transr,uplo,&n,a,&info,len0,len1)
+    callprotoargument char*,char*,F_INT*,<ctype>*,F_INT*,F_INT,F_INT
 
     character optional,intent(in),check(*transr=='N'||*transr==<'T','T','C','C'>):: transr = 'N'
     character optional,intent(in),check(*uplo=='U'||*uplo=='L'):: uplo = 'U'
@@ -2121,16 +2237,18 @@ subroutine <prefix>pftri(transr,uplo,n,nt,a,info)
     integer intent(hide),depend(a,n),check(nt==(n*(n+1)/2)):: nt=shape(a,0)
     integer intent(out):: info
 
+    integer intent(hide) :: len0 = 1
+    integer intent(hide) :: len1 = 1
 end subroutine <prefix>pftri
 
-subroutine <prefix>pftrs(transr,uplo,n,nhrs,nt,a,b,ldb,info)
+subroutine <prefix>pftrs(transr,uplo,n,nhrs,nt,a,b,ldb,info,len0,len1)
     !
     ! ?PFTRS solves a system of linear equations A*X = B with a Sym/Hermitian
     ! positive definite matrix A using the Cholesky factorization
     ! A = U**H*U or A = L*L**H computed by ?PFTRF.
     !
-    callstatement (*f2py_func)(transr,uplo,&n,&nhrs,a,b,&ldb,&info)
-    callprotoargument char*,char*,F_INT*,F_INT*,<ctype>*,<ctype>*,F_INT*,F_INT*
+    callstatement (*f2py_func)(transr,uplo,&n,&nhrs,a,b,&ldb,&info,len0,len1)
+    callprotoargument char*,char*,F_INT*,F_INT*,<ctype>*,<ctype>*,F_INT*,F_INT*,F_INT,F_INT
 
     character optional,intent(in),check(*transr=='N'||*transr==<'T','T','C','C'>):: transr = 'N'
     character optional,intent(in),check(*uplo=='U'||*uplo=='L'):: uplo = 'U'
@@ -2142,6 +2260,8 @@ subroutine <prefix>pftrs(transr,uplo,n,nhrs,nt,a,b,ldb,info)
     integer intent(hide),depend(b):: ldb = MAX(shape(b,0),1)
     integer intent(out):: info
 
+    integer intent(hide) :: len0 = 1
+    integer intent(hide) :: len1 = 1
 end subroutine<prefix>pftrs
 
 subroutine <prefix>tzrzf(m,n,a,lda,tau,work,lwork,info)
@@ -2208,15 +2328,15 @@ subroutine <prefix2>lasd4( n, i, d, z, delta, rho, sigma, work, info )
 
 end subroutine <prefix2>lasd4
 
-subroutine <prefix>lauum(n,c,info,lower)
+subroutine <prefix>lauum(n,c,info,lower,len0)
     ! a,info = lauum(c,lower=0,overwrite_c=0)
     ! Compute product
     ! U^T * U, C = U if lower = 0
     ! L * L^T, C = L if lower = 1
     ! C is triangular matrix of the corresponding Cholesky decomposition.
 
-    callstatement (*f2py_func)((lower?"L":"U"),&n,c,&n,&info)
-    callprotoargument char*,F_INT*,<ctype>*,F_INT*,F_INT*
+    callstatement (*f2py_func)((lower?"L":"U"),&n,c,&n,&info,len0)
+    callprotoargument char*,F_INT*,<ctype>*,F_INT*,F_INT*,F_INT
 
     integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
 
@@ -2225,6 +2345,7 @@ subroutine <prefix>lauum(n,c,info,lower)
     check(shape(c,0)==shape(c,1)) :: c
     integer intent(out) :: info
 
+    integer intent(hide) :: len0 = 1
 end subroutine <prefix>lauum
 
 subroutine <prefix>laswp(n,a,nrows,k1,k2,piv,off,inc,m,npiv)
@@ -2280,30 +2401,32 @@ end subroutine <prefix>laswp
 !          rmin  = underflow threshold - base**(emin-1)
 !          emax  = largest exponent before overflow
 !          rmax  = overflow threshold  - (base**emax)*(1-eps)
-function dlamch(cmach) result(x)
+function dlamch(cmach,len0) result(x)
     double precision :: dlamch, x
     character :: cmach
-    callstatement dlamch_return_value = (*f2py_func)(cmach)
-    callprotoargument char*
+    callstatement dlamch_return_value = (*f2py_func)(cmach,len0)
+    callprotoargument char*,F_INT
     intent(c) dlamch
     fortranname F_FUNC(dlamch,DLAMCH)
+    integer intent(hide) :: len0 = 1
 end function dlamch
 
-function slamch(cmach) result(x)
+function slamch(cmach,len0) result(x)
     real :: slamch, x
     character :: cmach
-    callstatement slamch_return_value = (*f2py_func)(cmach)
-    callprotoargument char*
+    callstatement slamch_return_value = (*f2py_func)(cmach,len0)
+    callprotoargument char*,F_INT
     intent(c) slamch
     fortranname F_FUNC(slamch,SLAMCH)
+    integer intent(hide) :: len0 = 1
 end function slamch
 
-function <prefix2>lange(norm,m,n,a,lda,work) result(n2)
+function <prefix2>lange(norm,m,n,a,lda,work,len0) result(n2)
     ! the one norm, or the Frobenius norm, or the  infinity norm, or the
     ! element of largest absolute value of a real matrix A.
     <ftype2> <prefix2>lange, n2
-    callstatement <prefix2>lange_return_value = (*f2py_func)(norm,&m,&n,a,&lda,work)
-    callprotoargument char*,F_INT*,F_INT*,<ctype2>*,F_INT*,<ctype2>*
+    callstatement <prefix2>lange_return_value = (*f2py_func)(norm,&m,&n,a,&lda,work,len0)
+    callprotoargument char*,F_INT*,F_INT*,<ctype2>*,F_INT*,<ctype2>*,F_INT
     intent(c) <prefix2>lange
     fortranname F_FUNC(<prefix2>lange,<S,D>LANGE)
 
@@ -2313,14 +2436,15 @@ function <prefix2>lange(norm,m,n,a,lda,work) result(n2)
     integer intent(hide),depend(a) :: n = shape(a,1)
     <ftype2> dimension(m,n),intent(in) :: a
     <ftype2> dimension(m+1),intent(cache,hide) :: work
+    integer intent(hide) :: len0 = 1
 end function <prefix2>lange
 
-function <prefix2c>lange(norm,m,n,a,lda,work) result(n2)
+function <prefix2c>lange(norm,m,n,a,lda,work,len0) result(n2)
     ! the one norm, or the Frobenius norm, or the  infinity norm, or the
     ! element of largest absolute value of a complex matrix A.
     <ftype2> <prefix2c>lange, n2
-    callstatement <prefix2c>lange_return_value = (*f2py_func)(norm,&m,&n,a,&lda,work)
-    callprotoargument char*,F_INT*,F_INT*,<ctype2c>*,F_INT*,<ctype2>*
+    callstatement <prefix2c>lange_return_value = (*f2py_func)(norm,&m,&n,a,&lda,work,len0)
+    callprotoargument char*,F_INT*,F_INT*,<ctype2c>*,F_INT*,<ctype2>*,F_INT
     intent(c) <prefix2c>lange
     fortranname F_FUNC(<prefix2c>lange,<C,Z>LANGE)
 
@@ -2330,17 +2454,18 @@ function <prefix2c>lange(norm,m,n,a,lda,work) result(n2)
     integer intent(hide),depend(a) :: n = shape(a,1)
     <ftype2c> dimension(m,n),intent(in) :: a
     <ftype2> dimension(m+1),intent(cache,hide) :: work
+    integer intent(hide) :: len0 = 1
 end function <prefix2c>lange
 
-function <prefix>lantr(norm, uplo, diag, m, n, a, lda, work) result(n2)
+function <prefix>lantr(norm, uplo, diag, m, n, a, lda, work,len0,len1,len2) result(n2)
 
     ! ?LANTR  returns the value of the one norm,  or the Frobenius norm, or
     ! the  infinity norm,  or the  element of  largest absolute value  of a
     ! trapezoidal or triangular matrix A.
 
     <ftypereal> <prefix>lantr, n2
-    callstatement <prefix>lantr_return_value = (*f2py_func)(norm, uplo, diag, &m, &n, a, &lda, work);
-    callprotoargument char*, char*, char*, F_INT*, F_INT*, <ctype>*, F_INT*, <ctypereal>*
+    callstatement <prefix>lantr_return_value = (*f2py_func)(norm, uplo, diag, &m, &n, a, &lda, work,len0,len1,len2);
+    callprotoargument char*, char*, char*, F_INT*, F_INT*, <ctype>*, F_INT*, <ctypereal>*,F_INT,F_INT,F_INT
     intent(c) <prefix>lantr
     fortranname F_FUNC(<prefix>lantr,<S,C,D,Z>LANTR)
 
@@ -2353,6 +2478,9 @@ function <prefix>lantr(norm, uplo, diag, m, n, a, lda, work) result(n2)
     integer intent(hide), depend(m) :: lda = MAX(1, m)
     <ftypereal> intent(cache,hide), dimension(lda) :: work
 
+    integer intent(hide) :: len0 = 1
+    integer intent(hide) :: len1 = 1
+    integer intent(hide) :: len2 = 1
 end subroutine <prefix>lantr
 
 subroutine <prefix>larfg(n, alpha, x, incx, tau, lx)
diff --git a/scipy/linalg/flapack_pos_def.pyf.src b/scipy/linalg/flapack_pos_def.pyf.src
index d264f80dad..8111ec0ce7 100644
--- a/scipy/linalg/flapack_pos_def.pyf.src
+++ b/scipy/linalg/flapack_pos_def.pyf.src
@@ -1,7 +1,7 @@
 ! Signatures for f2py-wrappers of FORTRAN LAPACK Positive Definite Matrix functions.
 !
 
-subroutine <prefix>pstrf(n,a,lda,piv,rank_c,tol,work,info,lower)
+subroutine <prefix>pstrf(n,a,lda,piv,rank_c,tol,work,info,lower,len0)
     ! c,x,info = pstrf(a,b,lower=0,overwrite_a=0,overwrite_b=0)
     ! Solve A * X = B.
     ! A is symmetric/hermitian positive semidefinite
@@ -10,8 +10,8 @@ subroutine <prefix>pstrf(n,a,lda,piv,rank_c,tol,work,info,lower)
     ! where U is an upper triangular matrix and L is lower triangular, and
     ! P is stored as vector PIV.
 
-    callstatement (*f2py_func)((lower?"L":"U"),&n,a,&lda,piv,&rank_c,&tol,work,&info)
-    callprotoargument char*,F_INT*,<ctype>*,F_INT*,F_INT*,F_INT*,<ctypereal>*,<ctypereal>*,F_INT*
+    callstatement (*f2py_func)((lower?"L":"U"),&n,a,&lda,piv,&rank_c,&tol,work,&info,len0)
+    callprotoargument char*,F_INT*,<ctype>*,F_INT*,F_INT*,F_INT*,<ctypereal>*,<ctypereal>*,F_INT*,F_INT
     
     integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
     integer depend(a),intent(hide):: n = shape(a,0)
@@ -22,10 +22,11 @@ subroutine <prefix>pstrf(n,a,lda,piv,rank_c,tol,work,info,lower)
     <ftypereal> optional, intent(in) :: tol = -1.0
     <ftypereal> intent(hide),dimension(2*n),depend(n) :: work
     integer intent(out) :: info
+    integer intent(hide) :: len0 = 1
 end subroutine <prefix>pstrf
 
 
-subroutine <prefix>pstf2(n,a,lda,piv,rank_c,tol,work,info,lower)
+subroutine <prefix>pstf2(n,a,lda,piv,rank_c,tol,work,info,lower,len0)
     ! c,x,info = pstf2(a,b,lower=0,overwrite_a=0,overwrite_b=0)
     ! Solve A * X = B.
     ! A is symmetric positive semidefinite
@@ -34,8 +35,8 @@ subroutine <prefix>pstf2(n,a,lda,piv,rank_c,tol,work,info,lower)
     ! where U is an upper triangular matrix and L is lower triangular, and
     ! P is stored as vector PIV.
 
-    callstatement (*f2py_func)((lower?"L":"U"),&n,a,&lda,piv,&rank_c,&tol,work,&info)
-    callprotoargument char*,F_INT*,<ctype>*,F_INT*,F_INT*,F_INT*,<ctypereal>*,<ctypereal>*,F_INT*
+    callstatement (*f2py_func)((lower?"L":"U"),&n,a,&lda,piv,&rank_c,&tol,work,&info,len0)
+    callprotoargument char*,F_INT*,<ctype>*,F_INT*,F_INT*,F_INT*,<ctypereal>*,<ctypereal>*,F_INT*,F_INT
 
     integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
     integer depend(a),intent(hide):: n = shape(a,0)
@@ -46,10 +47,11 @@ subroutine <prefix>pstf2(n,a,lda,piv,rank_c,tol,work,info,lower)
     <ftypereal> optional,intent(in) :: tol = -1.0
     <ftypereal> intent(hide),dimension(2*n),depend(n) :: work
     integer intent(out) :: info
+    integer intent(hide) :: len0 = 1
 end subroutine <prefix>pstf2
 
 
-subroutine <prefix>posv(n,nrhs,a,b,info,lower)
+subroutine <prefix>posv(n,nrhs,a,b,info,lower,len0)
     ! c,x,info = posv(a,b,lower=0,overwrite_a=0,overwrite_b=0)
     ! Solve A * X = B.
     ! A is symmetric positive defined
@@ -57,8 +59,8 @@ subroutine <prefix>posv(n,nrhs,a,b,info,lower)
     ! A = L * L^T, C = L if lower = 1
     ! C is triangular matrix of the corresponding Cholesky decomposition.
 
-    callstatement (*f2py_func)((lower?"L":"U"),&n,&nrhs,a,&n,b,&n,&info)
-    callprotoargument char*,F_INT*,F_INT*,<ctype>*,F_INT*,<ctype>*,F_INT*,F_INT*
+    callstatement (*f2py_func)((lower?"L":"U"),&n,&nrhs,a,&n,b,&n,&info,len0)
+    callprotoargument char*,F_INT*,F_INT*,<ctype>*,F_INT*,<ctype>*,F_INT*,F_INT*,F_INT
 
     integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
 
@@ -70,14 +72,15 @@ subroutine <prefix>posv(n,nrhs,a,b,info,lower)
     check(shape(a,0)==shape(b,0)) :: b
     integer intent(out) :: info
 
+    integer intent(hide) :: len0 = 1
 end subroutine <prefix>posv
 
-subroutine <prefix>posvx(fact,n,nrhs,a,lda,af,ldaf,equed,s,b,ldb,x,ldx,rcond,ferr,berr,work,irwork,info,lower)
+subroutine <prefix>posvx(fact,n,nrhs,a,lda,af,ldaf,equed,s,b,ldb,x,ldx,rcond,ferr,berr,work,irwork,info,lower,len0,len1,len2)
     ! Solve A * X = B for Symmetric/Hermitian A
     ! "expert" version of the ?POSV routines
     threadsafe
-    callstatement (*f2py_func)(fact,(lower?"L":"U"),&n,&nrhs,a,&lda,af,&ldaf,equed,s,b,&ldb,x,&ldx,&rcond,ferr,berr,work,irwork,&info)
-    callprotoargument char*,char*,F_INT*,F_INT*,<ctype>*,F_INT*,<ctype>*,F_INT*,char*,<ctypereal>*,<ctype>*,F_INT*,<ctype>*,F_INT*,<ctypereal>*,<ctypereal>*,<ctypereal>*,<ctype>*,<F_INT,F_INT,float,double>*,F_INT*
+    callstatement (*f2py_func)(fact,(lower?"L":"U"),&n,&nrhs,a,&lda,af,&ldaf,equed,s,b,&ldb,x,&ldx,&rcond,ferr,berr,work,irwork,&info,len0,len1,len2)
+    callprotoargument char*,char*,F_INT*,F_INT*,<ctype>*,F_INT*,<ctype>*,F_INT*,char*,<ctypereal>*,<ctype>*,F_INT*,<ctype>*,F_INT*,<ctypereal>*,<ctypereal>*,<ctypereal>*,<ctype>*,<F_INT,F_INT,float,double>*,F_INT*,F_INT,F_INT,F_INT
  
     character optional,intent(in):: fact = "E"
     integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
@@ -100,14 +103,17 @@ subroutine <prefix>posvx(fact,n,nrhs,a,lda,af,ldaf,equed,s,b,ldb,x,ldx,rcond,fer
     <integer,integer,real,double precision> intent(hide),dimension(n),depend(n):: irwork
     integer intent(out):: info
  
+    integer intent(hide) :: len0 = 1
+    integer intent(hide) :: len1 = 1
+    integer intent(hide) :: len2 = 1
 end subroutine <prefix>posvx
 
-subroutine <prefix>pocon(uplo,n,a,lda,anorm,rcond,work,irwork,info)
+subroutine <prefix>pocon(uplo,n,a,lda,anorm,rcond,work,irwork,info,len0)
     ! Computes the 1- or inf- norm reciprocal condition number estimate
     ! for a positive definite symmetric/hermitian matrix.
     threadsafe
-    callstatement (*f2py_func)(uplo,&n,a,&lda,&anorm,&rcond,work,irwork,&info)
-    callprotoargument char*,F_INT*,<ctype>*,F_INT*,<ctypereal>*,<ctypereal>*,<ctype>*,<F_INT,F_INT,float,double>*,F_INT*
+    callstatement (*f2py_func)(uplo,&n,a,&lda,&anorm,&rcond,work,irwork,&info,len0)
+    callprotoargument char*,F_INT*,<ctype>*,F_INT*,<ctypereal>*,<ctypereal>*,<ctype>*,<F_INT,F_INT,float,double>*,F_INT*,F_INT
  
     character optional,intent(in):: uplo = 'U'
     integer depend(a),intent(hide):: n = shape(a,0)
@@ -119,9 +125,10 @@ subroutine <prefix>pocon(uplo,n,a,lda,anorm,rcond,work,irwork,info)
     <integer,integer,real, double precision> depend(n),dimension(n),intent(hide,cache):: irwork
     integer intent(out):: info
  
+    integer intent(hide) :: len0 = 1
 end subroutine <prefix>pocon
  
-subroutine <prefix2>potrf(n,a,lda,info,lower,clean)
+subroutine <prefix2>potrf(n,a,lda,info,lower,clean,len0)
     ! c,info = potrf(a,lower=0,clean=1,overwrite_a=0)
     ! Compute Cholesky decomposition of symmetric positive defined matrix:
     ! A = U^T * U, C = U if lower = 0
@@ -129,8 +136,8 @@ subroutine <prefix2>potrf(n,a,lda,info,lower,clean)
     ! C is triangular matrix of the corresponding Cholesky decomposition.
     ! clean==1 zeros strictly lower or upper parts of U or L, respectively
  
-    callstatement (*f2py_func)((lower?"L":"U"),&n,a,&lda,&info); if(clean){Py_ssize_t i,j;if(lower){for(i=0;i\<n;++i) for(j=i+1;j\<n;++j) *(a+j*n+i)=0.0;} else {for(i=0;i\<n;++i) for(j=i+1;j<n;++j) *(a+i*n+j)=0.0;}}
-    callprotoargument char*,F_INT*,<ctype2>*,F_INT*,F_INT*
+    callstatement (*f2py_func)((lower?"L":"U"),&n,a,&lda,&info,len0); if(clean){Py_ssize_t i,j;if(lower){for(i=0;i\<n;++i) for(j=i+1;j\<n;++j) *(a+j*n+i)=0.0;} else {for(i=0;i\<n;++i) for(j=i+1;j<n;++j) *(a+i*n+j)=0.0;}}
+    callprotoargument char*,F_INT*,<ctype2>*,F_INT*,F_INT*,F_INT
  
     integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
     integer optional,intent(in),check(clean==0||clean==1) :: clean = 1
@@ -139,9 +146,10 @@ subroutine <prefix2>potrf(n,a,lda,info,lower,clean)
     integer depend(n),intent(hide) :: lda = MAX(1,n)
     integer intent(out) :: info
  
+    integer intent(hide) :: len0 = 1
 end subroutine <prefix2>potrf
  
-subroutine <prefix2c>potrf(n,a,lda,info,lower,clean)
+subroutine <prefix2c>potrf(n,a,lda,info,lower,clean,len0)
     ! c,info = potrf(a,lower=0,clean=1,overwrite_a=0)
     ! Compute Cholesky decomposition of symmetric positive defined matrix:
     ! A = U^H * U, C = U if lower = 0
@@ -149,8 +157,8 @@ subroutine <prefix2c>potrf(n,a,lda,info,lower,clean)
     ! C is triangular matrix of the corresponding Cholesky decomposition.
     ! clean==1 zeros strictly lower or upper parts of U or L, respectively
  
-    callstatement (*f2py_func)((lower?"L":"U"),&n,a,&lda,&info); if(clean){F_INT i,j,k;if(lower){for(i=0;i\<n;++i) for(j=i+1;j\<n;++j) {k=j*n+i;(a+k)->r=(a+k)->i=0.0;}} else {for(i=0;i\<n;++i) for(j=i+1;j\<n;++j) {k=i*n+j;(a+k)->r=(a+k)->i=0.0;}}}
-    callprotoargument char*,F_INT*,<ctype2c>*,F_INT*,F_INT*
+    callstatement (*f2py_func)((lower?"L":"U"),&n,a,&lda,&info,len0); if(clean){F_INT i,j,k;if(lower){for(i=0;i\<n;++i) for(j=i+1;j\<n;++j) {k=j*n+i;(a+k)->r=(a+k)->i=0.0;}} else {for(i=0;i\<n;++i) for(j=i+1;j\<n;++j) {k=i*n+j;(a+k)->r=(a+k)->i=0.0;}}}
+    callprotoargument char*,F_INT*,<ctype2c>*,F_INT*,F_INT*,F_INT
  
     integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
     integer optional,intent(in),check(clean==0||clean==1) :: clean = 1
@@ -159,9 +167,10 @@ subroutine <prefix2c>potrf(n,a,lda,info,lower,clean)
     integer depend(n),intent(hide) :: lda = MAX(1,n)
     integer intent(out) :: info
  
+    integer intent(hide) :: len0 = 1
 end subroutine <prefix2c>potrf
  
-subroutine <prefix>potrs(n,nrhs,c,b,info,lower)
+subroutine <prefix>potrs(n,nrhs,c,b,info,lower,len0)
      ! x,info = potrs(c,b,lower=0=1,overwrite_b=0)
     ! Solve A * X = B.
     ! A is symmetric positive defined
@@ -169,8 +178,8 @@ subroutine <prefix>potrs(n,nrhs,c,b,info,lower)
     ! A = L * L^T, C = L if lower = 1
     ! C is triangular matrix of the corresponding Cholesky decomposition.
  
-    callstatement (*f2py_func)((lower?"L":"U"),&n,&nrhs,c,&n,b,&n,&info)
-    callprotoargument char*,F_INT*,F_INT*,<ctype>*,F_INT*,<ctype>*,F_INT*,F_INT*
+    callstatement (*f2py_func)((lower?"L":"U"),&n,&nrhs,c,&n,b,&n,&info,len0)
+    callprotoargument char*,F_INT*,F_INT*,<ctype>*,F_INT*,<ctype>*,F_INT*,F_INT*,F_INT
  
     integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
  
@@ -182,17 +191,18 @@ subroutine <prefix>potrs(n,nrhs,c,b,info,lower)
     check(shape(c,0)==shape(b,0)) :: b
     integer intent(out) :: info
  
+    integer intent(hide) :: len0 = 1
 end subroutine <prefix>potrs
  
-subroutine <prefix>potri(n,c,info,lower)
+subroutine <prefix>potri(n,c,info,lower,len0)
     ! inv_a,info = potri(c,lower=0,overwrite_c=0)
     ! Compute A inverse A^-1.
     ! A = U^T * U, C = U if lower = 0
     ! A = L * L^T, C = L if lower = 1
     ! C is triangular matrix of the corresponding Cholesky decomposition.
  
-    callstatement (*f2py_func)((lower?"L":"U"),&n,c,&n,&info)
-    callprotoargument char*,F_INT*,<ctype>*,F_INT*,F_INT*
+    callstatement (*f2py_func)((lower?"L":"U"),&n,c,&n,&info,len0)
+    callprotoargument char*,F_INT*,<ctype>*,F_INT*,F_INT*,F_INT
  
     integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
  
@@ -201,4 +211,5 @@ subroutine <prefix>potri(n,c,info,lower)
     check(shape(c,0)==shape(c,1)) :: c
     integer intent(out) :: info
 
+    integer intent(hide) :: len0 = 1
 end subroutine <prefix>potri
diff --git a/scipy/linalg/flapack_pos_def_tri.pyf.src b/scipy/linalg/flapack_pos_def_tri.pyf.src
index f28c3135f9..d881aa8418 100644
--- a/scipy/linalg/flapack_pos_def_tri.pyf.src
+++ b/scipy/linalg/flapack_pos_def_tri.pyf.src
@@ -58,7 +58,7 @@ subroutine <prefix2>pttrs(n, nrhs, d, e, b, ldb, info)
 end subroutine<prefix2>pttrs
 
 
-subroutine <prefix2c>pttrs(lower, n, nrhs, d, e, b, ldb, info)
+subroutine <prefix2c>pttrs(lower, n, nrhs, d, e, b, ldb, info,len0)
     ! x, info  = pttrs(d, e, b, lower=0, overwrite_b=0)
     !
     ! ?PTTRS solves a tridiagonal system of the form
@@ -70,8 +70,8 @@ subroutine <prefix2c>pttrs(lower, n, nrhs, d, e, b, ldb, info)
     ! matrix whose subdiagonal is specified in the vector E, and X and B
     ! are N by NRHS matrices.
 
-    callstatement (*f2py_func)((lower?"L":"U"), &n, &nrhs, d, e, b, &ldb, &info)
-    callprotoargument char*, F_INT*, F_INT*, <ctype2>*, <ctype2c>*, <ctype2c>*, F_INT*, F_INT*
+    callstatement (*f2py_func)((lower?"L":"U"), &n, &nrhs, d, e, b, &ldb, &info,len0)
+    callprotoargument char*, F_INT*, F_INT*, <ctype2>*, <ctype2c>*, <ctype2c>*, F_INT*, F_INT*,F_INT
 
     integer optional, intent(in), check(lower==0||lower==1) :: lower = 0
     integer intent(hide), depend(d) :: n = len(d)
@@ -82,10 +82,11 @@ subroutine <prefix2c>pttrs(lower, n, nrhs, d, e, b, ldb, info)
     integer intent(hide), depend(b)  :: nrhs = shape(b, 1)
     integer intent(out) :: info
 
+    integer intent(hide) :: len0 = 1
 end subroutine<prefix2c>pttrs
 
 
-subroutine <prefix>pteqr(compute_z, n, d, e, z, ldz, work, info)
+subroutine <prefix>pteqr(compute_z, n, d, e, z, ldz, work, info,len0)
     ! d, e, z, work, info  = pteqr(d, e, z, compute_z=0, overwrite_d=0, overwrite_e=0, overwrite_z=0)
     ! ?PTEQR computes all eigenvalues and, optionally, eigenvectors of a
     ! symmetric positive definite tridiagonal matrix.
@@ -102,8 +103,8 @@ subroutine <prefix>pteqr(compute_z, n, d, e, z, ldz, work, info)
     ! tridiagonal form, however, may preclude the possibility of obtaining
     ! high relative accuracy in the small eigenvalues of the original
     ! matrix, if these eigenvalues range over many orders of magnitude.)
-    callstatement (*f2py_func)((compute_z?(compute_z==2?"I":"V"):"N"), &n, d, e, z, &ldz, work, &info)
-    callprotoargument char*, F_INT*, <ctypereal>*, <ctypereal>*, <ctype>*, F_INT*, <ctypereal>*, F_INT*
+    callstatement (*f2py_func)((compute_z?(compute_z==2?"I":"V"):"N"), &n, d, e, z, &ldz, work, &info,len0)
+    callprotoargument char*, F_INT*, <ctypereal>*, <ctypereal>*, <ctype>*, F_INT*, <ctypereal>*, F_INT*,F_INT
     integer intent(in, optional), check((compute_z>=0) && (compute_z<=2)) :: compute_z = 0
     integer intent(hide), depend(d) :: n = len(d)
     <ftypereal> intent(in,out,copy), dimension(n) :: d
@@ -113,10 +114,11 @@ subroutine <prefix>pteqr(compute_z, n, d, e, z, ldz, work, info)
     <ftypereal> intent(hide), dimension(4*n) :: work
     integer intent(out) :: info
 
+    integer intent(hide) :: len0 = 1
 end subroutine <prefix>pteqr
 
 
-subroutine <prefix2>ptsvx(fact, n, nrhs, d, e, df, ef, b, ldb, x, ldx, rcond, ferr, berr, work, info)
+subroutine <prefix2>ptsvx(fact, n, nrhs, d, e, df, ef, b, ldb, x, ldx, rcond, ferr, berr, work, info,len0)
     ! DPTSVX uses the factorization A = L*D*L**T to compute the solution
     ! to a real system of linear equations A*X = B, where A is an N-by-N
     ! symmetric positive definite tridiagonal matrix and X and B are
@@ -124,8 +126,8 @@ subroutine <prefix2>ptsvx(fact, n, nrhs, d, e, df, ef, b, ldb, x, ldx, rcond, fe
     !
     ! Error bounds on the solution and a condition estimate are also
     ! provided.
-    callstatement (*f2py_func)(fact, &n, &nrhs, d, e, df, ef, b, &ldb, x, &ldx, &rcond, ferr, berr, work, &info)
-    callprotoargument char*, F_INT*, F_INT*, <ctype2>*, <ctype2>*, <ctype2>*, <ctype2>*, <ctype2>*, F_INT*, <ctype2>*, F_INT*,  <ctype2>*, <ctype2>*, <ctype2>*, <ctype2>*, F_INT*
+    callstatement (*f2py_func)(fact, &n, &nrhs, d, e, df, ef, b, &ldb, x, &ldx, &rcond, ferr, berr, work, &info,len0)
+    callprotoargument char*, F_INT*, F_INT*, <ctype2>*, <ctype2>*, <ctype2>*, <ctype2>*, <ctype2>*, F_INT*, <ctype2>*, F_INT*,  <ctype2>*, <ctype2>*, <ctype2>*, <ctype2>*, F_INT*,F_INT
 
     character optional, intent(in) :: fact = 'N'
     integer intent(hide), depend(d) :: n = len(d)
@@ -144,10 +146,11 @@ subroutine <prefix2>ptsvx(fact, n, nrhs, d, e, df, ef, b, ldb, x, ldx, rcond, fe
     <ftype2> intent(hide,cache), depend(n), dimension(2*n) :: work
     integer intent(out) :: info
 
+    integer intent(hide) :: len0 = 1
 end subroutine <prefix2>ptsvx
 
 
-subroutine <prefix2c>ptsvx(fact, n, nrhs, d, e, df, ef, b, ldb, x, ldx, rcond, ferr, berr, work, rwork, info)
+subroutine <prefix2c>ptsvx(fact, n, nrhs, d, e, df, ef, b, ldb, x, ldx, rcond, ferr, berr, work, rwork, info,len0)
     ! DPTSVX uses the factorization A = L*D*L**T to compute the solution
     ! to a real system of linear equations A*X = B, where A is an N-by-N
     ! symmetric positive definite tridiagonal matrix and X and B are
@@ -155,8 +158,8 @@ subroutine <prefix2c>ptsvx(fact, n, nrhs, d, e, df, ef, b, ldb, x, ldx, rcond, f
     !
     ! Error bounds on the solution and a condition estimate are also
     ! provided.
-    callstatement (*f2py_func)(fact, &n, &nrhs, d, e, df, ef, b, &ldb, x, &ldx, &rcond, ferr, berr, work, rwork, &info)
-    callprotoargument char*, F_INT*, F_INT*, <ctype2>*, <ctype2c>*, <ctype2>*, <ctype2c>*, <ctype2c>*, F_INT*, <ctype2c>*, F_INT*,  <ctype2>*, <ctype2>*, <ctype2>*, <ctype2c>*, <ctype2>*, F_INT*
+    callstatement (*f2py_func)(fact, &n, &nrhs, d, e, df, ef, b, &ldb, x, &ldx, &rcond, ferr, berr, work, rwork, &info,len0)
+    callprotoargument char*, F_INT*, F_INT*, <ctype2>*, <ctype2c>*, <ctype2>*, <ctype2c>*, <ctype2c>*, F_INT*, <ctype2c>*, F_INT*,  <ctype2>*, <ctype2>*, <ctype2>*, <ctype2c>*, <ctype2>*, F_INT*,F_INT
 
     character optional, intent(in) :: fact = 'N'
     integer intent(hide), depend(d) :: n = len(d)
@@ -176,4 +179,5 @@ subroutine <prefix2c>ptsvx(fact, n, nrhs, d, e, df, ef, b, ldb, x, ldx, rcond, f
     <ftype2> intent(hide,cache), depend(n), dimension(n) :: rwork
     integer intent(out) :: info
 
+    integer intent(hide) :: len0 = 1
 end subroutine <prefix2c>ptsvx
diff --git a/scipy/linalg/flapack_sym_herm.pyf.src b/scipy/linalg/flapack_sym_herm.pyf.src
index d0decd33c9..ac2015c98f 100644
--- a/scipy/linalg/flapack_sym_herm.pyf.src
+++ b/scipy/linalg/flapack_sym_herm.pyf.src
@@ -1,7 +1,7 @@
 ! Signatures for f2py-wrappers of FORTRAN LAPACK Symmetric/Hermitian Matrix functions.
 !
 
-subroutine <prefix2>syev(compute_v,lower,n,w,a,lda,work,lwork,info)
+subroutine <prefix2>syev(compute_v,lower,n,w,a,lda,work,lwork,info,len0,len1)
     ! w,v,info = syev(a,compute_v=1,lower=0,lwork=3*n-1,overwrite_a=0)
     ! Compute all eigenvalues and, optionally, eigenvectors of a
     ! real symmetric matrix A.
@@ -9,8 +9,8 @@ subroutine <prefix2>syev(compute_v,lower,n,w,a,lda,work,lwork,info)
     ! Performance tip:
     !   If compute_v=0 then set also overwrite_a=1.
 
-    callstatement (*f2py_func)((compute_v?"V":"N"),(lower?"L":"U"),&n,a,&lda,w,work,&lwork,&info)
-    callprotoargument char*,char*,F_INT*,<ctype2>*,F_INT*,<ctype2>*,<ctype2>*,F_INT*,F_INT*
+    callstatement (*f2py_func)((compute_v?"V":"N"),(lower?"L":"U"),&n,a,&lda,w,work,&lwork,&info,len0,len1)
+    callprotoargument char*,char*,F_INT*,<ctype2>*,F_INT*,<ctype2>*,<ctype2>*,F_INT*,F_INT*,F_INT,F_INT
 
     integer optional,intent(in):: compute_v = 1
     check(compute_v==1||compute_v==0) compute_v
@@ -29,15 +29,17 @@ subroutine <prefix2>syev(compute_v,lower,n,w,a,lda,work,lwork,info)
 
     integer intent(out) :: info
 
+    integer intent(hide) :: len0 = 1
+    integer intent(hide) :: len1 = 1
 end subroutine <prefix2>syev
 
-subroutine <prefix2>syev_lwork(lower,n,w,a,lda,work,lwork,info)
+subroutine <prefix2>syev_lwork(lower,n,w,a,lda,work,lwork,info,len0,len1)
     ! LWORK routines for syev
 
     fortranname <prefix2>syev
 
-    callstatement (*f2py_func)("N",(lower?"L":"U"),&n,&a,&lda,&w,&work,&lwork,&info)
-    callprotoargument char*,char*,F_INT*,<ctype2>*,F_INT*,<ctype2>*,<ctype2>*,F_INT*,F_INT*
+    callstatement (*f2py_func)("N",(lower?"L":"U"),&n,&a,&lda,&w,&work,&lwork,&info,len0,len1)
+    callprotoargument char*,char*,F_INT*,<ctype2>*,F_INT*,<ctype2>*,<ctype2>*,F_INT*,F_INT*,F_INT,F_INT
     
      integer intent(in):: n
      integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
@@ -50,9 +52,11 @@ subroutine <prefix2>syev_lwork(lower,n,w,a,lda,work,lwork,info)
      <ftype2> intent(out):: work
      integer intent(out):: info
      
+    integer intent(hide) :: len0 = 1
+    integer intent(hide) :: len1 = 1
 end subroutine <prefix2>syev_lwork
 
-subroutine <prefix2c>heev(compute_v,lower,n,w,a,lda,work,lwork,rwork,info)
+subroutine <prefix2c>heev(compute_v,lower,n,w,a,lda,work,lwork,rwork,info,len0,len1)
     ! w,v,info = syev(a,compute_v=1,lower=0,lwork=3*n-1,overwrite_a=0)
     ! Compute all eigenvalues and, optionally, eigenvectors of a
     ! complex Hermitian matrix A.
@@ -60,8 +64,8 @@ subroutine <prefix2c>heev(compute_v,lower,n,w,a,lda,work,lwork,rwork,info)
     ! Warning:
     !   If compute_v=0 and overwrite_a=1, the contents of a is destroyed.
 
-    callstatement (*f2py_func)((compute_v?"V":"N"),(lower?"L":"U"),&n,a,&lda,w,work,&lwork,rwork,&info)
-    callprotoargument char*,char*,F_INT*,<ctype2c>*,F_INT*,<ctype2>*,<ctype2c>*,F_INT*,<ctype2>*,F_INT*
+    callstatement (*f2py_func)((compute_v?"V":"N"),(lower?"L":"U"),&n,a,&lda,w,work,&lwork,rwork,&info,len0,len1)
+    callprotoargument char*,char*,F_INT*,<ctype2c>*,F_INT*,<ctype2>*,<ctype2c>*,F_INT*,<ctype2>*,F_INT*,F_INT,F_INT
 
     integer optional,intent(in),check(compute_v==1||compute_v==0) :: compute_v = 1
     integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
@@ -80,14 +84,16 @@ subroutine <prefix2c>heev(compute_v,lower,n,w,a,lda,work,lwork,rwork,info)
 
     integer intent(out) :: info
 
+    integer intent(hide) :: len0 = 1
+    integer intent(hide) :: len1 = 1
 end subroutine <prefix2c>heev
 
-subroutine <prefix2c>heev_lwork(lower,n,w,a,lda,work,lwork,rwork,info)
+subroutine <prefix2c>heev_lwork(lower,n,w,a,lda,work,lwork,rwork,info,len0,len1)
     ! LWORK routines for heev
 
     fortranname <prefix2c>heev
-    callstatement (*f2py_func)("N",(lower?"L":"U"),&n,&a,&lda,&w,&work,&lwork,&rwork,&info)
-    callprotoargument char*,char*,F_INT*,<ctype2c>*,F_INT*,<ctype2>*,<ctype2c>*,F_INT*,<ctype2>*,F_INT*
+    callstatement (*f2py_func)("N",(lower?"L":"U"),&n,&a,&lda,&w,&work,&lwork,&rwork,&info,len0,len1)
+    callprotoargument char*,char*,F_INT*,<ctype2c>*,F_INT*,<ctype2>*,<ctype2c>*,F_INT*,<ctype2>*,F_INT*,F_INT,F_INT
 
      integer intent(in):: n
      integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
@@ -101,9 +107,11 @@ subroutine <prefix2c>heev_lwork(lower,n,w,a,lda,work,lwork,rwork,info)
      <ftype2c> intent(out):: work
      integer intent(out):: info
      
+    integer intent(hide) :: len0 = 1
+    integer intent(hide) :: len1 = 1
 end subroutine <prefix2c>heev_lwork
 
-subroutine <prefix2>syevd(compute_v,lower,n,w,a,lda,work,lwork,iwork,liwork,info)
+subroutine <prefix2>syevd(compute_v,lower,n,w,a,lda,work,lwork,iwork,liwork,info,len0,len1)
     ! w,v,info = syevd(a,compute_v=1,lower=0,lwork=min_lwork,overwrite_a=0)
     ! Compute all eigenvalues and, optionally, eigenvectors of a
     ! real symmetric matrix A using D&C.
@@ -111,8 +119,8 @@ subroutine <prefix2>syevd(compute_v,lower,n,w,a,lda,work,lwork,iwork,liwork,info
     ! Performance tip:
     !   If compute_v=0 then set also overwrite_a=1.
 
-    callstatement (*f2py_func)((compute_v?"V":"N"),(lower?"L":"U"),&n,a,&lda,w,work,&lwork,iwork,&liwork,&info)
-    callprotoargument char*,char*,F_INT*,<ctype2>*,F_INT*,<ctype2>*,<ctype2>*,F_INT*,F_INT*,F_INT*,F_INT*
+    callstatement (*f2py_func)((compute_v?"V":"N"),(lower?"L":"U"),&n,a,&lda,w,work,&lwork,iwork,&liwork,&info,len0,len1)
+    callprotoargument char*,char*,F_INT*,<ctype2>*,F_INT*,<ctype2>*,<ctype2>*,F_INT*,F_INT*,F_INT*,F_INT*,F_INT,F_INT
 
     integer optional,intent(in),check(compute_v==1||compute_v==0) :: compute_v = 1
     integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
@@ -132,15 +140,17 @@ subroutine <prefix2>syevd(compute_v,lower,n,w,a,lda,work,lwork,iwork,liwork,info
 
     integer intent(out) :: info
 
+    integer intent(hide) :: len0 = 1
+    integer intent(hide) :: len1 = 1
 end subroutine <prefix2>syevd
 
-subroutine <prefix2>syevd_lwork(compute_v,lower,n,w,a,lda,work,lwork,iwork,liwork,info)
+subroutine <prefix2>syevd_lwork(compute_v,lower,n,w,a,lda,work,lwork,iwork,liwork,info,len0,len1)
     ! LWORK routines for syevd
 
     fortranname <prefix2>syevd
 
-    callstatement (*f2py_func)((compute_v?"V":"N"),(lower?"L":"U"),&n,&a,&lda,&w,&work,&lwork,&iwork,&liwork,&info)
-    callprotoargument char*,char*,F_INT*,<ctype2>*,F_INT*,<ctype2>*,<ctype2>*,F_INT*,F_INT*,F_INT*,F_INT*
+    callstatement (*f2py_func)((compute_v?"V":"N"),(lower?"L":"U"),&n,&a,&lda,&w,&work,&lwork,&iwork,&liwork,&info,len0,len1)
+    callprotoargument char*,char*,F_INT*,<ctype2>*,F_INT*,<ctype2>*,<ctype2>*,F_INT*,F_INT*,F_INT*,F_INT*,F_INT,F_INT
 
     integer intent(in):: n
     integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
@@ -156,9 +166,11 @@ subroutine <prefix2>syevd_lwork(compute_v,lower,n,w,a,lda,work,lwork,iwork,liwor
     integer intent(out):: iwork
     integer intent(out):: info
 
+    integer intent(hide) :: len0 = 1
+    integer intent(hide) :: len1 = 1
 end subroutine <prefix2>syevd_lwork
 
-subroutine <prefix2c>heevd(compute_v,lower,n,w,a,lda,work,lwork,iwork,liwork,rwork,lrwork,info)
+subroutine <prefix2c>heevd(compute_v,lower,n,w,a,lda,work,lwork,iwork,liwork,rwork,lrwork,info,len0,len1)
     ! w,v,info = heevd(a,compute_v=1,lower=0,lwork=min_lwork,overwrite_a=0)
     ! Compute all eigenvalues and, optionally, eigenvectors of a
     ! complex Hermitian matrix A using D&C.
@@ -166,8 +178,8 @@ subroutine <prefix2c>heevd(compute_v,lower,n,w,a,lda,work,lwork,iwork,liwork,rwo
     ! Warning:
     !   If compute_v=0 and overwrite_a=1, the contents of a is destroyed.
 
-    callstatement (*f2py_func)((compute_v?"V":"N"),(lower?"L":"U"),&n,a,&lda,w,work,&lwork,rwork,&lrwork,iwork,&liwork,&info)
-    callprotoargument char*,char*,F_INT*,<ctype2c>*,F_INT*,<ctype2>*,<ctype2c>*,F_INT*,<ctype2>*,F_INT*,F_INT*,F_INT*,F_INT*
+    callstatement (*f2py_func)((compute_v?"V":"N"),(lower?"L":"U"),&n,a,&lda,w,work,&lwork,rwork,&lrwork,iwork,&liwork,&info,len0,len1)
+    callprotoargument char*,char*,F_INT*,<ctype2c>*,F_INT*,<ctype2>*,<ctype2c>*,F_INT*,<ctype2>*,F_INT*,F_INT*,F_INT*,F_INT*,F_INT,F_INT
 
     integer optional,intent(in):: compute_v = 1
     check(compute_v==1||compute_v==0) compute_v
@@ -190,15 +202,17 @@ subroutine <prefix2c>heevd(compute_v,lower,n,w,a,lda,work,lwork,iwork,liwork,rwo
     <ftype2> dimension(lrwork),intent(hide,cache),depend(n,lrwork) :: rwork
     integer intent(out) :: info
 
+    integer intent(hide) :: len0 = 1
+    integer intent(hide) :: len1 = 1
 end subroutine <prefix2c>heevd
 
-subroutine <prefix2c>heevd_lwork(compute_v,lower,n,w,a,lda,work,lwork,iwork,liwork,rwork,lrwork,info)
+subroutine <prefix2c>heevd_lwork(compute_v,lower,n,w,a,lda,work,lwork,iwork,liwork,rwork,lrwork,info,len0,len1)
     ! LWORK routines for heevd
     
     fortranname <prefix2c>heevd
     
-    callstatement (*f2py_func)((compute_v?"V":"N"),(lower?"L":"U"),&n,&a,&lda,&w,&work,&lwork,&rwork,&lrwork,&iwork,&liwork,&info)
-    callprotoargument char*,char*,F_INT*,<ctype2c>*,F_INT*,<ctype2>*,<ctype2c>*,F_INT*,<ctype2>*,F_INT*,F_INT*,F_INT*,F_INT*
+    callstatement (*f2py_func)((compute_v?"V":"N"),(lower?"L":"U"),&n,&a,&lda,&w,&work,&lwork,&rwork,&lrwork,&iwork,&liwork,&info,len0,len1)
+    callprotoargument char*,char*,F_INT*,<ctype2c>*,F_INT*,<ctype2>*,<ctype2c>*,F_INT*,<ctype2>*,F_INT*,F_INT*,F_INT*,F_INT*,F_INT,F_INT
 
     integer intent(in):: n
     integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
@@ -216,16 +230,18 @@ subroutine <prefix2c>heevd_lwork(compute_v,lower,n,w,a,lda,work,lwork,iwork,liwo
     integer intent(out):: iwork
     integer intent(out):: info
 
+    integer intent(hide) :: len0 = 1
+    integer intent(hide) :: len1 = 1
 end subroutine <prefix2c>heevd_lwork
 
-   subroutine <prefix>sytf2(lower,n,a,lda,ipiv,info)
+   subroutine <prefix>sytf2(lower,n,a,lda,ipiv,info,len0)
 
      ! Compute the factorization of a symmetric matrix such that
      ! A = L * D * L^T if lower = 1
      ! A = U * D * U^T if lower = 0
 
-     callstatement (*f2py_func)((lower?"L":"U"),&n,a,&lda,ipiv,&info)
-     callprotoargument char*,F_INT*,<ctype>*,F_INT*,F_INT*,F_INT*
+     callstatement (*f2py_func)((lower?"L":"U"),&n,a,&lda,ipiv,&info,len0)
+     callprotoargument char*,F_INT*,<ctype>*,F_INT*,F_INT*,F_INT*,F_INT
 
      integer optional,intent(in),check(lower==0||lower==1):: lower = 0
      integer depend(a),intent(hide):: n = shape(a,0)
@@ -234,9 +250,10 @@ end subroutine <prefix2c>heevd_lwork
      integer dimension(n),depend(n),intent(out):: ipiv
      integer intent(out):: info
 
+    integer intent(hide) :: len0 = 1
    end subroutine<prefix>sytf2
 
-  subroutine <prefix2>sygst(n,a,lda,b,ldb,info,itype,lower)
+  subroutine <prefix2>sygst(n,a,lda,b,ldb,info,itype,lower,len0)
 
     ! c, info = sygst(a,b)
     ! Transforms the generalized symmetric eigenvalue problem to standard.
@@ -244,8 +261,8 @@ end subroutine <prefix2c>heevd_lwork
     ! A = U^T * A * U or L^T * A * L, if itype == 2 or 3, respectively
     ! B must contain the factorized U and L from potrf
 
-     callstatement (*f2py_func)(&itype,(lower?"L":"U"),&n,a,&lda,b,&ldb,&info)
-     callprotoargument F_INT*,char*,F_INT*,<ctype2>*,F_INT*,<ctype2>*,F_INT*,F_INT*
+     callstatement (*f2py_func)(&itype,(lower?"L":"U"),&n,a,&lda,b,&ldb,&info,len0)
+     callprotoargument F_INT*,char*,F_INT*,<ctype2>*,F_INT*,<ctype2>*,F_INT*,F_INT*,F_INT
 
      integer optional,intent(in),check(itype==1||itype==2||itype==3):: itype = 1
      integer optional,intent(in),check(lower==0||lower==1):: lower = 0
@@ -256,17 +273,18 @@ end subroutine <prefix2c>heevd_lwork
      integer depend(b),intent(hide):: ldb = max(shape(b,0),1)
      integer intent(out):: info
 
+    integer intent(hide) :: len0 = 1
    end subroutine <prefix2>sygst
 
-   subroutine <prefix>sytrf(lower,n,a,lda,ipiv,work,lwork,info)
+   subroutine <prefix>sytrf(lower,n,a,lda,ipiv,work,lwork,info,len0)
 
      ! Compute the factorization of a symmetric matrix such that
      ! A = L * D * L^T if lower = 1
      ! A = U * D * U^T if lower = 0
      ! This is similar to ?SYTF2 but uses BLAS3 blocked calls
 
-     callstatement (*f2py_func)((lower?"L":"U"),&n,a,&lda,ipiv,work,&lwork,&info)
-     callprotoargument char*,F_INT*,<ctype>*,F_INT*,F_INT*,<ctype>*,F_INT*,F_INT*
+     callstatement (*f2py_func)((lower?"L":"U"),&n,a,&lda,ipiv,work,&lwork,&info,len0)
+     callprotoargument char*,F_INT*,<ctype>*,F_INT*,F_INT*,<ctype>*,F_INT*,F_INT*,F_INT
 
      integer optional,intent(in),check(lower==0||lower==1):: lower = 0
      integer depend(a),intent(hide):: n = shape(a,0)
@@ -277,16 +295,17 @@ end subroutine <prefix2c>heevd_lwork
      <ftype> depend(lwork),dimension(MAX(lwork,1)),intent(hide,cache):: work
      integer intent(out):: info
 
+    integer intent(hide) :: len0 = 1
    end subroutine <prefix>sytrf
 
 
-   subroutine <prefix>sytrf_lwork(lower,n,a,lda,ipiv,work,lwork,info)
+   subroutine <prefix>sytrf_lwork(lower,n,a,lda,ipiv,work,lwork,info,len0)
      ! lwork computation for ?SYTRF
 
      fortranname <prefix>sytrf
 
-     callstatement (*f2py_func)((lower?"L":"U"),&n,&a,&lda,&ipiv,&work,&lwork,&info)
-     callprotoargument char*,F_INT*,<ctype>*,F_INT*,F_INT*,<ctype>*,F_INT*,F_INT*
+     callstatement (*f2py_func)((lower?"L":"U"),&n,&a,&lda,&ipiv,&work,&lwork,&info,len0)
+     callprotoargument char*,F_INT*,<ctype>*,F_INT*,F_INT*,<ctype>*,F_INT*,F_INT*,F_INT
 
      integer intent(in):: n
      integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
@@ -299,15 +318,16 @@ end subroutine <prefix2c>heevd_lwork
      <ftype> intent(out):: work
      integer intent(out):: info
 
+    integer intent(hide) :: len0 = 1
    end subroutine <prefix>sytrf_lwork
 
 
-   subroutine <prefix>sytrs(n,nrhs,a,lda,ipiv,b,ldb,info,lower)
+   subroutine <prefix>sytrs(n,nrhs,a,lda,ipiv,b,ldb,info,lower,len0)
    
    ! Solve A * X = B for symmetric A matrix after calling ?sytrf
    
-     callstatement (*f2py_func)((lower?"L":"U"),&n,&nrhs,a,&lda,ipiv,b,&ldb,&info)
-     callprotoargument char*,F_INT*,F_INT*,<ctype>*,F_INT*,F_INT*,<ctype>*,F_INT*,F_INT*
+     callstatement (*f2py_func)((lower?"L":"U"),&n,&nrhs,a,&lda,ipiv,b,&ldb,&info,len0)
+     callprotoargument char*,F_INT*,F_INT*,<ctype>*,F_INT*,F_INT*,<ctype>*,F_INT*,F_INT*,F_INT
      
      <ftype> intent(in), dimension(lda, n), check((lda >= n) && (n >= 0)) :: a
      <ftype> intent(in,out,copy,out=x),dimension(ldb, nrhs) :: b
@@ -319,15 +339,16 @@ end subroutine <prefix2c>heevd_lwork
      integer intent(hide), depend(b,n),check(ldb >= n) :: ldb = MAX(1, shape(b, 0))
      integer intent(out) :: info
 
+    integer intent(hide) :: len0 = 1
    end subroutine <prefix>sytrs
 
 
-   subroutine <prefix2c>hetrs(n,nrhs,a,lda,ipiv,b,ldb,info,lower)
+   subroutine <prefix2c>hetrs(n,nrhs,a,lda,ipiv,b,ldb,info,lower,len0)
    
    ! Solve A * X = B for hermitian A matrix after calling ?hetrf
    
-     callstatement (*f2py_func)((lower?"L":"U"),&n,&nrhs,a,&lda,ipiv,b,&ldb,&info)
-     callprotoargument char*,F_INT*,F_INT*,<ctype2c>*,F_INT*,F_INT*,<ctype2c>*,F_INT*,F_INT*
+     callstatement (*f2py_func)((lower?"L":"U"),&n,&nrhs,a,&lda,ipiv,b,&ldb,&info,len0)
+     callprotoargument char*,F_INT*,F_INT*,<ctype2c>*,F_INT*,F_INT*,<ctype2c>*,F_INT*,F_INT*,F_INT
      
      <ftype2c> intent(in), dimension(lda, n), check((lda >= n) && (n >= 0)) :: a
      <ftype2c> intent(in,out,copy,out=x),dimension(ldb, nrhs) :: b
@@ -339,15 +360,16 @@ end subroutine <prefix2c>heevd_lwork
      integer intent(hide), depend(b,n),check(ldb >= n) :: ldb = MAX(1, shape(b, 0))
      integer intent(out) :: info
 
+    integer intent(hide) :: len0 = 1
    end subroutine <prefix2c>hetrs
    
    
-   subroutine <prefix>sysv(n,nrhs,a,lda,ipiv,b,ldb,work,lwork,info,lower)
+   subroutine <prefix>sysv(n,nrhs,a,lda,ipiv,b,ldb,work,lwork,info,lower,len0)
 
    ! Solve A * X = B for symmetric A matrix
 
-     callstatement (*f2py_func)((lower?"L":"U"),&n,&nrhs,a,&lda,ipiv,b,&ldb,work,&lwork,&info)
-     callprotoargument char*,F_INT*,F_INT*,<ctype>*,F_INT*,F_INT*,<ctype>*,F_INT*,<ctype>*,F_INT*,F_INT*
+     callstatement (*f2py_func)((lower?"L":"U"),&n,&nrhs,a,&lda,ipiv,b,&ldb,work,&lwork,&info,len0)
+     callprotoargument char*,F_INT*,F_INT*,<ctype>*,F_INT*,F_INT*,<ctype>*,F_INT*,<ctype>*,F_INT*,F_INT*,F_INT
 
      integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
      integer depend(a),intent(hide):: n = shape(a,0)
@@ -361,15 +383,16 @@ end subroutine <prefix2c>heevd_lwork
      <ftype> depend(lwork),dimension(MAX(lwork,1)),intent(hide,cache):: work
      integer intent(out):: info
 
+    integer intent(hide) :: len0 = 1
    end subroutine <prefix>sysv
 
-   subroutine <prefix>sysv_lwork(n,nrhs,a,lda,ipiv,b,ldb,work,lwork,info,lower)
+   subroutine <prefix>sysv_lwork(n,nrhs,a,lda,ipiv,b,ldb,work,lwork,info,lower,len0)
 
    ! lwork computation for ?SYSV
 
      fortranname <prefix>sysv
-     callstatement (*f2py_func)((lower?"L":"U"),&n,&nrhs,&a,&lda,&ipiv,&b,&ldb,&work,&lwork,&info)
-     callprotoargument char*,F_INT*,F_INT*,<ctype>*,F_INT*,F_INT*,<ctype>*,F_INT*,<ctype>*,F_INT*,F_INT*
+     callstatement (*f2py_func)((lower?"L":"U"),&n,&nrhs,&a,&lda,&ipiv,&b,&ldb,&work,&lwork,&info,len0)
+     callprotoargument char*,F_INT*,F_INT*,<ctype>*,F_INT*,F_INT*,<ctype>*,F_INT*,<ctype>*,F_INT*,F_INT*,F_INT
 
      integer intent(in):: n
      integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
@@ -385,16 +408,17 @@ end subroutine <prefix2c>heevd_lwork
      <ftype> intent(out):: work
      integer intent(out):: info
 
+    integer intent(hide) :: len0 = 1
    end subroutine <prefix>sysv_lwork
 
-   subroutine <prefix>sysvx(n,nrhs,a,lda,af,ldaf,ipiv,b,ldb,x,ldx,rcond,ferr,berr,work,lwork,irwork,info,factored,lower)
+   subroutine <prefix>sysvx(n,nrhs,a,lda,af,ldaf,ipiv,b,ldb,x,ldx,rcond,ferr,berr,work,lwork,irwork,info,factored,lower,len0,len1)
 
    ! Solve A * X = B for symmetric A matrix
    ! The expert driver of ?SYSV with condition number, backward,forward error estimates and iterative refinement
    ! The (c,z) versions assume only symmetric complex matrices. For Hermitian matrices, routine (c,z)HESVX is used
      threadsafe
-     callstatement (*f2py_func)((factored?"F":"N"),(lower?"L":"U"),&n,&nrhs,a,&lda,af,&ldaf,ipiv,b,&ldb,x,&ldx,&rcond,ferr,berr,work,&lwork,irwork,&info)
-     callprotoargument char*,char*,F_INT*,F_INT*,<ctype>*,F_INT*,<ctype>*,F_INT*,F_INT*,<ctype>*,F_INT*,<ctype>*,F_INT*,<ctypereal>*,<ctypereal>*,<ctypereal>*,<ctype>*,F_INT*,<F_INT,F_INT,float,double>*,F_INT*
+     callstatement (*f2py_func)((factored?"F":"N"),(lower?"L":"U"),&n,&nrhs,a,&lda,af,&ldaf,ipiv,b,&ldb,x,&ldx,&rcond,ferr,berr,work,&lwork,irwork,&info,len0,len1)
+     callprotoargument char*,char*,F_INT*,F_INT*,<ctype>*,F_INT*,<ctype>*,F_INT*,F_INT*,<ctype>*,F_INT*,<ctype>*,F_INT*,<ctypereal>*,<ctypereal>*,<ctypereal>*,<ctype>*,F_INT*,<F_INT,F_INT,float,double>*,F_INT*,F_INT,F_INT
 
      integer optional,intent(in),check(factored==0||factored==1) :: factored = 0
      integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
@@ -417,15 +441,17 @@ end subroutine <prefix2c>heevd_lwork
      <integer,integer,real,double precision> intent(hide,cache),dimension(n),depend(n) :: irwork
      integer intent(out):: info
 
+    integer intent(hide) :: len0 = 1
+    integer intent(hide) :: len1 = 1
    end subroutine <prefix>sysvx
 
-   subroutine <prefix>sysvx_lwork(n,nrhs,a,lda,af,ldaf,ipiv,b,ldb,x,ldx,rcond,ferr,berr,work,lwork,irwork,info,factored,lower)
+   subroutine <prefix>sysvx_lwork(n,nrhs,a,lda,af,ldaf,ipiv,b,ldb,x,ldx,rcond,ferr,berr,work,lwork,irwork,info,factored,lower,len0,len1)
 
    ! lwork computation for ?SYSVX
 
      fortranname <prefix>sysvx
-     callstatement (*f2py_func)((factored?"F":"N"),(lower?"L":"U"),&n,&nrhs,&a,&lda,&af,&ldaf,&ipiv,&b,&ldb,&x,&ldx,&rcond,&ferr,&berr,&work,&lwork,&irwork,&info)
-     callprotoargument char*,char*,F_INT*,F_INT*,<ctype>*,F_INT*,<ctype>*,F_INT*,F_INT*,<ctype>*,F_INT*,<ctype>*,F_INT*,<ctypereal>*,<ctypereal>*,<ctypereal>*,<ctype>*,F_INT*,<F_INT,F_INT,float,double>*,F_INT*
+     callstatement (*f2py_func)((factored?"F":"N"),(lower?"L":"U"),&n,&nrhs,&a,&lda,&af,&ldaf,&ipiv,&b,&ldb,&x,&ldx,&rcond,&ferr,&berr,&work,&lwork,&irwork,&info,len0,len1)
+     callprotoargument char*,char*,F_INT*,F_INT*,<ctype>*,F_INT*,<ctype>*,F_INT*,F_INT*,<ctype>*,F_INT*,<ctype>*,F_INT*,<ctypereal>*,<ctypereal>*,<ctypereal>*,<ctype>*,F_INT*,<F_INT,F_INT,float,double>*,F_INT*,F_INT,F_INT
 
      integer intent(in):: n
      integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
@@ -450,10 +476,12 @@ end subroutine <prefix2c>heevd_lwork
      <ftype> intent(out) :: work
      integer intent(out):: info
 
+    integer intent(hide) :: len0 = 1
+    integer intent(hide) :: len1 = 1
    end subroutine <prefix>sysvx_lwork
 
 
-  subroutine <prefix2>sycon(n,a,lda,ipiv,anorm,rcond,work,iwork,info,lower)
+  subroutine <prefix2>sycon(n,a,lda,ipiv,anorm,rcond,work,iwork,info,lower,len0)
   !   Estimates the reciprocal of the condition number (in the
   !   1-norm) of a real symmetric matrix A using the factorization
   !   A = U*D*U**T or A = L*D*L**T computed by (S/D)SYTRF.
@@ -461,8 +489,8 @@ end subroutine <prefix2c>heevd_lwork
   !   An estimate is obtained for norm(inv(A)), and the reciprocal of the
   !   condition number is computed as RCOND = 1 / (ANORM * norm(inv(A)))
 
-    callstatement (*f2py_func)((lower?"L":"U"),&n,a,&lda,ipiv,&anorm,&rcond,work,iwork,&info)
-    callprotoargument char*,F_INT*,<ctype2>*,F_INT*,F_INT*,<ctype2>*,<ctype2>*,<ctype2>*,F_INT*,F_INT*
+    callstatement (*f2py_func)((lower?"L":"U"),&n,a,&lda,ipiv,&anorm,&rcond,work,iwork,&info,len0)
+    callprotoargument char*,F_INT*,<ctype2>*,F_INT*,F_INT*,<ctype2>*,<ctype2>*,<ctype2>*,F_INT*,F_INT*,F_INT
 
     integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
     integer depend(a),intent(hide):: n = shape(a,0)
@@ -475,10 +503,11 @@ end subroutine <prefix2c>heevd_lwork
     integer intent(hide),dimension(n),depend(n) :: iwork
     integer intent(out) :: info
 
+    integer intent(hide) :: len0 = 1
   end subroutine <prefix2>sycon
 
 
-  subroutine <c,z,c,z><sy,\0,he,\2>con(n,a,lda,ipiv,anorm,rcond,work,info,lower)
+  subroutine <c,z,c,z><sy,\0,he,\2>con(n,a,lda,ipiv,anorm,rcond,work,info,lower,len0)
   !   Estimates the reciprocal of the condition number (in the
   !   1-norm) of a complex symmetric matrix A using the factorization
   !   A = U*D*U**T or A = L*D*L**T computed by (C/Z)SYTRF.
@@ -486,8 +515,8 @@ end subroutine <prefix2c>heevd_lwork
   !   An estimate is obtained for norm(inv(A)), and the reciprocal of the
   !   condition number is computed as RCOND = 1 / (ANORM * norm(inv(A)))
 
-    callstatement (*f2py_func)((lower?"L":"U"),&n,a,&lda,ipiv,&anorm,&rcond,work,&info)
-    callprotoargument char*,F_INT*,<ctypecomplex>*,F_INT*,F_INT*,<ctypereal>*,<ctypereal>*,<ctypecomplex>*,F_INT*
+    callstatement (*f2py_func)((lower?"L":"U"),&n,a,&lda,ipiv,&anorm,&rcond,work,&info,len0)
+    callprotoargument char*,F_INT*,<ctypecomplex>*,F_INT*,F_INT*,<ctypereal>*,<ctypereal>*,<ctypecomplex>*,F_INT*,F_INT
 
     integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
     integer depend(a),intent(hide):: n = shape(a,0)
@@ -499,14 +528,15 @@ end subroutine <prefix2c>heevd_lwork
     <ftypecomplex> intent(hide),dimension(2*n),depend(n) :: work
     integer intent(out) :: info
 
+    integer intent(hide) :: len0 = 1
   end subroutine <c,z,c,z><sy,\0,he,\2>con
 
-  subroutine <prefix>syconv(lower,way,n,a,lda,ipiv,e,info)
+  subroutine <prefix>syconv(lower,way,n,a,lda,ipiv,e,info,len0,len1)
   ! ?SYCONV converts A given by ???TRF into L and D and vice-versa.
   ! Get Non-diag elements of D (returned in workspace) and apply or reverse permutation done in TRF.
 
-    callstatement (*f2py_func)((lower?"L":"U"),(way?"R":"C"),&n,a,&lda,ipiv,e,&info)
-    callprotoargument char*,char*,F_INT*,<ctype>*,F_INT*,F_INT*,<ctype>*,F_INT*
+    callstatement (*f2py_func)((lower?"L":"U"),(way?"R":"C"),&n,a,&lda,ipiv,e,&info,len0,len1)
+    callprotoargument char*,char*,F_INT*,<ctype>*,F_INT*,F_INT*,<ctype>*,F_INT*,F_INT,F_INT
 
     integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
     integer optional,intent(in),check(way==0||way==1) :: way = 0
@@ -517,9 +547,11 @@ end subroutine <prefix2c>heevd_lwork
     <ftype> intent(out),dimension(n),depend(n):: e
     integer intent(out) :: info
 
+    integer intent(hide) :: len0 = 1
+    integer intent(hide) :: len1 = 1
   end subroutine <prefix>syconv
 
-  subroutine <prefix2c>hegst(n,a,lda,b,ldb,info,itype,lower)
+  subroutine <prefix2c>hegst(n,a,lda,b,ldb,info,itype,lower,len0)
 
     ! c, info = hegst(a,b)
     ! Transforms the generalized Hermitian eigenvalue problem to standard.
@@ -527,8 +559,8 @@ end subroutine <prefix2c>heevd_lwork
     ! A = U^H * A * U or L^H * A * L, if itype == 2 or 3, respectively
     ! B must contain the factorized U and L from potrf
 
-     callstatement (*f2py_func)(&itype,(lower?"L":"U"),&n,a,&lda,b,&ldb,&info)
-     callprotoargument F_INT*,char*,F_INT*,<ctype2c>*,F_INT*,<ctype2c>*,F_INT*,F_INT*
+     callstatement (*f2py_func)(&itype,(lower?"L":"U"),&n,a,&lda,b,&ldb,&info,len0)
+     callprotoargument F_INT*,char*,F_INT*,<ctype2c>*,F_INT*,<ctype2c>*,F_INT*,F_INT*,F_INT
 
      integer optional,intent(in),check(itype==1||itype==2||itype==3):: itype = 1
      integer optional,intent(in),check(lower==0||lower==1):: lower = 0
@@ -539,17 +571,18 @@ end subroutine <prefix2c>heevd_lwork
      integer depend(b),intent(hide):: ldb = max(shape(b,0),1)
      integer intent(out):: info
 
+    integer intent(hide) :: len0 = 1
    end subroutine <prefix2c>hegst
 
-   subroutine <prefix2c>hetrf(lower,n,a,lda,ipiv,work,lwork,info)
+   subroutine <prefix2c>hetrf(lower,n,a,lda,ipiv,work,lwork,info,len0)
 
      ! Compute the factorization of a hermitian matrix such that
      ! A = L * D * L^T if lower = 1
      ! A = U * D * U^T if lower = 0
      ! This is similar to ?HETF2 but uses BLAS3 blocked calls
 
-     callstatement (*f2py_func)((lower?"L":"U"),&n,a,&lda,ipiv,work,&lwork,&info)
-     callprotoargument char*,F_INT*,<ctype2c>*,F_INT*,F_INT*,<ctype2c>*,F_INT*,F_INT*
+     callstatement (*f2py_func)((lower?"L":"U"),&n,a,&lda,ipiv,work,&lwork,&info,len0)
+     callprotoargument char*,F_INT*,<ctype2c>*,F_INT*,F_INT*,<ctype2c>*,F_INT*,F_INT*,F_INT
 
      integer optional,intent(in),check(lower==0||lower==1):: lower = 0
      integer depend(a),intent(hide):: n = shape(a,0)
@@ -560,16 +593,17 @@ end subroutine <prefix2c>heevd_lwork
      <ftype2c> depend(lwork),dimension(MAX(lwork,1)),intent(hide,cache):: work
      integer intent(out):: info
 
+    integer intent(hide) :: len0 = 1
    end subroutine <prefix2c>hetrf
 
 
-   subroutine <prefix2c>hetrf_lwork(lower,n,a,lda,ipiv,work,lwork,info)
+   subroutine <prefix2c>hetrf_lwork(lower,n,a,lda,ipiv,work,lwork,info,len0)
      ! lwork computation for ?HETRF
 
      fortranname <prefix2c>hetrf
 
-     callstatement (*f2py_func)((lower?"L":"U"),&n,&a,&lda,&ipiv,&work,&lwork,&info)
-     callprotoargument char*,F_INT*,<ctype2c>*,F_INT*,F_INT*,<ctype2c>*,F_INT*,F_INT*
+     callstatement (*f2py_func)((lower?"L":"U"),&n,&a,&lda,&ipiv,&work,&lwork,&info,len0)
+     callprotoargument char*,F_INT*,<ctype2c>*,F_INT*,F_INT*,<ctype2c>*,F_INT*,F_INT*,F_INT
 
      integer intent(in):: n
      integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
@@ -582,18 +616,19 @@ end subroutine <prefix2c>heevd_lwork
      <ftype2c> intent(out):: work
      integer intent(out):: info
 
+    integer intent(hide) :: len0 = 1
    end subroutine <prefix2c>hetrf_lwork
 
 
-   subroutine <prefix2c>hesv(n,nrhs,a,lda,ipiv,b,ldb,work,lwork,info,lower)
+   subroutine <prefix2c>hesv(n,nrhs,a,lda,ipiv,b,ldb,work,lwork,info,lower,len0)
 
    ! Solves A * X = B for X
    ! A is hermitian. For symmetric A see ?SYSV
    ! A = U * D * U**H if lower = 0
    ! A = L * D * L**H if lower = 1
      threadsafe
-     callstatement (*f2py_func)((lower?"L":"U"),&n,&nrhs,a,&lda,ipiv,b,&ldb,work,&lwork,&info)
-     callprotoargument char*,F_INT*,F_INT*,<ctype2c>*,F_INT*,F_INT*,<ctype2c>*,F_INT*,<ctype2c>*,F_INT*,F_INT*
+     callstatement (*f2py_func)((lower?"L":"U"),&n,&nrhs,a,&lda,ipiv,b,&ldb,work,&lwork,&info,len0)
+     callprotoargument char*,F_INT*,F_INT*,<ctype2c>*,F_INT*,F_INT*,<ctype2c>*,F_INT*,<ctype2c>*,F_INT*,F_INT*,F_INT
 
      integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
      integer depend(a),intent(hide):: n = shape(a,0)
@@ -607,15 +642,16 @@ end subroutine <prefix2c>heevd_lwork
      <ftype2c> depend(lwork),dimension(MAX(lwork,1)),intent(hide,cache):: work
      integer intent(out):: info
 
+    integer intent(hide) :: len0 = 1
    end subroutine <prefix2c>hesv
 
-   subroutine <prefix2c>hesv_lwork(n,nrhs,a,lda,ipiv,b,ldb,work,lwork,info,lower)
+   subroutine <prefix2c>hesv_lwork(n,nrhs,a,lda,ipiv,b,ldb,work,lwork,info,lower,len0)
 
    ! lwork computation for C/ZHESV
 
      fortranname <prefix2c>hesv
-     callstatement (*f2py_func)((lower?"L":"U"),&n,&nrhs,&a,&lda,&ipiv,&b,&ldb,&work,&lwork,&info)
-     callprotoargument char*,F_INT*,F_INT*,<ctype2c>*,F_INT*,F_INT*,<ctype2c>*,F_INT*,<ctype2c>*,F_INT*,F_INT*
+     callstatement (*f2py_func)((lower?"L":"U"),&n,&nrhs,&a,&lda,&ipiv,&b,&ldb,&work,&lwork,&info,len0)
+     callprotoargument char*,F_INT*,F_INT*,<ctype2c>*,F_INT*,F_INT*,<ctype2c>*,F_INT*,<ctype2c>*,F_INT*,F_INT*,F_INT
 
      integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
      integer intent(in):: n
@@ -631,17 +667,18 @@ end subroutine <prefix2c>heevd_lwork
      <ftype2c> intent(out):: work
      integer intent(out):: info
 
+    integer intent(hide) :: len0 = 1
    end subroutine <prefix2c>hesv_lwork
 
-subroutine <prefix2c>hesvx(n,nrhs,a,lda,af,ldaf,ipiv,b,ldb,x,ldx,rcond,ferr,berr,work,lwork,rwork,info,factored,lower)
+subroutine <prefix2c>hesvx(n,nrhs,a,lda,af,ldaf,ipiv,b,ldb,x,ldx,rcond,ferr,berr,work,lwork,rwork,info,factored,lower,len0,len1)
    ! Solves A * X = B for X
    ! Expert driver for ?HESV
    ! A is hermitian. For symmetric A see ?SYSVX
    ! A = U * D * U**H if lower = 0
    ! A = L * D * L**H if lower = 1
     threadsafe
-    callstatement (*f2py_func)((factored?"F":"N"),(lower?"L":"U"),&n,&nrhs,a,&lda,af,&ldaf,ipiv,b,&ldb,x,&ldx,&rcond,ferr,berr,work,&lwork,rwork,&info)
-    callprotoargument char*,char*,F_INT*,F_INT*,<ctype2c>*,F_INT*,<ctype2c>*,F_INT*,F_INT*,<ctype2c>*,F_INT*,<ctype2c>*,F_INT*,<ctype2>*,<ctype2>*,<ctype2>*,<ctype2c>*,F_INT*,<ctype2>*,F_INT*
+    callstatement (*f2py_func)((factored?"F":"N"),(lower?"L":"U"),&n,&nrhs,a,&lda,af,&ldaf,ipiv,b,&ldb,x,&ldx,&rcond,ferr,berr,work,&lwork,rwork,&info,len0,len1)
+    callprotoargument char*,char*,F_INT*,F_INT*,<ctype2c>*,F_INT*,<ctype2c>*,F_INT*,F_INT*,<ctype2c>*,F_INT*,<ctype2c>*,F_INT*,<ctype2>*,<ctype2>*,<ctype2>*,<ctype2c>*,F_INT*,<ctype2>*,F_INT*,F_INT,F_INT
 
     integer optional,intent(in),check(factored==0||factored==1) :: factored = 0
     integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
@@ -664,13 +701,15 @@ subroutine <prefix2c>hesvx(n,nrhs,a,lda,af,ldaf,ipiv,b,ldb,x,ldx,rcond,ferr,berr
     <ftype2> intent(hide,cache),dimension(n),depend(n) :: rwork
     integer intent(out):: info
 
+    integer intent(hide) :: len0 = 1
+    integer intent(hide) :: len1 = 1
 end subroutine <prefix2c>hesvx
 
-subroutine <prefix2c>hesvx_lwork(n,nrhs,a,lda,af,ldaf,ipiv,b,ldb,x,ldx,rcond,ferr,berr,work,lwork,rwork,info,factored,lower)
+subroutine <prefix2c>hesvx_lwork(n,nrhs,a,lda,af,ldaf,ipiv,b,ldb,x,ldx,rcond,ferr,berr,work,lwork,rwork,info,factored,lower,len0,len1)
     ! lwork computation for ?HESVX
     fortranname <prefix2c>hesvx
-    callstatement (*f2py_func)((factored?"F":"N"),(lower?"L":"U"),&n,&nrhs,&a,&lda,&af,&ldaf,&ipiv,&b,&ldb,&x,&ldx,&rcond,&ferr,&berr,&work,&lwork,&rwork,&info)
-    callprotoargument char*,char*,F_INT*,F_INT*,<ctype2c>*,F_INT*,<ctype2c>*,F_INT*,F_INT*,<ctype2c>*,F_INT*,<ctype2c>*,F_INT*,<ctype2>*,<ctype2>*,<ctype2>*,<ctype2c>*,F_INT*,<ctype2>*,F_INT*
+    callstatement (*f2py_func)((factored?"F":"N"),(lower?"L":"U"),&n,&nrhs,&a,&lda,&af,&ldaf,&ipiv,&b,&ldb,&x,&ldx,&rcond,&ferr,&berr,&work,&lwork,&rwork,&info,len0,len1)
+    callprotoargument char*,char*,F_INT*,F_INT*,<ctype2c>*,F_INT*,<ctype2c>*,F_INT*,F_INT*,<ctype2c>*,F_INT*,<ctype2c>*,F_INT*,<ctype2>*,<ctype2>*,<ctype2>*,<ctype2c>*,F_INT*,<ctype2>*,F_INT*,F_INT,F_INT
 
     integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
     integer intent(in):: n
@@ -695,15 +734,17 @@ subroutine <prefix2c>hesvx_lwork(n,nrhs,a,lda,af,ldaf,ipiv,b,ldb,x,ldx,rcond,fer
     <ftype2c> intent(out):: work
     integer intent(out):: info
 
+    integer intent(hide) :: len0 = 1
+    integer intent(hide) :: len1 = 1
 end subroutine <prefix2c>hesvx_lwork
 
-subroutine <prefix2>sytrd(lower,n,a,lda,d,e,tau,work,lwork,info)
+subroutine <prefix2>sytrd(lower,n,a,lda,d,e,tau,work,lwork,info,len0)
     ! Reduce a real symmetric matrix A to real symmetric
     ! tridiagonal form T by an orthogonal similarity transformation:
     ! Q**T * A * Q = T.
 
-    callstatement (*f2py_func)((lower?"L":"U"),&n,a,&lda,d,e,tau,work,&lwork,&info);
-    callprotoargument char*,F_INT*,<ctype2>*,F_INT*,<ctype2>*,<ctype2>*,<ctype2>*,<ctype2>*,F_INT*,F_INT*
+    callstatement (*f2py_func)((lower?"L":"U"),&n,a,&lda,d,e,tau,work,&lwork,&info,len0);
+    callprotoargument char*,F_INT*,<ctype2>*,F_INT*,<ctype2>*,<ctype2>*,<ctype2>*,<ctype2>*,F_INT*,F_INT*,F_INT
 
     integer intent(hide),depend(a) :: lda=MAX(shape(a,0),1)
     integer intent(hide),depend(a) :: n=shape(a,1)
@@ -717,13 +758,14 @@ subroutine <prefix2>sytrd(lower,n,a,lda,d,e,tau,work,lwork,info)
     <ftype2> dimension(lwork),intent(cache,hide),depend(lwork) :: work
     integer intent(out) :: info
 
+    integer intent(hide) :: len0 = 1
 end subroutine <prefix2>sytrd
 
-subroutine <prefix2>sytrd_lwork(lower,n,a,lda,d,e,tau,work,lwork,info)
+subroutine <prefix2>sytrd_lwork(lower,n,a,lda,d,e,tau,work,lwork,info,len0)
     ! lwork computation for sytrd
     fortranname <prefix2>sytrd
-    callstatement (*f2py_func)((lower?"L":"U"),&n,&a,&lda,&d,&e,&tau,&work,&lwork,&info);
-    callprotoargument char*,F_INT*,<ctype2>*,F_INT*,<ctype2>*,<ctype2>*,<ctype2>*,<ctype2>*,F_INT*,F_INT*
+    callstatement (*f2py_func)((lower?"L":"U"),&n,&a,&lda,&d,&e,&tau,&work,&lwork,&info,len0);
+    callprotoargument char*,F_INT*,<ctype2>*,F_INT*,<ctype2>*,<ctype2>*,<ctype2>*,<ctype2>*,F_INT*,F_INT*,F_INT
 
     integer intent(in) :: n
     integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
@@ -737,15 +779,16 @@ subroutine <prefix2>sytrd_lwork(lower,n,a,lda,d,e,tau,work,lwork,info)
     integer intent(hide) :: lwork = -1
     integer intent(out) :: info
 
+    integer intent(hide) :: len0 = 1
 end subroutine <prefix2>sytrd_lwork
 
-subroutine <prefix2c>hetrd(lower,n,a,lda,d,e,tau,work,lwork,info)
+subroutine <prefix2c>hetrd(lower,n,a,lda,d,e,tau,work,lwork,info,len0)
     ! Reduce a complex hermitian matrix A to real symmetric
     ! tridiagonal form T by an orthogonal similarity transformation:
     ! Q**H * A * Q = T.
 
-    callstatement (*f2py_func)((lower?"L":"U"),&n,a,&lda,d,e,tau,work,&lwork,&info);
-    callprotoargument char*,F_INT*,<ctype2c>*,F_INT*,<ctype2>*,<ctype2>*,<ctype2c>*,<ctype2c>*,F_INT*,F_INT*
+    callstatement (*f2py_func)((lower?"L":"U"),&n,a,&lda,d,e,tau,work,&lwork,&info,len0);
+    callprotoargument char*,F_INT*,<ctype2c>*,F_INT*,<ctype2>*,<ctype2>*,<ctype2c>*,<ctype2c>*,F_INT*,F_INT*,F_INT
 
     integer intent(hide),depend(a) :: lda=MAX(shape(a,0),1)
     integer intent(hide),depend(a) :: n=shape(a,1)
@@ -759,13 +802,14 @@ subroutine <prefix2c>hetrd(lower,n,a,lda,d,e,tau,work,lwork,info)
     <ftype2c> dimension(lwork),intent(cache,hide),depend(lwork) :: work
     integer intent(out) :: info
 
+    integer intent(hide) :: len0 = 1
 end subroutine <prefix2c>hetrd
 
-subroutine <prefix2c>hetrd_lwork(lower,n,a,lda,d,e,tau,work,lwork,info)
+subroutine <prefix2c>hetrd_lwork(lower,n,a,lda,d,e,tau,work,lwork,info,len0)
     ! lwork computation for hetrd
     fortranname <prefix2c>hetrd
-    callstatement (*f2py_func)((lower?"L":"U"),&n,&a,&lda,&d,&e,&tau,&work,&lwork,&info);
-    callprotoargument char*,F_INT*,<ctype2c>*,F_INT*,<ctype2>*,<ctype2>*,<ctype2c>*,<ctype2c>*,F_INT*,F_INT*
+    callstatement (*f2py_func)((lower?"L":"U"),&n,&a,&lda,&d,&e,&tau,&work,&lwork,&info,len0);
+    callprotoargument char*,F_INT*,<ctype2c>*,F_INT*,<ctype2>*,<ctype2>*,<ctype2c>*,<ctype2c>*,F_INT*,F_INT*,F_INT
 
     integer intent(in) :: n
     integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
@@ -779,9 +823,10 @@ subroutine <prefix2c>hetrd_lwork(lower,n,a,lda,d,e,tau,work,lwork,info)
     integer intent(hide) :: lwork = -1
     integer intent(out) :: info
 
+    integer intent(hide) :: len0 = 1
 end subroutine <prefix2c>hetrd_lwork
 
-subroutine <prefix2>syevr(compute_v,range,lower,n,a,lda,vl,vu,il,iu,abstol,w,z,m,ldz,isuppz,work,lwork,iwork,liwork,info)
+subroutine <prefix2>syevr(compute_v,range,lower,n,a,lda,vl,vu,il,iu,abstol,w,z,m,ldz,isuppz,work,lwork,iwork,liwork,info,len0,len1,len2)
     ! Standard Symmetric/HermitianEigenvalue Problem
     ! Real - Single precision / Double precision
     !
@@ -790,8 +835,8 @@ subroutine <prefix2>syevr(compute_v,range,lower,n,a,lda,vl,vu,il,iu,abstol,w,z,m
     ! if jobz = 'V' and range = 'V', z is (nxn) since returned number of eigs is unknown beforehand
     ! if jobz = 'V' and range = 'I', z is (nx(iu-il+1))
 
-    callstatement (*f2py_func)((compute_v?"V":"N"),range,(lower?"L":"U"),&n,a,&lda,&vl,&vu,&il,&iu,&abstol,&m,w,z,&ldz,isuppz,work,&lwork,iwork,&liwork,&info)
-    callprotoargument char*,char*,char*,F_INT*,<ctype2>*,F_INT*,<ctype2>*,<ctype2>*,F_INT*,F_INT*,<ctype2>*,F_INT*,<ctype2>*,<ctype2>*,F_INT*,F_INT*,<ctype2>*,F_INT*,F_INT*,F_INT*,F_INT*
+    callstatement (*f2py_func)((compute_v?"V":"N"),range,(lower?"L":"U"),&n,a,&lda,&vl,&vu,&il,&iu,&abstol,&m,w,z,&ldz,isuppz,work,&lwork,iwork,&liwork,&info,len0,len1,len2)
+    callprotoargument char*,char*,char*,F_INT*,<ctype2>*,F_INT*,<ctype2>*,<ctype2>*,F_INT*,F_INT*,<ctype2>*,F_INT*,<ctype2>*,<ctype2>*,F_INT*,F_INT*,<ctype2>*,F_INT*,F_INT*,F_INT*,F_INT*,F_INT,F_INT,F_INT
 
     <ftype2> intent(in,copy,aligned8),check(shape(a,0)==shape(a,1)),dimension(n,n) :: a
     integer optional,intent(in),check(compute_v==1||compute_v==0):: compute_v = 1
@@ -818,13 +863,16 @@ subroutine <prefix2>syevr(compute_v,range,lower,n,a,lda,vl,vu,il,iu,abstol,w,z,m
     integer intent(out),dimension((compute_v?(2*((*range=='A')||((*range=='I') && (iu-il+1==n))?n:0)):0)),depend(n,iu,il,compute_v,range) :: isuppz
     integer intent(out) :: info
 
+    integer intent(hide) :: len0 = 1
+    integer intent(hide) :: len1 = 1
+    integer intent(hide) :: len2 = 1
 end subroutine <prefix2>syevr
 
-subroutine <prefix2>syevr_lwork(lower,n,a,lda,vl,vu,il,iu,abstol,m,w,z,ldz,isuppz,work,lwork,iwork,liwork,info)
+subroutine <prefix2>syevr_lwork(lower,n,a,lda,vl,vu,il,iu,abstol,m,w,z,ldz,isuppz,work,lwork,iwork,liwork,info,len0,len1,len2)
     ! LWORK routines for (s/d)syevr
     fortranname <prefix2>syevr
-    callstatement (*f2py_func)("N","A",(lower?"L":"U"),&n,&a,&lda,&vl,&vu,&il,&iu,&abstol,&m,&w,&z,&ldz,&isuppz,&work,&lwork,&iwork,&liwork,&info)
-    callprotoargument char*,char*,char*,F_INT*,<ctype2>*,F_INT*,<ctype2>*,<ctype2>*,F_INT*,F_INT*,<ctype2>*,F_INT*,<ctype2>*,<ctype2>*,F_INT*,F_INT*,<ctype2>*,F_INT*,F_INT*,F_INT*,F_INT*
+    callstatement (*f2py_func)("N","A",(lower?"L":"U"),&n,&a,&lda,&vl,&vu,&il,&iu,&abstol,&m,&w,&z,&ldz,&isuppz,&work,&lwork,&iwork,&liwork,&info,len0,len1,len2)
+    callprotoargument char*,char*,char*,F_INT*,<ctype2>*,F_INT*,<ctype2>*,<ctype2>*,F_INT*,F_INT*,<ctype2>*,F_INT*,<ctype2>*,<ctype2>*,F_INT*,F_INT*,<ctype2>*,F_INT*,F_INT*,F_INT*,F_INT*,F_INT,F_INT,F_INT
 
     ! Inputs
     integer intent(in):: n
@@ -849,9 +897,12 @@ subroutine <prefix2>syevr_lwork(lower,n,a,lda,vl,vu,il,iu,abstol,m,w,z,ldz,isupp
     integer intent(out) :: iwork
     integer intent(out) :: info
 
+    integer intent(hide) :: len0 = 1
+    integer intent(hide) :: len1 = 1
+    integer intent(hide) :: len2 = 1
 end subroutine <prefix2>syevr_lwork
 
-subroutine <prefix2c>heevr(compute_v,range,lower,n,a,lda,vl,vu,il,iu,abstol,w,z,m,ldz,isuppz,work,lwork,rwork,lrwork,iwork,liwork,info)
+subroutine <prefix2c>heevr(compute_v,range,lower,n,a,lda,vl,vu,il,iu,abstol,w,z,m,ldz,isuppz,work,lwork,rwork,lrwork,iwork,liwork,info,len0,len1,len2)
     ! Standard Symmetric/HermitianEigenvalue Problem
     ! Complex - Single precision / Double precision
     !
@@ -860,8 +911,8 @@ subroutine <prefix2c>heevr(compute_v,range,lower,n,a,lda,vl,vu,il,iu,abstol,w,z,
     ! if jobz = 'V' and range = 'V', z is (nxn) since returned number of eigs is unknown beforehand
     ! if jobz = 'V' and range = 'I', z is (nx(iu-il+1))
 
-    callstatement (*f2py_func)((compute_v?"V":"N"),range,(lower?"L":"U"),&n,a,&lda,&vl,&vu,&il,&iu,&abstol,&m,w,z,&ldz,isuppz,work,&lwork,rwork,&lrwork,iwork,&liwork,&info)
-    callprotoargument char*,char*,char*,F_INT*,<ctype2c>*,F_INT*,<ctype2>*,<ctype2>*,F_INT*,F_INT*,<ctype2>*,F_INT*,<ctype2>*,<ctype2c>*,F_INT*,F_INT*,<ctype2c>*,F_INT*,<ctype2>*,F_INT*,F_INT*,F_INT*,F_INT*
+    callstatement (*f2py_func)((compute_v?"V":"N"),range,(lower?"L":"U"),&n,a,&lda,&vl,&vu,&il,&iu,&abstol,&m,w,z,&ldz,isuppz,work,&lwork,rwork,&lrwork,iwork,&liwork,&info,len0,len1,len2)
+    callprotoargument char*,char*,char*,F_INT*,<ctype2c>*,F_INT*,<ctype2>*,<ctype2>*,F_INT*,F_INT*,<ctype2>*,F_INT*,<ctype2>*,<ctype2c>*,F_INT*,F_INT*,<ctype2c>*,F_INT*,<ctype2>*,F_INT*,F_INT*,F_INT*,F_INT*,F_INT,F_INT,F_INT
 
     <ftype2c> intent(in,copy,aligned8),check(shape(a,0)==shape(a,1)),dimension(n,n) :: a
     integer optional,intent(in),check(compute_v==1||compute_v==0):: compute_v = 1
@@ -897,13 +948,16 @@ subroutine <prefix2c>heevr(compute_v,range,lower,n,a,lda,vl,vu,il,iu,abstol,w,z,
     integer intent(out),dimension(2*max(1,n)),depend(n) :: isuppz
     integer intent(out) :: info
 
+    integer intent(hide) :: len0 = 1
+    integer intent(hide) :: len1 = 1
+    integer intent(hide) :: len2 = 1
 end subroutine <prefix2c>heevr
 
-subroutine <prefix2c>heevr_lwork(n,lower,a,lda,vl,vu,il,iu,abstol,m,w,z,ldz,isuppz,work,lwork,rwork,lrwork,iwork,liwork,info)
+subroutine <prefix2c>heevr_lwork(n,lower,a,lda,vl,vu,il,iu,abstol,m,w,z,ldz,isuppz,work,lwork,rwork,lrwork,iwork,liwork,info,len0,len1,len2)
     ! LWORK routines for (c/z)heevr
     fortranname <prefix2c>heevr
-    callstatement (*f2py_func)("N","A",(lower?"L":"U"),&n,&a,&lda,&vl,&vu,&il,&iu,&abstol,&m,&w,&z,&ldz,&isuppz,&work,&lwork,&rwork,&lrwork,&iwork,&liwork,&info)
-    callprotoargument char*,char*,char*,F_INT*,<ctype2c>*,F_INT*,<ctype2>*,<ctype2>*,F_INT*,F_INT*,<ctype2>*,F_INT*,<ctype2>*,<ctype2c>*,F_INT*,F_INT*,<ctype2c>*,F_INT*,<ctype2>*,F_INT*,F_INT*,F_INT*,F_INT*
+    callstatement (*f2py_func)("N","A",(lower?"L":"U"),&n,&a,&lda,&vl,&vu,&il,&iu,&abstol,&m,&w,&z,&ldz,&isuppz,&work,&lwork,&rwork,&lrwork,&iwork,&liwork,&info,len0,len1,len2)
+    callprotoargument char*,char*,char*,F_INT*,<ctype2c>*,F_INT*,<ctype2>*,<ctype2>*,F_INT*,F_INT*,<ctype2>*,F_INT*,<ctype2>*,<ctype2c>*,F_INT*,F_INT*,<ctype2c>*,F_INT*,<ctype2>*,F_INT*,F_INT*,F_INT*,F_INT*,F_INT,F_INT,F_INT
 
     ! Inputs
     integer intent(in):: n
@@ -930,16 +984,19 @@ subroutine <prefix2c>heevr_lwork(n,lower,a,lda,vl,vu,il,iu,abstol,m,w,z,ldz,isup
     integer intent(out) :: iwork
     integer intent(out) :: info
 
+    integer intent(hide) :: len0 = 1
+    integer intent(hide) :: len1 = 1
+    integer intent(hide) :: len2 = 1
 end subroutine <prefix2c>heevr_work
 
-subroutine <prefix2>syevx(compute_v,range,lower,n,a,lda,vl,vu,il,iu,abstol,w,z,m,ldz,work,lwork,iwork,ifail,info)
+subroutine <prefix2>syevx(compute_v,range,lower,n,a,lda,vl,vu,il,iu,abstol,w,z,m,ldz,work,lwork,iwork,ifail,info,len0,len1,len2)
     ! DSYEVX computes selected eigenvalues and, optionally, eigenvectors
     ! of a real symmetric matrix A.  Eigenvalues and eigenvectors can be
     ! selected by specifying either a range of values or a range of indices
     ! for the desired eigenvalues.
 
-    callstatement (*f2py_func)((compute_v?"V":"N"),range,(lower?"L":"U"),&n,a,&lda,&vl,&vu,&il,&iu,&abstol,&m,w,z,&ldz,work,&lwork,iwork,ifail,&info)
-    callprotoargument char*,char*,char*,F_INT*,<ctype2>*,F_INT*,<ctype2>*,<ctype2>*,F_INT*,F_INT*,<ctype2>*,F_INT*,<ctype2>*,<ctype2>*,F_INT*,<ctype2>*,F_INT*,F_INT*,F_INT*,F_INT*
+    callstatement (*f2py_func)((compute_v?"V":"N"),range,(lower?"L":"U"),&n,a,&lda,&vl,&vu,&il,&iu,&abstol,&m,w,z,&ldz,work,&lwork,iwork,ifail,&info,len0,len1,len2)
+    callprotoargument char*,char*,char*,F_INT*,<ctype2>*,F_INT*,<ctype2>*,<ctype2>*,F_INT*,F_INT*,<ctype2>*,F_INT*,<ctype2>*,<ctype2>*,F_INT*,<ctype2>*,F_INT*,F_INT*,F_INT*,F_INT*,F_INT,F_INT,F_INT
     
     integer optional,intent(in),check(compute_v==1||compute_v==0):: compute_v = 1
     character optional,intent(in),check(*range=='A'||*range=='V' ||*range=='I') :: range='A'
@@ -964,14 +1021,17 @@ subroutine <prefix2>syevx(compute_v,range,lower,n,a,lda,vl,vu,il,iu,abstol,w,z,m
     integer intent(out),dimension((compute_v?n:0)),depend(compute_v,n):: ifail
     integer intent(out) :: info
     
+    integer intent(hide) :: len0 = 1
+    integer intent(hide) :: len1 = 1
+    integer intent(hide) :: len2 = 1
 end subroutine <prefix2>syevx
 
-subroutine <prefix2>syevx_lwork(lower,n,a,lda,vl,vu,il,iu,abstol,m,w,z,ldz,work,lwork,iwork,ifail,info)
+subroutine <prefix2>syevx_lwork(lower,n,a,lda,vl,vu,il,iu,abstol,m,w,z,ldz,work,lwork,iwork,ifail,info,len0,len1,len2)
     ! LWORK routines for (d/s)syevx
 
     fortranname <prefix2>syevx
-    callstatement (*f2py_func)("N","A",(lower?"L":"U"),&n,&a,&lda,&vl,&vu,&il,&iu,&abstol,&m,&w,&z,&ldz,&work,&lwork,&iwork,&ifail,&info)
-    callprotoargument char*,char*,char*,F_INT*,<ctype2>*,F_INT*,<ctype2>*,<ctype2>*,F_INT*,F_INT*,<ctype2>*,F_INT*,<ctype2>*,<ctype2>*,F_INT*,<ctype2>*,F_INT*,F_INT*,F_INT*,F_INT*
+    callstatement (*f2py_func)("N","A",(lower?"L":"U"),&n,&a,&lda,&vl,&vu,&il,&iu,&abstol,&m,&w,&z,&ldz,&work,&lwork,&iwork,&ifail,&info,len0,len1,len2)
+    callprotoargument char*,char*,char*,F_INT*,<ctype2>*,F_INT*,<ctype2>*,<ctype2>*,F_INT*,F_INT*,<ctype2>*,F_INT*,<ctype2>*,<ctype2>*,F_INT*,<ctype2>*,F_INT*,F_INT*,F_INT*,F_INT*,F_INT,F_INT,F_INT
     
     integer intent(in):: n
     integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
@@ -994,16 +1054,19 @@ subroutine <prefix2>syevx_lwork(lower,n,a,lda,vl,vu,il,iu,abstol,m,w,z,ldz,work,
     <ftype2> intent(out):: work
     integer intent(out):: info
 
+    integer intent(hide) :: len0 = 1
+    integer intent(hide) :: len1 = 1
+    integer intent(hide) :: len2 = 1
 end subroutine <prefix2>syevx_lwork
 
-subroutine <prefix2c>heevx(compute_v,range,lower,n,a,lda,vl,vu,il,iu,abstol,w,z,m,ldz,work,lwork,rwork,iwork,ifail,info)
+subroutine <prefix2c>heevx(compute_v,range,lower,n,a,lda,vl,vu,il,iu,abstol,w,z,m,ldz,work,lwork,rwork,iwork,ifail,info,len0,len1,len2)
     ! (C/Z)HEEVX computes selected eigenvalues and, optionally, eigenvectors
     ! of a complex Hermitian matrix A.  Eigenvalues and eigenvectors can
     ! be selected by specifying either a range of values or a range of
     ! indices for the desired eigenvalues.
 
-    callstatement (*f2py_func)((compute_v?"V":"N"),range,(lower?"L":"U"),&n,a,&lda,&vl,&vu,&il,&iu,&abstol,&m,w,z,&ldz,work,&lwork,rwork,iwork,ifail,&info)
-    callprotoargument char*,char*,char*,F_INT*,<ctype2c>*,F_INT*,<ctype2>*,<ctype2>*,F_INT*,F_INT*,<ctype2>*,F_INT*,<ctype2>*,<ctype2c>*,F_INT*,<ctype2c>*,F_INT*,<ctype2>*,F_INT*,F_INT*,F_INT*
+    callstatement (*f2py_func)((compute_v?"V":"N"),range,(lower?"L":"U"),&n,a,&lda,&vl,&vu,&il,&iu,&abstol,&m,w,z,&ldz,work,&lwork,rwork,iwork,ifail,&info,len0,len1,len2)
+    callprotoargument char*,char*,char*,F_INT*,<ctype2c>*,F_INT*,<ctype2>*,<ctype2>*,F_INT*,F_INT*,<ctype2>*,F_INT*,<ctype2>*,<ctype2c>*,F_INT*,<ctype2c>*,F_INT*,<ctype2>*,F_INT*,F_INT*,F_INT*,F_INT,F_INT,F_INT
     
     integer optional,intent(in),check(compute_v==1||compute_v==0):: compute_v = 1
     character optional,intent(in),check(*range=='A'||*range=='V' ||*range=='I') :: range='A'
@@ -1029,14 +1092,17 @@ subroutine <prefix2c>heevx(compute_v,range,lower,n,a,lda,vl,vu,il,iu,abstol,w,z,
     integer intent(out),dimension(compute_v*n),depend(compute_v,n):: ifail
     integer intent(out) :: info
     
+    integer intent(hide) :: len0 = 1
+    integer intent(hide) :: len1 = 1
+    integer intent(hide) :: len2 = 1
 end subroutine <prefix2c>heevx
 
-subroutine <prefix2c>heevx_lwork(lower,n,a,lda,vl,vu,il,iu,abstol,m,w,z,ldz,work,lwork,rwork,iwork,ifail,info)
+subroutine <prefix2c>heevx_lwork(lower,n,a,lda,vl,vu,il,iu,abstol,m,w,z,ldz,work,lwork,rwork,iwork,ifail,info,len0,len1,len2)
     ! LWORK routines for (c/z)heevx
 
     fortranname <prefix2c>heevx
-    callstatement (*f2py_func)("N","A",(lower?"L":"U"),&n,&a,&lda,&vl,&vu,&il,&iu,&abstol,&m,&w,&z,&ldz,&work,&lwork,&rwork,&iwork,&ifail,&info)
-    callprotoargument char*,char*,char*,F_INT*,<ctype2c>*,F_INT*,<ctype2>*,<ctype2>*,F_INT*,F_INT*,<ctype2>*,F_INT*,<ctype2>*,<ctype2c>*,F_INT*,<ctype2c>*,F_INT*,<ctype2>*,F_INT*,F_INT*,F_INT*
+    callstatement (*f2py_func)("N","A",(lower?"L":"U"),&n,&a,&lda,&vl,&vu,&il,&iu,&abstol,&m,&w,&z,&ldz,&work,&lwork,&rwork,&iwork,&ifail,&info,len0,len1,len2)
+    callprotoargument char*,char*,char*,F_INT*,<ctype2c>*,F_INT*,<ctype2>*,<ctype2>*,F_INT*,F_INT*,<ctype2>*,F_INT*,<ctype2>*,<ctype2c>*,F_INT*,<ctype2c>*,F_INT*,<ctype2>*,F_INT*,F_INT*,F_INT*,F_INT,F_INT,F_INT
     
     integer intent(in):: n
     integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
@@ -1060,17 +1126,20 @@ subroutine <prefix2c>heevx_lwork(lower,n,a,lda,vl,vu,il,iu,abstol,m,w,z,ldz,work
     <ftype2c> intent(out):: work
     integer intent(out):: info
 
+    integer intent(hide) :: len0 = 1
+    integer intent(hide) :: len1 = 1
+    integer intent(hide) :: len2 = 1
 end subroutine <prefix2c>heevx_lwork
 
-subroutine <prefix2>sygv(itype,jobz,uplo,n,lda,ldb,w,a,b,work,lwork,info)
+subroutine <prefix2>sygv(itype,jobz,uplo,n,lda,ldb,w,a,b,work,lwork,info,len0,len1)
     ! Generalized Symmetric Eigenvalue Problem
     ! Real - Single precision / Double precision
     !
     ! if jobz = 'N' there are no eigvecs returned
     ! if jobz = 'V' 'a' contains eigvecs
 
-    callstatement (*f2py_func)(&itype,jobz,uplo,&n,a,&lda,b,&ldb,w,work,&lwork,&info)
-    callprotoargument F_INT*,char*,char*,F_INT*,<ctype2>*,F_INT*,<ctype2>*,F_INT*,<ctype2>*,<ctype2>*,F_INT*,F_INT*
+    callstatement (*f2py_func)(&itype,jobz,uplo,&n,a,&lda,b,&ldb,w,work,&lwork,&info,len0,len1)
+    callprotoargument F_INT*,char*,char*,F_INT*,<ctype2>*,F_INT*,<ctype2>*,F_INT*,<ctype2>*,<ctype2>*,F_INT*,F_INT*,F_INT,F_INT
     !                itype,jobz ,uplo , n  ,    a    ,lda ,    b    , ldb,   w     , work   ,lwork, info
 
     <ftype2> intent(in,copy,aligned8,out,out=v),check(shape(a,0)==shape(a,1)),dimension(n,n) :: a
@@ -1088,14 +1157,16 @@ subroutine <prefix2>sygv(itype,jobz,uplo,n,lda,ldb,w,a,b,work,lwork,info)
     <ftype2> intent(out),dimension(n),depend(n) :: w
     integer intent(out) :: info
 
+    integer intent(hide) :: len0 = 1
+    integer intent(hide) :: len1 = 1
 end subroutine <prefix2>sygv
 
-subroutine <prefix2>sygv_lwork(itype,jobz,uplo,n,a,lda,b,ldb,w,work,lwork,info)
+subroutine <prefix2>sygv_lwork(itype,jobz,uplo,n,a,lda,b,ldb,w,work,lwork,info,len0,len1)
     ! LWORK routine for (S,D)SYGV
 
     fortranname <prefix2>sygv
-    callstatement (*f2py_func)(&itype,jobz,uplo,&n,&a,&lda,&b,&ldb,&w,&work,&lwork,&info)
-    callprotoargument F_INT*,char*,char*,F_INT*,<ctype2>*,F_INT*,<ctype2>*,F_INT*,<ctype2>*,<ctype2>*,F_INT*,F_INT*
+    callstatement (*f2py_func)(&itype,jobz,uplo,&n,&a,&lda,&b,&ldb,&w,&work,&lwork,&info,len0,len1)
+    callprotoargument F_INT*,char*,char*,F_INT*,<ctype2>*,F_INT*,<ctype2>*,F_INT*,<ctype2>*,<ctype2>*,F_INT*,F_INT*,F_INT,F_INT
 
     ! Inputs
     integer intent(in):: n
@@ -1113,17 +1184,19 @@ subroutine <prefix2>sygv_lwork(itype,jobz,uplo,n,a,lda,b,ldb,w,work,lwork,info)
     <ftype2> intent(out) :: work
     integer intent(out) :: info
 
+    integer intent(hide) :: len0 = 1
+    integer intent(hide) :: len1 = 1
 end subroutine <prefix2>sygv_lwork
 
-subroutine <prefix2c>hegv(itype,jobz,uplo,n,lda,ldb,w,a,b,work,lwork,rwork,info)
+subroutine <prefix2c>hegv(itype,jobz,uplo,n,lda,ldb,w,a,b,work,lwork,rwork,info,len0,len1)
     ! Generalized Symmetric Eigenvalue Problem
     ! Complex - Single precision / Double precision
     !
     ! if jobz = 'N' there are no eigvecs returned
     ! if jobz = 'V' 'a' contains eigvecs
 
-    callstatement (*f2py_func)(&itype,jobz,uplo,&n,a,&lda,b,&ldb,w,work,&lwork,rwork,&info)
-    callprotoargument F_INT*,char*,char*,F_INT*,<ctype2c>*,F_INT*,<ctype2c>*,F_INT*,<ctype2>*,<ctype2c>*,F_INT*,<ctype2>*,F_INT*
+    callstatement (*f2py_func)(&itype,jobz,uplo,&n,a,&lda,b,&ldb,w,work,&lwork,rwork,&info,len0,len1)
+    callprotoargument F_INT*,char*,char*,F_INT*,<ctype2c>*,F_INT*,<ctype2c>*,F_INT*,<ctype2>*,<ctype2c>*,F_INT*,<ctype2>*,F_INT*,F_INT,F_INT
     !                itype,jobz ,uplo , n  ,    a     ,lda ,    b     , ldb,   w     , work     ,lwork,rwork   ,info
 
     <ftype2c> intent(in,copy,aligned8,out,out=v),check(shape(a,0)==shape(a,1)),dimension(n,n) :: a
@@ -1142,14 +1215,16 @@ subroutine <prefix2c>hegv(itype,jobz,uplo,n,lda,ldb,w,a,b,work,lwork,rwork,info)
     <ftype2> intent(out),dimension(n),depend(n) :: w
     integer intent(out) :: info
 
+    integer intent(hide) :: len0 = 1
+    integer intent(hide) :: len1 = 1
 end subroutine <prefix2c>hegv
 
-subroutine <prefix2c>hegv_lwork(itype,jobz,uplo,n,a,lda,b,ldb,w,work,lwork,rwork,info)
+subroutine <prefix2c>hegv_lwork(itype,jobz,uplo,n,a,lda,b,ldb,w,work,lwork,rwork,info,len0,len1)
     ! LWORK Query routine for (c/z)hegv
 
     fortranname <prefix2c>hegv
-    callstatement (*f2py_func)(&itype,jobz,uplo,&n,&a,&lda,&b,&ldb,&w,&work,&lwork,&rwork,&info)
-    callprotoargument F_INT*,char*,char*,F_INT*,<ctype2c>*,F_INT*,<ctype2c>*,F_INT*,<ctype2>*,<ctype2c>*,F_INT*,<ctype2>*,F_INT*
+    callstatement (*f2py_func)(&itype,jobz,uplo,&n,&a,&lda,&b,&ldb,&w,&work,&lwork,&rwork,&info,len0,len1)
+    callprotoargument F_INT*,char*,char*,F_INT*,<ctype2c>*,F_INT*,<ctype2c>*,F_INT*,<ctype2>*,<ctype2c>*,F_INT*,<ctype2>*,F_INT*,F_INT,F_INT
 
     ! Inputs
     integer intent(in):: n
@@ -1168,17 +1243,19 @@ subroutine <prefix2c>hegv_lwork(itype,jobz,uplo,n,a,lda,b,ldb,w,work,lwork,rwork
     <ftype2c> intent(out) :: work
     integer intent(out) :: info
 
+    integer intent(hide) :: len0 = 1
+    integer intent(hide) :: len1 = 1
 end subroutine <prefix2c>hegv_lwork
 
 !
 ! Divide and conquer routines for generalized eigenvalue problem
 !
-subroutine <prefix2>sygvd(itype,jobz,uplo,n,lda,ldb,w,a,b,work,lwork,iwork,liwork,info)
+subroutine <prefix2>sygvd(itype,jobz,uplo,n,lda,ldb,w,a,b,work,lwork,iwork,liwork,info,len0,len1)
 
     ! No call to ILAENV is performed. Hence no need for (d/s)sygvd_lwork. Default sizes are optimal.
 
-    callstatement (*f2py_func)(&itype,jobz,uplo,&n,a,&lda,b,&ldb,w,work,&lwork,iwork,&liwork,&info)
-    callprotoargument F_INT*,char*,char*,F_INT*,<ctype2>*,F_INT*,<ctype2>*,F_INT*,<ctype2>*,<ctype2>*,F_INT*,F_INT*,F_INT*,F_INT*
+    callstatement (*f2py_func)(&itype,jobz,uplo,&n,a,&lda,b,&ldb,w,work,&lwork,iwork,&liwork,&info,len0,len1)
+    callprotoargument F_INT*,char*,char*,F_INT*,<ctype2>*,F_INT*,<ctype2>*,F_INT*,<ctype2>*,<ctype2>*,F_INT*,F_INT*,F_INT*,F_INT*,F_INT,F_INT
 
     <ftype2> intent(in,copy,aligned8,out,out=v),check(shape(a,0)==shape(a,1)),dimension(n,n) :: a
     <ftype2> intent(in,copy,aligned8),check(shape(b,0)==shape(b,1)),check(shape(b,0)==n),dimension(n,n),depend(n) :: b
@@ -1197,14 +1274,16 @@ subroutine <prefix2>sygvd(itype,jobz,uplo,n,lda,ldb,w,a,b,work,lwork,iwork,liwor
     <ftype2> intent(out),dimension(n),depend(n) :: w
     integer intent(out) :: info
 
+    integer intent(hide) :: len0 = 1
+    integer intent(hide) :: len1 = 1
 end subroutine <prefix2>sygvd
 
-subroutine <prefix2c>hegvd(itype,jobz,uplo,n,lda,ldb,w,a,b,work,lwork,rwork,lrwork,iwork,liwork,info)
+subroutine <prefix2c>hegvd(itype,jobz,uplo,n,lda,ldb,w,a,b,work,lwork,rwork,lrwork,iwork,liwork,info,len0,len1)
 
     ! No call to ILAENV is performed. Hence no need for (c/z)hegvd_lwork. Default sizes are optimal.
 
-    callstatement (*f2py_func)(&itype,jobz,uplo,&n,a,&lda,b,&ldb,w,work,&lwork,rwork,&lrwork,iwork,&liwork,&info)
-    callprotoargument F_INT*,char*,char*,F_INT*,<ctype2c>*,F_INT*,<ctype2c>*,F_INT*,<ctype2>*,<ctype2c>*,F_INT*,<ctype2>*,F_INT*,F_INT*,F_INT*,F_INT*
+    callstatement (*f2py_func)(&itype,jobz,uplo,&n,a,&lda,b,&ldb,w,work,&lwork,rwork,&lrwork,iwork,&liwork,&info,len0,len1)
+    callprotoargument F_INT*,char*,char*,F_INT*,<ctype2c>*,F_INT*,<ctype2c>*,F_INT*,<ctype2>*,<ctype2c>*,F_INT*,<ctype2>*,F_INT*,F_INT*,F_INT*,F_INT*,F_INT,F_INT
 
     <ftype2c> intent(in,copy,aligned8,out,out=v),check(shape(a,0)==shape(a,1)),dimension(n,n) :: a
     <ftype2c> intent(in,copy,aligned8),check(shape(b,0)==shape(b,1)),check(shape(b,0)==n),dimension(n,n),depend(n) :: b
@@ -1225,12 +1304,14 @@ subroutine <prefix2c>hegvd(itype,jobz,uplo,n,lda,ldb,w,a,b,work,lwork,rwork,lrwo
     <ftype2> intent(out),dimension(n),depend(n) :: w
     integer intent(out) :: info
 
+    integer intent(hide) :: len0 = 1
+    integer intent(hide) :: len1 = 1
 end subroutine <prefix2c>hegvd
 
 !
 ! Expert routines for generalized eigenvalue problem
 !
-subroutine <prefix2>sygvx(itype,jobz,range,uplo,n,a,lda,b,ldb,vl,vu,il,iu,abstol,w,z,m,ldz,work,lwork,iwork,ifail,info)
+subroutine <prefix2>sygvx(itype,jobz,range,uplo,n,a,lda,b,ldb,vl,vu,il,iu,abstol,w,z,m,ldz,work,lwork,iwork,ifail,info,len0,len1,len2)
     ! (S/D)SYGVX computes selected eigenvalues, and optionally, eigenvectors
     ! of a real generalized symmetric-definite eigenproblem, of the form
     ! A*x=(lambda)*B*x,  A*Bx=(lambda)*x,  or B*A*x=(lambda)*x.  Here A
@@ -1238,8 +1319,8 @@ subroutine <prefix2>sygvx(itype,jobz,range,uplo,n,a,lda,b,ldb,vl,vu,il,iu,abstol
     ! Eigenvalues and eigenvectors can be selected by specifying either a
     ! range of values or a range of indices for the desired eigenvalues.
 
-    callstatement (*f2py_func)(&itype,jobz,range,uplo,&n,a,&lda,b,&ldb,&vl,&vu,&il,&iu,&abstol,&m,w,z,&ldz,work,&lwork,iwork,ifail,&info)
-    callprotoargument F_INT*,char*,char*,char*,F_INT*,<ctype2>*,F_INT*,<ctype2>*,F_INT*,<ctype2>*,<ctype2>*,F_INT*,F_INT*,<ctype2>*,F_INT*,<ctype2>*,<ctype2>*,F_INT*,<ctype2>*,F_INT*,F_INT*,F_INT*,F_INT*
+    callstatement (*f2py_func)(&itype,jobz,range,uplo,&n,a,&lda,b,&ldb,&vl,&vu,&il,&iu,&abstol,&m,w,z,&ldz,work,&lwork,iwork,ifail,&info,len0,len1,len2)
+    callprotoargument F_INT*,char*,char*,char*,F_INT*,<ctype2>*,F_INT*,<ctype2>*,F_INT*,<ctype2>*,<ctype2>*,F_INT*,F_INT*,<ctype2>*,F_INT*,<ctype2>*,<ctype2>*,F_INT*,<ctype2>*,F_INT*,F_INT*,F_INT*,F_INT*,F_INT,F_INT,F_INT
     
     integer optional,intent(in),check(itype>0||itype<4) :: itype=1
     character optional,intent(in),check(*jobz=='N'||*jobz=='V') :: jobz="V"
@@ -1267,13 +1348,16 @@ subroutine <prefix2>sygvx(itype,jobz,range,uplo,n,a,lda,b,ldb,vl,vu,il,iu,abstol
     integer intent(out),dimension((jobz[0]=='N'?0:n)),depend(jobz,n):: ifail
     integer intent(out) :: info
 
+    integer intent(hide) :: len0 = 1
+    integer intent(hide) :: len1 = 1
+    integer intent(hide) :: len2 = 1
 end subroutine <prefix2>sygvx
 
-subroutine <prefix2>sygvx_lwork(itype,uplo,n,a,lda,b,ldb,vl,vu,il,iu,abstol,m,w,z,ldz,work,lwork,iwork,ifail,info)
+subroutine <prefix2>sygvx_lwork(itype,uplo,n,a,lda,b,ldb,vl,vu,il,iu,abstol,m,w,z,ldz,work,lwork,iwork,ifail,info,len0,len1,len2)
     ! LWORK Query routine for (s/d)sygvx
     fortranname <prefix2>sygvx
-    callstatement (*f2py_func)(&itype,"N","A",uplo,&n,&a,&lda,&b,&ldb,&vl,&vu,&il,&iu,&abstol,&m,&w,&z,&ldz,&work,&lwork,&iwork,&ifail,&info)
-    callprotoargument F_INT*,char*,char*,char*,F_INT*,<ctype2>*,F_INT*,<ctype2>*,F_INT*,<ctype2>*,<ctype2>*,F_INT*,F_INT*,<ctype2>*,F_INT*,<ctype2>*,<ctype2>*,F_INT*,<ctype2>*,F_INT*,F_INT*,F_INT*,F_INT*
+    callstatement (*f2py_func)(&itype,"N","A",uplo,&n,&a,&lda,&b,&ldb,&vl,&vu,&il,&iu,&abstol,&m,&w,&z,&ldz,&work,&lwork,&iwork,&ifail,&info,len0,len1,len2)
+    callprotoargument F_INT*,char*,char*,char*,F_INT*,<ctype2>*,F_INT*,<ctype2>*,F_INT*,<ctype2>*,<ctype2>*,F_INT*,F_INT*,<ctype2>*,F_INT*,<ctype2>*,<ctype2>*,F_INT*,<ctype2>*,F_INT*,F_INT*,F_INT*,F_INT*,F_INT,F_INT,F_INT
 
     integer intent(in):: n
     character optional,intent(in),check(*uplo=='U'||*uplo=='L') :: uplo='L'
@@ -1299,17 +1383,20 @@ subroutine <prefix2>sygvx_lwork(itype,uplo,n,a,lda,b,ldb,vl,vu,il,iu,abstol,m,w,
     <ftype2> intent(out):: work
     integer intent(out):: info
 
+    integer intent(hide) :: len0 = 1
+    integer intent(hide) :: len1 = 1
+    integer intent(hide) :: len2 = 1
 end subroutine <prefix2>sygvx_lwork
 
-subroutine <prefix2c>hegvx(itype,jobz,range,uplo,n,a,lda,b,ldb,vl,vu,il,iu,abstol,w,z,m,ldz,work,lwork,rwork,iwork,ifail,info)
+subroutine <prefix2c>hegvx(itype,jobz,range,uplo,n,a,lda,b,ldb,vl,vu,il,iu,abstol,w,z,m,ldz,work,lwork,rwork,iwork,ifail,info,len0,len1,len2)
     ! (C/Z)HEGVX computes selected eigenvalues, and optionally, eigenvectors
     ! of a complex generalized Hermitian-definite eigenproblem, of the form
     ! A*x=(lambda)*B*x,  A*Bx=(lambda)*x,  or B*A*x=(lambda)*x.  Here A and
     ! B are assumed to be Hermitian and B is also positive definite.
     ! Eigenvalues and eigenvectors can be selected by specifying either a
     ! range of values or a range of indices for the desired eigenvalues.
-    callstatement (*f2py_func)(&itype,jobz,range,uplo,&n,a,&lda,b,&ldb,&vl,&vu,&il,&iu,&abstol,&m,w,z,&ldz,work,&lwork,rwork,iwork,ifail,&info)
-    callprotoargument F_INT*,char*,char*,char*,F_INT*,<ctype2c>*,F_INT*,<ctype2c>*,F_INT*,<ctype2>*,<ctype2>*,F_INT*,F_INT*,<ctype2>*,F_INT*,<ctype2>*,<ctype2c>*,F_INT*,<ctype2c>*,F_INT*,<ctype2>*,F_INT*,F_INT*,F_INT*
+    callstatement (*f2py_func)(&itype,jobz,range,uplo,&n,a,&lda,b,&ldb,&vl,&vu,&il,&iu,&abstol,&m,w,z,&ldz,work,&lwork,rwork,iwork,ifail,&info,len0,len1,len2)
+    callprotoargument F_INT*,char*,char*,char*,F_INT*,<ctype2c>*,F_INT*,<ctype2c>*,F_INT*,<ctype2>*,<ctype2>*,F_INT*,F_INT*,<ctype2>*,F_INT*,<ctype2>*,<ctype2c>*,F_INT*,<ctype2c>*,F_INT*,<ctype2>*,F_INT*,F_INT*,F_INT*,F_INT,F_INT,F_INT
     
     integer optional,intent(in),check(itype>0||itype<4) :: itype=1
     character optional,intent(in),check(*jobz=='N'||*jobz=='V') :: jobz='V'
@@ -1338,13 +1425,16 @@ subroutine <prefix2c>hegvx(itype,jobz,range,uplo,n,a,lda,b,ldb,vl,vu,il,iu,absto
     integer intent(out),dimension((jobz[0]=='N'?0:n)),depend(jobz,n):: ifail
     integer intent(out) :: info
 
+    integer intent(hide) :: len0 = 1
+    integer intent(hide) :: len1 = 1
+    integer intent(hide) :: len2 = 1
 end subroutine <prefix2c>hegvx
 
-subroutine <prefix2c>hegvx_lwork(itype,uplo,n,a,lda,b,ldb,vl,vu,il,iu,abstol,m,w,z,ldz,work,lwork,rwork,iwork,ifail,info)
+subroutine <prefix2c>hegvx_lwork(itype,uplo,n,a,lda,b,ldb,vl,vu,il,iu,abstol,m,w,z,ldz,work,lwork,rwork,iwork,ifail,info,len0,len1,len2)
     ! LWORK Query routine for (c/z)hegvx
     fortranname <prefix2c>hegvx
-    callstatement (*f2py_func)(&itype,"N","A",uplo,&n,&a,&lda,&b,&ldb,&vl,&vu,&il,&iu,&abstol,&m,&w,&z,&ldz,&work,&lwork,&rwork,&iwork,&ifail,&info)
-    callprotoargument F_INT*,char*,char*,char*,F_INT*,<ctype2c>*,F_INT*,<ctype2c>*,F_INT*,<ctype2>*,<ctype2>*,F_INT*,F_INT*,<ctype2>*,F_INT*,<ctype2>*,<ctype2c>*,F_INT*,<ctype2c>*,F_INT*,<ctype2>*,F_INT*,F_INT*,F_INT*
+    callstatement (*f2py_func)(&itype,"N","A",uplo,&n,&a,&lda,&b,&ldb,&vl,&vu,&il,&iu,&abstol,&m,&w,&z,&ldz,&work,&lwork,&rwork,&iwork,&ifail,&info,len0,len1,len2)
+    callprotoargument F_INT*,char*,char*,char*,F_INT*,<ctype2c>*,F_INT*,<ctype2c>*,F_INT*,<ctype2>*,<ctype2>*,F_INT*,F_INT*,<ctype2>*,F_INT*,<ctype2>*,<ctype2c>*,F_INT*,<ctype2c>*,F_INT*,<ctype2>*,F_INT*,F_INT*,F_INT*,F_INT,F_INT,F_INT
 
     integer intent(in):: n
     character optional,intent(in),check(*uplo=='U'||*uplo=='L') :: uplo='L'
@@ -1371,12 +1461,15 @@ subroutine <prefix2c>hegvx_lwork(itype,uplo,n,a,lda,b,ldb,vl,vu,il,iu,abstol,m,w
     <ftype2c> intent(out):: work
     integer intent(out):: info
 
+    integer intent(hide) :: len0 = 1
+    integer intent(hide) :: len1 = 1
+    integer intent(hide) :: len2 = 1
 end subroutine <prefix2c>hegvx_lwork
 
-subroutine <prefix>syequb(lower,n,a,lda,s,scond,amax,work,info)
+subroutine <prefix>syequb(lower,n,a,lda,s,scond,amax,work,info,len0)
 
-    callstatement (*f2py_func)((lower?"L":"U"),&n,a,&lda,s,&scond,&amax,work,&info)
-    callprotoargument char*,F_INT*,<ctype>*,F_INT*,<ctypereal>*,<ctypereal>*,<ctypereal>*,<ctype>*,F_INT*
+    callstatement (*f2py_func)((lower?"L":"U"),&n,a,&lda,s,&scond,&amax,work,&info,len0)
+    callprotoargument char*,F_INT*,<ctype>*,F_INT*,<ctypereal>*,<ctypereal>*,<ctypereal>*,<ctype>*,F_INT*,F_INT
 
     integer intent(hide),depend(a) :: n = shape(a,1)
     integer intent(hide),depend(a) :: lda = MAX(1,shape(a,0))
@@ -1390,12 +1483,13 @@ subroutine <prefix>syequb(lower,n,a,lda,s,scond,amax,work,info)
     <ftypereal> intent(out) :: amax
     integer intent(out) :: info
 
+    integer intent(hide) :: len0 = 1
 end subroutine <prefix>syequb
 
-subroutine <prefix2c>heequb(lower,n,a,lda,s,scond,amax,work,info)
+subroutine <prefix2c>heequb(lower,n,a,lda,s,scond,amax,work,info,len0)
 
-    callstatement (*f2py_func)((lower?"L":"U"),&n,a,&lda,s,&scond,&amax,work,&info)
-    callprotoargument char*,F_INT*,<ctype2c>*,F_INT*,<ctype2>*,<ctype2>*,<ctype2>*,<ctype2c>*,F_INT*
+    callstatement (*f2py_func)((lower?"L":"U"),&n,a,&lda,s,&scond,&amax,work,&info,len0)
+    callprotoargument char*,F_INT*,<ctype2c>*,F_INT*,<ctype2>*,<ctype2>*,<ctype2>*,<ctype2c>*,F_INT*,F_INT
 
     integer intent(hide),depend(a) :: n = shape(a,1)
     integer intent(hide),depend(a) :: lda = MAX(1,shape(a,0))
@@ -1409,4 +1503,5 @@ subroutine <prefix2c>heequb(lower,n,a,lda,s,scond,amax,work,info)
     <ftype2> intent(out) :: amax
     integer intent(out) :: info
 
+    integer intent(hide) :: len0 = 1
 end subroutine <prefix2c>heequb
-- 
2.51.0

